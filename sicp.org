#+TITLE: NOTES: SICP "WIZARD" BOOK
#+DATE: [2014-09-09 Tue]

* About
  These are my notes about the programming examples and exercises as
  described in the Structure and interpretation of computer programs
  found in this [[https://mitpress.mit.edu/sicp/full-text/book/book.html][link]].

  Instead of using scheme to implement the examples, I used Elisp as
  an exercise to learn the language.

* Chapter 1
** Count-change example
#+BEGIN_SRC elisp
   (defun counting-change (amount)

     (defun cc (amount kinds-of-coins)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (= kinds-of-coins 0)) 0)
             (t (+ (cc amount (1- kinds-of-coins))
                   (cc (- amount (first-denomination kinds-of-coins))
                       kinds-of-coins)))))

     (defun first-denomination (kinds-of-coins)
       (cond ((= kinds-of-coins 1) 1)
             ((= kinds-of-coins 2) 5)
             ((= kinds-of-coins 3) 10)
             ((= kinds-of-coins 4) 25)
             ((= kinds-of-coins 5) 50)))

      (cc amount 5))

   (counting-change 11)
#+END_SRC
** Exponentiation
#+BEGIN_SRC elisp
    ; This process grows logarithmically both in space
    ; and number of steps, since every call to `fast-expt'
    ; the calculation is for an exponent 'n/2'
    (defun fast-expt (b n)
      (cond ((= n 0) 1)
            ((even? n) (square (fast-expt b (/ n 2))))
            (t (* b (fast-expt b (- n 1))))))
    (defun square (n)
      (* n n))
    (defun even? (n)
      (= (% n 2) 0))

    (fast-expt 2 7)
#+END_SRC

** Euclid's algorithm for GCD
#+BEGIN_SRC elisp
  (defun gcd (a b)
    (cond ((= b 0) a)
          (t (gcd b (% a b)))))
(gcd 4 20)
(fib 4)
#+END_SRC

** Testing primality of a number
#+BEGIN_SRC elisp
  ; This tests executes in [theta](sqrt(n))
  (defun prime? (n)
    (defun smallest-divisor (n)
      (defun find-divisor (n test-divisor)
        (defun divides? (a b)
          (= (% b a) 0))

        (defun square (x)
          (* x x))

        (cond ((> (square test-divisor) n) n)
              ((divides? test-divisor n) test-divisor)
              (t (find-divisor n (1+ test-divisor)))))
      (find-divisor n 2))
    (= (smallest-divisor n) n))

  ; Test
  (prime? 12)
#+END_SRC elisp
** Testing primality with Fermat little Theorem
#+BEGIN_SRC elisp
   ; if n is prime, then a^n is congruent to a modulo n

  (defun expmod (base exp m)
  ; This process computes the exponential of a number
  ; Modulo another.
    (cond ((= exp 0) 1)
          ((even? exp)
           (% (square (expmod base (/ exp 2) m))
                      m))
          (t
            (% (* base (expmod base (- exp 1) m))
	       m))))

   (defun fermat-test (n)
   ; For the fermat test need to choose a number between
   ; 1 and n-1 so use (1+ (random 1- n))
     (defun try-it (a)
       (= (expmod a n n) a))
     (try-it (1+ (random (1- n)))))

   (defun fast-prime? (n times)
     (cond ((= times 0) t)
           ((fermat-test n) (fast-prime? n (1- times)))
           (t nil)))

(fast-prime? 12 5)

; Properties of modulo operation used for expmod
; https://en.wikipedia.org/wiki/Modular_arithmetic#Remainders
(% (expt 6 8) 10)
(% (expt (% (expt 6 (/ 8 2)) 10) 2) 10)

(mod (expt 6 7) 7)
#+END_SRC

** 1.3.1 Procedures as arguments (sum)
#+BEGIN_SRC elisp
  (defun sum (ter a next b)
    (if (> a b)
      0
     (+ (funcall ter a)
        (sum ter (funcall next a) next b))))

  (defun pi-sum (a b)
    (setq max-lisp-eval-depth 6000)
    (defun pi-term (x)
      (/ 1.0 (* x (+ x 2))))
    (defun pi-next (x)
      (+ x 4))
    (sum #'pi-term a #'pi-next b))

(* 8 (pi-sum 1 1000))

  (defun integral (f a b dx)
    (defun add-dx (x) (+ x dx))
    (* (sum f (+ a (/ dx 2.0)) #'add-dx b) dx))

  (defun cube (x) (* x x x))

  (integral #'cube 0 1 0.01)
  (integral #'cube 0 1 0.001)
#+END_SRC

** 1.3.3 half-interval method
#+BEGIN_SRC elisp
  (defun search-aux (f neg-point pos-point)
    (let ((midpoint (average neg-point pos-point)))
      (if (close-enough? neg-point pos-point)
          midpoint
        (let ((testval (funcall f midpoint)))
          (cond ((positive? testval)
                 (search-aux f neg-point midpoint))
                ((negative? testval)
                 (search-aux f midpoint pos-point))
                (t midpoint))))))

  (defun close-enough? (x y)
    (< (abs (- x y)) 0.001))

  (defun negative? (x) (< x 0))
  (defun positive? (x) (not (negative? x)))
  (defun average (a b) (/ (+ a b) 2))

  (defun half-interval-method (f a b)
    "Method used to search zeros in a function."
    (let ((a-value (funcall f a))
          (b-value (funcall f b)))
      (cond ((and (negative? a-value) (positive? b-value))
             (search-aux f a b))
            ((and (negative? b-value) (positive? a-value))
             (search-aux f b a))
            (t (error "Values are not of opposite sign" a b)))))

  (half-interval-method #'sin 2.0 4.0)
  (half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                        1.0
                        2.0)
#+END_SRC

** 1.3.3 Finding fixed points of functions
#+BEGIN_SRC elisp
  ; A fixed point of a function is the point that
  ; satisfies f(x) = x
  ; This approach is based on taking a function
  ; and apply it repeatedly until we find two
  ; successive values whose difference is less than
  ; some prescribed tolerance:
  (defvar tolerance 0.00001)
  (defun fixed-point (f first-guess)
    (defun close-enough? (v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (defun try (guess)
      (let ((next (funcall f guess)))
        (if (close-enough? guess next)
          next
          (try next))))
    (try first-guess))

  (fixed-point #'cos 1.0)  ; => 0.7390822985224024
  (cos 0.7390822985224024) ; => 0.7390870426953322
  (fixed-point (lambda (x) (+ (sin x) (cos x))) 1.0)

  (defun sqrt-with-fixed-point (x)
    ; Need to average y and x / y to prevent oscillating
    (fixed-point (lambda (y) (average y (/ x y))) 1.0))
  (sqrt-with-fixed-point 4)
#+END_SRC

** 1.3.4 Average Damp
#+BEGIN_SRC elisp
  (defun average-damp (f)
    `(lambda (x) (average x (,f x))))
  (funcall (average-damp #'square) 10)

  ; reformulate square-root procedure
  (defun square-root (x)
    (fixed-point (average-damp (lambda (y) (/ x y)))
                 1.0))
#+END_SRC
#+BEGIN_SRC racket
  (define (average x y)
    (/ (+ x y) 2.0))
  (define (average-damp f)
    (lambda (x) (average x (f x))))
  ((average-damp square) 10)
#+END_SRC
** 1.3.4 Derivatives
#+BEGIN_SRC elisp
  (defun deriv (g)
    (let ((dx 0.0001))
      `(lambda (x)
        (/ (- (,g (+ x ,dx)) (,g x)) ,dx))))

  (defun cube (x) (* x x x))
  (funcall (deriv #'cube) 5.0)
  (funcall (deriv (lambda (x) (* x x x))) 5.0)

  (defun call-it (g)
    (funcall (deriv g) 5.0))

  (call-it (lambda (x) (* x x x)))

#+END_SRC
** 1.3.4 Newton's method as a fixed point process
#+BEGIN_SRC elisp
  (defun sqrt-newton (w)
    (defun newton-transform (g)
      `(lambda (x)
         (- x (/ (funcall #',g x) (funcall (deriv #',g) x)))))

    (defun newtons-method (g guess)
      (fixed-point (newton-transform g) guess))

    (newtons-method (lambda (y) (- (square y) w)) 1.0))

  (sqrt-newton 100.0)
#+END_SRC
** 1.3.4 Fixed point of transform
#+BEGIN_SRC elisp
  (defun fixed-point-of-transform (g transform guess)
    (fixed-point (funcall transform g) guess))

  ; recast of first square root
  (defun sqrt-recast1 (w)
    (fixed-point-of-transform (lambda (y) (/ w y))
                              #'average-damp
                              1.0))
  (sqrt-recast1 4.0)

  (defun sqrt-recast2 (w)
    (fixed-point-of-transform (lambda (y) (- (square y) w))
                              #'newton-transform
                              1.0))
  (sqrt-recast2 40.0)
#+END_SRC

** Exercises
*** Exercise 1.1
   - Below is a sequence of expressions.  What is the
     result printed by the interpreter in response to each expression?
     Assume that the sequence is to be evaluated in the order in which
     it is presented.

#+BEGIN_SRC elisp
          10

          (+ 5 3 4)

          (- 9 1)

          (/ 6 2)

          (+ (* 2 4) (- 4 6))

          (defvar a 3)

          (defvar b (+ a 1))

          (+ a b (* a b))

          (= a b)

          (if (and (> b a) (< b (* a b)))
              b
              a)

          (cond ((= a 4) 6)
                ((= b 4) (+ 6 7 a))
                (else 25))

          (+ 2 (if (> b a) b a))

          (* (cond ((> a b) a)
                   ((< a b) b)
                   (else -1))
             (+ a 1))
#+END_SRC

*** Exercise 1.2
   - Translate the following expression into prefix form.

#+BEGIN_SRC text

          5 + 4 + (2 - (3 - (6 + 4/5)))
          -----------------------------
                 3(6 - 2)(2 - 7)
#+END_SRC

#+BEGIN_SRC
          (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
#+END_SRC

*** Exercise 1.3
   - Define a procedure that takes three numbers as arguments and
     returns the sum of the squares of the two larger numbers.

#+BEGIN_SRC
     (defun sum-of-square-of-two-larger (a b c)
     ;; sort can be used, but try to use the tools presented up to this
     ;; chapter.
     (setq g1 a)
     (setq g2 b)
     (cond ((< a c) (setq g1 c))
           ((< b c) (setq g2 c)))
     (+ (* g1 g1) (* g2 g2)))
#+END_SRC

*** Exercise 1.4
   - Observe that our model of evaluation allows for combinations
     whose operators are compound expressions.  Use this observation
     to describe the behavior of the following procedure:

#+BEGIN_SRC
     (defun a-plus-abs-b (a b)
       (funcall (if (> b 0) '+ '-) a b))
#+END_SRC
   - Evaluating the if special form yields the symbol of the
     operation that will be performed between a and b based on the
     value of b.

*** Exercise 1.5
     - Ben Bitdiddle has invented a test to determine whether the
       interpreter he is faced with is using applicative-order
       evaluation or normal-order evaluation.  He defines the
       following two procedures:
#+BEGIN_SRC elisp
       (defun p () (p))

       (defun test (x y)
         (if (= x 0)
            0
           y))
#+END_SRC
     -Then he evaluates the expression
#+BEGIN_SRC elisp
          (test 0 (p))
#+END_SRC
     - What behavior will Ben observe with an interpreter that uses
       applicative-order evaluation?  What behavior will he observe
       with an interpreter that uses normal-order evaluation?  Explain
       your answer.  (Assume that the evaluation rule for the special
       form `if' is the same whether the interpreter is using normal
       or applicative order: The predicate expression is evaluated
       first, and the result determines whether to evaluate the
       consequent or the alternative expression.)

     - A. The `p' function is a infinite recursive function, if the
       evaluation method is a `normal-order', then the `p' won't be
       evaluated since it's never required. In the contrary if the
       evaluation method is applicative-order it will evaluate `p'
       when `test' is called, hence the function will never return.

#+BEGIN_SRC elisp
   (defun sqrt-iter (guess x)
     (if (good-enough-p guess x)
         guess
       (sqrt-iter (improve guess x) x)))

   ;; A guess is improved by averaging it
   (defun improve (guess x)
     (average guess (/ x guess)))

   (defun average (x y)
     (/ (+ x y) 2))

   (defun good-enough-p (guess x)
     (< (abs (- (square guess) x)) 0.001))

   (defun square (x) (* x x))

   (defun my/sqrt (x)
     (sqrt-iter 1.0 x))

   (my/sqrt 9)
#+END_SRC

*** Exercise 1.6
    - If we substitute the special form `if' with a regular definition
      `new-if', the `new-if' will evaluate the `PREDICATE',
      `THEN-CLAUSE' and `ELSE-CLAUSE' will be evaluated in
      applicative-order, this will cause the `ELSE-CLAUSE' to
      evaluate making the recursive call never returning. On the
      other hand the `if' special form evaluates in normal-order
      which won't evaluate the `ELSE-CLAUSE' until needed.
#+BEGIN_SRC
   (defun new-if (predicate then-clause else-clause)
     (cond (predicate then-clause)
           (t else-clause)))
#+END_SRC

*** Exercise 1.7
    - With small numbers, when the number to be calculated is smaller
      than the tolerance '0.0001' then the calculated value will not
      be precise.
    - With a big number a float type loses precision so doing a
      subtraction (- 1e100 1) is still 1e100 then the `good-enough-p'
      and `improve' procedures will return the same value over and
      over because of the lack of precision. Examples:

#+BEGIN_SRC elisp
  (my/sqrt .00001)   ; small number
  (my/sqrt 1e+100)   ; big number
1e+016
#+END_SRC

    - The alternative strategy would be
#+BEGIN_SRC elisp
  (defun good-enough-p (prev-guess new-guess)
    (< (abs (- prev-guess new-guess)) 1e-5))

  (defun sqrt-iter (prev-guess new-guess x)
    (if (good-enough-p prev-guess new-guess)
       new-guess
      (sqrt-iter new-guess (improve new-guess x) x)))

  (defun my/sqrt (x)
    (sqrt-iter 0.0 1.0 x))

  (my/sqrt 9)
#+END_SRC

*** Exercise 1.8
    - Implementation to calculate cube roots
#+BEGIN_SRC elisp
  (defun cube-iter (prev-guess new-guess x)
    (if (good-enough-p prev-guess new-guess)
       new-guess
      (cube-iter new-guess (cube-improve new-guess x) x)))

   (defun cube-improve (guess x)
    (/ (+ (/ x (square guess)) (* 2 guess)) 3))

  (defun my/cube-root (x)
    (cube-iter 0.0 1.0 x))

   (my/cube-root 125)
#+END_SRC

*** Exercise 1.9
#+BEGIN_SRC elisp
    (defun plus-v1 (a b)
      (if (= a 0)
         b
        (1+ (plus-v1 (1- a) b))))

   (defun plus-v2 (a b)
      (if (= a 0)
         b
         (plus-v2 (1- a) (1+ b))))

   ;; Expand using substitution model
   (plus-v1 4 5)
   (1+ (plus-v1 3 5))
   (1+ (1+ (plus-v1 2 5)))
   (1+ (1+ (1+ (plus-v1 1 5))))
   (1+ (1+ (1+ (1+ (plus-v1 0 5)))))
   (1+ (1+ (1+ (1+ 5))))
   (1+ (1+ (1+ 6)))
   (1+ (1+ 7))
   (1+ 8)
   9

   (plus-v2 4 5)
   (plus-v2 (1- 4) (1+ 5))
   (plus-v2 (1- 3) (1+ 6))
   (plus-v2 (1- 2) (1+ 7))
   (plus-v2 (1- 1) (1+ 8))
   (plus-v2 0 9)
   9
#+END_SRC
    - Based on the model substitution, `plus-v1' is a recursive
      process and `plus-v2' is an iterative process.

*** Exercise 1.10: Ackermann's function
#+BEGIN_SRC elisp
  (defun A (x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (t (A (- x 1)
                (A x (- y 1))))))

   (A 1 10)  ; Result 1024  = (expt 2 10)
   (A 2 4)   ; Result 65536 = (expt 2 16)
   (A 3 3)   ; Result 65536 = (expt 3 3)

   (defun f (n) (A 0 n))   ; 2^n
   (defun g (n) (A 1 n))   ; 2^n
   (defun h (n) (A 2 n))   ; 2^(h(n-1)) for n > 2 or 2^2^2... where the number of 2's is n
   (defun k (n) (* 5 n n)) ; 5n^2
#+END_SRC

*** Exercise 1.11
#+BEGIN_SRC elisp
  (defun f-recursive (n)
    (cond ((< n 3) n)
          (t (+ (f-recursive (- n 1))
                (* 2 (f-recursive (- n 2)))
                (* 3 (f-recursive (- n 3)))))))

   (defun f-iterative (n)
     (defun f-iter (a b c count)
       (cond ((> count n) c)
             (t (f-iter b c (+ (* 3 a) (* 2 b) c) (1+ count)))))
     (cond ((< n 3) n)
           (t (f-iter 0 1 2 3))))

   (f-iterative 27) ; = 288269163
   (f-recursive 27) ; = 288269163
#+END_SRC
*** Exercise 1.12
#+BEGIN_SRC elisp
  (defun pascal-triangle (n m)
    (cond ((or (< n 1) (< m 1)) 0)
          ((or (= m 1) (= n m)) 1)
          (t (+ (pascal-triangle (1- n) (1- m))
                (pascal-triangle (1- n) m)))))
#+END_SRC
*** Exercise 1.13
    - Show that the definition works for the two firs element of the
      series fib(0) = 0 and fib(1) = 1
    - Now show the definitions works for any k such that:
        fib(k) = fib(k-1) + fib(k-1)

*** Exercise 1.14
    - Easy to draw in a piece of paper, it would be cool to draw it
      using Graphviz
    - Depth of tree grows linear [theta](n)
    - Number of steps, when the number of coins k = 1, the calls to
      `cc' is `m' which is the total amount. When `k' = 2 a linear
      number of calls to the `cc' functions are made, but also each
      of this k = 2 calls, generates a k = 1 tree, so this makes the
      growth m^2 and so on, so the growth steps is [theta](n^k)

*** Exercise 1.15
#+BEGIN_SRC elisp
    (defun cube (x) (* x x x))
    (defun p (x) (- (* 3 x) (* 4 (cube x))))
    (defun sine (angle)
       (if (not (> (abs angle) 0.1))
           angle
         (p (sine (/ angle 3.0)))))

(sine 300)
(sin 300)

;; Two calculate `a.' how many times is the procedure `p' applied
(defun how-many-times-called-when (n)
   (defun iter (y x)
     (if (<= y 0.1)
        x
      (iter (/ y 3.0) (1+ x))))
   (iter n 0))

(how-many-times-called-when 12.5)
(log 12.5 3)
#+END_SRC
    - The order of growth is [theta](log n)

*** Exercise 1.16
#+BEGIN_SRC elisp
    (defun expt-iter (b n)
      (defun square (x) (* x x))
      (defun even? (x) (if (= (% x 2) 0) t nil))

      (defun iter (b n a)
        (cond ((= n 0) a)
              ((even? n) (iter (square b) (/ n 2) a))
              (t (iter b (- n 1) (* a b)))))
       (iter b n 1))
#+END_SRC
*** Exercise 1.17
#+BEGIN_SRC elisp
    ;; fast recursive
    (defun fast-mult (a b)
      (defun halve (n) (/ n 2))
      (defun double (n) (+ n n))
      (defun even? (n) (if (= (% n 2) 0) t nil))
      ;; switch a and b in case b is greater than a
      (cond (or (= a 0) (= b 0) 0)
            ((= b 1) a)
            ((even? b) (fast-mult (double a) (halve b)))
            (t (+ a (fast-mult a (- b 1))))))
#+END_SRC
*** Exercise 1.18
#+BEGIN_SRC elisp
     ;; fast iterative
     (defun fast-mult-iter (a b)
      (defun halve (n) (/ n 2))
      (defun double (n) (+ n n))
      (defun even? (n) (if (= (% n 2) 0) t nil))
      (defun iter (a b c)
        (cond ((= b 0) c)
              ((even? b) (iter (double a) (halve b) c))
              (t (iter a (- b 1) (+ c a)))))
      ; switch parameters if a > b
      (if (< a b)
         (iter a b 0)
        (iter b a 0)))
#+END_SRC

*** Exercise 1.19
#+BEGIN_SRC elisp
  (defun fib (n)
    (fib-iter 1 0 0 1 n))

  (defun fib-iter (a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (* p p) (* q q))
                     (+ (* q q) (* 2 p q))
                     (/ count 2)))
          (t (fib-iter (+ (* b q) (* a q) (* a p))
                       (+ (* b p) (* a q))
                       p
                       q
                       (- count 1)))))

   ; Apply transform T_pq then apply the same transform to the result
   ; to get T_pq^2 group the elements to get the form of the transform
   ; definition, from there p' and q' will be evident.
#+END_SRC

*** Exercise 1.20
#+BEGIN_SRC elisp
    ; Normal-order evaluation of gcd
    (gcd 206 40)

    (if 40)
      (gcd 40 (% 206 40)) ; reminders not evaluated until reduction

    (if (% 206 40)) ; 1
       (gcd (% 206 40) (% 40 (% 206 40)))

    (if (% 40 (% 206 40))) ; 2
      (gcd (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40))))

    (if (% (% 206 40) (% 40 (% 206 40))))  ; 4
      (gcd (% (% 206 40) (% 40 (% 206 40))) (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40)))))

    (if (% (% 40 (% 206 40)) (% (% 206 40) (% 40 (% 206 40))))) ; 7
      (% (% 206 40) (% 40 (% 206 40))) ; reduction 4

    ; ifs       : 14
    ; reduction : 4
    ; 18 reminder operations using normal-order

    ; Applicative order
    (gcd 206 40)
    (gcd 40 6)
    (gcd 6 4)
    (gcd 4 2)
    (gcd 2 0)
    ; 4 reminder operations are performed
#+END_SRC

*** Exercise 1.21
#+BEGIN_SRC elisp
  (defun smallest-divisor (n)
    (defun find-divisor (n test-divisor)
      (defun smallest-divisor (n)
        (find-divisor n 2))
      (defun divides? (a b)
        (= (% b a) 0))
      (cond ((> (square test-divisor) n) n)
            ((divides? test-divisor n) test-divisor)
            (t (find-divisor n (1+ test-divisor)))))
    (find-divisor n 2))

(smallest-divisor 199)   ; => 199
(smallest-divisor 1999)  ; => 1999
(smallest-divisor 19999) ; => 7
#+END_SRC
*** Exercise 1.22
#+BEGIN_SRC elisp
    ; Answers
    ; This implementation was taken from
    ; http://www.kendyck.com/archives/2005/05/23/solution-to-sicp-exercise-122/
    ; The reason is that I was getting problem testing with bit integers

    ; Example on how to print number of passed milliseconds
    (let* ((start (current-time))
           (end (progn (sit-for 5) (current-time))))
          (format-time-string "%3N" (time-subtract end start)))

(defun prime? (n)
  (defun smallest-divisor (n)
    (defun find-divisor (n test-divisor)
      (defun divides? (a b)
        (= (% b a) 0))

      (defun square (x)
        (* x x))

      (cond ((> (square test-divisor) n) n)
            ((divides? test-divisor n) test-divisor)
            (t (find-divisor n (+ 1 test-divisor)))))
    (find-divisor n 2))
  (= (smallest-divisor n) n))

(defun timed-prime-test (n)
  (insert (format "%d " n))
  (start-prime-test n (current-time)))

(defun start-prime-test (n start-time)
  (if (prime? n)
      (report-prime
       (time-subtract (current-time) start-time))))

(defun report-prime (elapsed-time)
  (insert (format " *** %s ns\n"
                  (format-time-string "%N" elapsed-time))))

(defun search-for-next-prime (starting-at)
  (if (prime? starting-at)
      starting-at
      (search-for-next-prime (+ starting-at 2))))

(defun search-for-primes (find-n starting-at)
  (if (= find-n 0)
      nil
      (let ((next-prime (search-for-next-prime starting-at)))
        (cons next-prime
              (search-for-primes (- find-n 1) (+ next-prime 2))))))

(defun time-prime-tests (primes)
  (mapc 'timed-prime-test primes))

; Between each run this is the complexity should run
(sqrt 10) ; 3.1622776601683795

(time-prime-tests (search-for-primes 3 1001))
1009  *** 010000000 ns
1013  *** 000000000 ns
1019  *** 000000000 ns

(time-prime-tests (search-for-primes 3 10001))
10007  *** 010000000 ns
10009  *** 000000000 ns
10037  *** 000000000 ns

(time-prime-tests (search-for-primes 3 100001))
100003  *** 010000000 ns
100019  *** 000000000 ns
100043  *** 000000000 ns


(time-prime-tests (search-for-primes 3 1000001))
1000003  *** 000000000 ns
1000033  *** 010000000 ns
1000037  *** 000000000 ns


(time-prime-tests (search-for-primes 3 10000001))
10000019  *** 020000000 ns
10000079  *** 130000000 ns
10000103  *** 150000000 ns


#+END_SRC

*** Exercise 1.23
#+BEGIN_SRC elisp
(three-primes-from 1000000)

   ; Measure using 1.22 => 73000 usec
   ; Measure using 1.23 => 36000 usec
   ; it was expected to run twice faster
   ; A. It ran around twice faster
   (/ 73000 36000.0) 2.0277777777777777

  ; This tests executes in [theta](sqrt(n))
  (defun prime? (n)
    (= (smallest-divisor n) n))

  (defun smallest-divisor (n)
    (find-divisor n 2))

  (defun find-divisor (n test-divisor)
    (defun next (n)
      (if (= n 2) 3 (+ n 2)))
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (t (find-divisor n (next test-divisor)))))

  (defun divides? (a b)
    (= (% b a) 0))

  (defun square (x)
    (* x x))
#+END_SRC
*** Exercise 1.24
#+BEGIN_SRC elisp
  (defun even? (n)
    (if (= (% n 2) 0) t nil))

  (defun expmod (base exp m)
  ; This process computes the exponential of a number
  ; Modulo another.
    (cond ((= exp 0) 1)
          ((even? exp)
           (% (square (expmod base (/ exp 2) m))
                      m))
          (t
            (% (* base (expmod base (- exp 1) m))
	       m))))

   (defun fermat-test (n)
   ; For the fermat test need to choose a number between
   ; 1 and n-1 so use (1+ (random 1- n))
     (defun try-it (a)
       (= (expmod a n n) a))
     (try-it (1+ (random (1- n)))))

   (defun fast-prime? (n times)
     (cond ((= times 0) t)
           ((fermat-test n) (fast-prime? n (1- times)))
           (t nil)))

    (defun timed-prime-test (n)
      (start-prime-test n (current-time)))

    (defun start-prime-test (n start-time)
      (if (fast-prime? n 5)
        (report-prime n (format-time-string
                          "%6N"
                          (time-subtract (current-time) start-time)))))

    (defun report-prime (n formated-time)
      (insert (format "%d *** %s\n" n  formated-time))
      t)

    (defun three-primes-from (low-int)
      (defun aux-primes (n count)
        (cond ((>= count 3) t)
              ((timed-prime-test n) (aux-primes (+ n 2) (1+ count)))
              (t (aux-primes (+ n 2) count))))

      ;; Allow emacs more recursion and variable bind depth
      (setq max-lisp-eval-depth 20000)
      (setq max-specpdl-size 10000)
      (if (= (% low-int 2) 0)
        (aux-primes (1+ low-int)  0)
       (aux-primes low-int 0)))

; Results from 1.22
; Time starting on 10000 = 6000 usecs
; Time starting on 100000        = 16000 usecs
;   Expected (* (sqrt 10) 6000)  = 18973.665961010
; Time starting on 1000000       = 73000 usecs
;  Expected  (* (sqrt 10) 16000) = 50596.44256269407

; Results from 1.23
(three-primes-from 1000000)
; for 1000000
; Measure using 1.22 => 73000 usec
; Measure using 1.23 => 36000 usec
; it was expected to run twice faster
; A. It ran around twice faster
; (/ 73000 36000.0) 2.0277777777777777

; Results from 1.24
(three-primes-from 1000)
10007 *** 000000
10009 *** 001000
10037 *** 000000 ; => 1000

; One problem here is the amount of recursion required by
; this implementation. Adjusted the values of max-depth and
; max-spec, but still not able to test number in the order of
; 100000
#+END_SRC
*** Exercise 1.25
#+BEGIN_SRC elisp
  (defun expmod (base exp m)
  ; This process computes the exponential of a number
  ; Modulo another.
    (% (fast-expt base exp) n))

  ; Using this  form of expmod utilizes even more recursion
  ; than the originally defined expmod
#+END_SRC

*** Exercise 1.26
#+BEGIN_SRC elisp
  ; Louis is calculating (expmod base (/ exp 2) m) twice for each call
  ; of reminder. This is creating a tree recursion call which grows
  ; exponentially.
#+END_SRC
*** Exercise 1.27
#+BEGIN_SRC elisp
    (defun expmod (base exp m)
    ; This process computes the exponential of a number
    ; Modulo another.
      (cond ((= exp 0) 1)
            ((even? exp)
             (% (square (expmod base (/ exp 2) m))
                        m))
            (t
              (% (* base (expmod base (- exp 1) m))
                 m))))

     (defun fermat-test-on-carmichaels (n)
     ; For the fermat test need to choose a number between
     ; 1 and n-1 so use (1+ (random 1- n))
       (defun try-it (a)
         (= (expmod a n n) a))
       (defun fermat-test-for-every-a (curr)
         (cond ((= curr 0) t)
               ((try-it curr) (fermat-test-for-every-a (1- curr)))
               (t nil)))
       (fermat-test-for-every-a (1- n)))

  ; The smallest Carmichaels 561, 1105, 1729, 2465, 2821, and 6601.
  (fast-prime? 561 5)
  (mapcar 'fermat-test-on-carmichaels '(561 1105 1729 2465 2821  6601))
#+END_SRC
*** Exercise 1.28
#+BEGIN_SRC elisp
     ; if n is prime, then a^n is congruent to a modulo n
    (defun even? (n)
      (if (= 0 (% n 2)) t nil))
    (defun square (n) (* n n))
    (defun mr-expmod (base exp m)
    ; This process computes the exponential of a number
    ; Modulo another.
      (cond ((= exp 0) 1)
            ((even? exp)
             (% (square (trivial-root (mr-expmod base (/ exp 2) m) m))
                m))
            (t
             (% (* base (mr-expmod base (- exp 1) m))
                m))))

     (defun trivial-root (a n)
       (cond ((and (not (or (= a 1) (= a (1- n))))
                   (= (% (square a) n) 1)) 0)
             (t a)))

     (defun miller-rabin-test (n)
     ; For the this test need to choose a number between
     ; 1 and n-1 so use (1+ (random 1- n))
       (defun try-it (a)
         (= (mr-expmod a (1- n) n) 1))
       (try-it (1+ (random (1- n)))))

     (defun mr-fast-prime? (n times)
       (cond ((= times 0) t)
             ((miller-rabin-test n) (mr-fast-prime? n (1- times)))
             (t nil)))

     (defun mr-fast (n)
       (mr-fast-prime? n 5))

     (defun fermat-fast (n)
       (fast-prime? n 5))

  (mapcar 'mr-fast '(561 1105 1729 2465 2821  6601))
  (mapcar 'fermat-fast '(561 1105 1729 2465 2821  6601))
#+END_SRC

*** Exercise 1.29
#+BEGIN_SRC elisp
  (defun simpson-integral (f a b n)
    (setq max-lisp-eval-depth 10000)
    (setq h (/ (- b a) n))
    (defun even? (x) (= 0 (% x 2)))
    (defun y-k (k) (funcall f (+ a (* k h))))
    (defun ter (k)
      (* (y-k k) (if (even? k) 2 4)))
    (* (/ h 3) (+ (y-k 0) (y-k n) (sum #'ter 1 #'1+ (1- n)))))

  (simpson-integral #'cube 0 1 400.0)
#+END_SRC

*** Exercise 1.30
#+BEGIN_SRC elisp
  (defun sum (ter a next b)
    (defun iter (a result)
      (if (> a b)
          result
        (iter (funcall next a) (+ result (funcall ter a)))))
    (iter a 0))

  (simpson-integral #'cube 0 1 400.0)
#+END_SRC
*** Exercise 1.31
#+BEGIN_SRC elisp
    (defun product (f a next b)
      (defun-tco iter (a result)  ;; tco tail-recursion macro
        (if (> a b)
            result
          (iter (funcall next a) (* result (funcall f a)))))
      (iter a 1))

    (defun factorial (n)
      (defun ident (x) x)
      (product #'ident 1 #'1+ n))

    (mapcar #'factorial '(0 1 2 3 4 5 6 7 8 9))

    (defun pi-aprox-by-product (b)
      (defun even? (n) (= 0 (% n 2)))
      (defun f (n)
        (if (even? n)
            (/ (+ n 2.0) (1+ n))
          (/ (1+ n) (+ n 2.0))))
      (* 4 (product #'f 1 #'1+ b)))

    (pi-aprox-by-product 5000)

  (defun product-recursive (f a next b)
    (if (> a b)
        1
      (* (funcall f a)
         (product-recursive f (funcall next a) next b))))
#+END_SRC
*** Exercise 1.32
#+BEGIN_SRC elisp
  (defun accumulate-it (combiner null-value ter a next b)
    "Iterative version of accumulate."
    (defun-tco iter (a result)
      (if (> a b)
          result
        (iter (funcall next a)
              (funcall combiner result (funcall ter a)))))
    (iter a null-value))

  (defun accumulate-re (combiner null-value ter a next b)
    "Recursive version of accumulate"
    (if (> a b)
        null-value
      (funcall combiner (funcall ter a)
               (accumulate-re combiner
                              null-value
                              ter
                              (funcall next a)
                              next b))))

  (defun product (f a next b)
    (accumulate-re #'* 1 f a next b))

  (defun sum (f a next b)
    (accumulate-re #'+ 0 f a next b))

  (mapcar #'factorial '(0 1 2 3 4 5 6 7 8 9))
  (simpson-integral #'cube 0 1 400.0)

#+END_SRC

*** Exercise 1.33
#+BEGIN_SRC elisp
  (defun filtered-accumulate-it
    (combiner null-value ter a next b filt)
     "Iterative version of accumulate with filter."
     (defun-tco iter (a result)
           (if (> a b)
               result
             (iter (funcall next a)
                   (if (funcall filt a)
                       (funcall combiner result (funcall ter a))
                     result))))
     (iter a null-value))

  (defun sum (f a next b)
    (defun filter-nothing (x) x)
    (filtered-accumulate-it #'+ 0 f a next b #'filter-nothing))

  (defun sum-prime-squares (a b)
    (filtered-accumulate-it #'+ 0 #'square a #'1+ b #'prime?))

  (sum-prime-squares 1 12)

  (defun product-positive-ints-less-than-and-relatively-prime-to (n)
    (defun filt (i) (= 1 (gcd i n)))
    (if (> n 0)
        (filtered-accumulate-it #'* 1 #'ident 1 #'1+ n #'filt)
      1))

  (product-positive-ints-less-than-and-relatively-prime-to 5)
#+END_SRC

*** Exercise 1.34
    - The interpreter will try to execute 2 as a function.
#+BEGIN_SRC elisp
  (defun f (g) (funcall g 2))
  (f #'square)
  (f #'f)

  ; The order of evaluation is:
  (f f)
  (f 2)
  (2 2)
#+END_SRC

*** Exercise 1.35
    - if the golden ration is defined as the x that satisfies:
      x^2 = x + 1, then a transformation is x = (x+1)/x, which
      in turn is x = 1 + 1/x
#+BEGIN_SRC elisp
  (defvar phi (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0))
#+END_SRC

*** Exercise 1.36
#+BEGIN_SRC elisp
  (defvar tolerance 0.00001)
  (defun fixed-point (f first-guess)
    (defun close-enough? (v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (defun try (guess)
      (let ((next (funcall f guess)))
        (insert (number-to-string next) "\n")
        (if (close-enough? guess next)
          next
          (try next))))
    (try first-guess))

(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)
   ; => 34 iterations

(fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2.0)
  ; => 9 iterations using average damping
#+END_SRC

*** Exercise 1.37
#+BEGIN_SRC elisp
    (defun cont-frac-rec (n d k)
      "Calculate the k-th term of a continuous fraction."
      (defun rec (i)
        (if (= i k)
            (/ (funcall n i) (funcall d i))
          (/ (funcall n i)  (+ (funcall d i) (rec (1+ i))))))
      (rec 1))

  (defun cont-frac-iter (n d k)
    "Calculate the k-th term of a continuous fraction series."
    (defun iter (i result)
      (if (= 0 i)
          result
        (iter (1- i)
              (/ (funcall n i)
                 (+ (funcall d i) result)))))
    (iter k (/ (funcall n k) (funcall d k))))

  (cont-frac-iter (lambda(x) 1.0) (lambda(x) 1.0) 200) ; => 0.6180339887498948
  (cont-frac-rec (lambda(x) 1.0) (lambda(x) 1.0) 200)  ; => 0.6180339887498948
  (/ 1 phi)                                            ; => 0.6180344478216819

  (defun how-large-k (tol)
    "How large must you make `k' to be accurate according
     to tolerance TOL."
    (defun try (k phi)
      (let ((test (cont-frac-iter (lambda (x) 1.0)
                                  (lambda (x) 1.0)
                                  k)))
        (if (> (abs (- phi test)) tol)
            (try (1+ k) phi)
          k)))

    (try 1 (/ 2 (+ (sqrt 5) 1))))

  (how-large-k 0.0001)  ; => 9
#+END_SRC

*** Exercise 1.38
#+BEGIN_SRC elisp
(defun aprox-e (k)
  (+ 2.0 (cont-frac-iter (lambda (x) 1.0)
                         (lambda (x)
                           (if (= (% x 3) 2)
                              (/ (+ x 1) 1.5)
                             1))
                         k)))
(exp 1.0)       ; => 2.718281828459045
(aprox-e 100)   ; => 2.7182818284590455
#+END_SRC
*** Exercise 1.39
#+BEGIN_SRC elisp
(defun tan-cf (x k)
  (cont-frac-iter (lambda (i)
                    (if (= i 1) x (- (square x))))
                  (lambda (i)
                    (- (* 2 i) 1))
                k))

(tan 3)           ; => -0.1425465430742778
(tan-cf 3 1000.0) ; => -0.14254654307427775
#+END_SRC

*** Exercise 1.40
#+BEGIN_SRC elisp
  (defun cubic (a b c)
    `(lambda (w) (+ (* w w w) (* ,a w w) (* ,b w) ,c)))

  (newtons-method (cubic 2 2 2) 1.0)
#+END_SRC
*** Exercise 1.41
#+BEGIN_SRC elisp
  (defun inc (x) (1+ x))
  (defun double (g)
    `(lambda (x) (funcall #',g (funcall #',g x))))

  (funcall (funcall (double (double #'double)) #'inc) 5) ; => 21
#+END_SRC

*** Exercise 1.42
#+BEGIN_SRC elisp
  (defun compose (f g)
    `(lambda (x) (funcall #',f (funcall #',g x))))
  (funcall (compose 'square 'inc) 6)
#+END_SRC

*** Exercise 1.43
#+BEGIN_SRC elisp
(defun repeated-rec (f n)
  (if (<= n 1)
    f
    (repeated-rec (compose f f) (- n 1))))

(defun repeated-iter (f n)
  (defun iter (i result)
    (if (> i n)
        result
        (iter (+ i n) (compose f result))))
  (iter 1 f))

(funcall (repeated-rec  #'square 2) 5) ; => 625
(funcall (repeated-iter #'square 2) 5) ; => 625
#+END_SRC

*** Exercise 1.44
#+BEGIN_SRC elisp
  (defun smooth (g)
    `(lambda (x)
      (let ((dx 0.001))
        (/ (+ (funcall #',g (- x dx))
              (funcall #',g x)
              (funcall #',g (+ x dx)))
           3))))
(funcall (funcall (repeated-rec #'smooth 3) #'square) 2.0)
#+END_SRC

*** Exercise 1.45
#+BEGIN_SRC elisp
  (defun average-damp (f)
    `(lambda (x) (average x (,f x))))
  (funcall (average-damp #'square) 10)

  (defun square-root (w)
    (fixed-point (average-damp (lambda (y) (/ w y)))
                 1.0))
  ((lambda (w)
    (fixed-point
       (average-damp (lambda (y) (/ w (* y y)))) 1.0)) 8.0)

  ((lambda (w)
    (fixed-point
       (average-damp (average-damp (lambda (y) (/ w (* y y y))))) 1.0)) 8)

  (defun nth-root (n w)
    (fixed-point
      (funcall (repeated-rec #'average-damp (logb n))
               (lambda (y)
                 (/ w (accumulate-it #'* 1 (lambda (a) y) 1 #'1+ (1- n)))))
      1.0))

; The approximate seems to be some number based on log2 n, but not so sure.
; This can be seen in the following tests, the lower root range is in the format
; (2^x)-1
; According to this http://community.schemewiki.org/?sicp-ex-1.45 it says that
; it is actually a log2(x), but it doesn't seem that x grows linear (1, 2, 3, 4)
; damp_times root-range
; 1,          1 - 2    =>     1
; 2,          3 - 6    =>     2 1
; 3,          7 - 30   =>     3 2
; 4,         31 - 510  =>    5 2
; 5,        511        =>    9 4

#+END_SRC

*** Exercise 1.46
#+BEGIN_SRC elisp
  (defun square (x) (* x x))
  (defun average (x y) (/ (+ x y) 2))
  (defun iterative-improve (good-enough? improve start)
    (defun iter (test)
      (if (funcall good-enough? test)
        (funcall improve test)
        (iter (funcall improve test))))
    (iter start))

  (defun sqrt-iterative-improve (x)
    (iterative-improve (lambda (guess)
                         (< (abs (- (square guess) x)) 0.001))
                       (lambda (guess)
                         (average guess (/ x guess)))
                       1.0))
  (sqrt-iterative-improve 9)

  (defun fixed-point-iterative-improve (f first-guess)
    (let ((tol 0.0001))
      (iterative-improve (lambda (v1)
                           (< (abs (- v1 (funcall f v1))) tol))
                         f
                         first-guess)))

  (fixed-point-iterative-improve #'cos 1.0)

  ;; redefine iterative-improve returning a procedure that takes an initial
  ;; guess and keeps improving until it is good enough.
  (defun iterative-improve (good-enough? improve)
    `(lambda (x)
      (if (funcall #',good-enough? x)
        x
        (funcall (iterative-improve #',good-enough? #',improve)
                 (funcall #',improve x)))))

  (defun sqrt-iterative-improve (w)
    (funcall (iterative-improve (lambda (guess)
                                  (< (abs (- (square guess) w)) 0.0001))
                                (lambda (guess)
                                  (average guess (/ w guess))))
             1.0))
  (sqrt-iterative-improve 9.0)

  (defun fixed-point-iterative-improve (f guess)
    (funcall (iterative-improve (lambda (v1)
                                  (< (abs (- v1 (funcall f v1))) 0.001))
                                f)
             guess))
  (fixed-point-iterative-improve #'cos 1.0)
#+END_SRC

* Chapter 2
** Working with rationals
#+BEGIN_SRC elisp
  (defun gcd (a b)
    (cond ((= b 0) (abs a))
          (t (gcd b (% a b)))))

  (defun make-rat (n d)
    (let* ((g (gcd n d))
           (s (if (< (/ n (float d)) 0) -1 1)))
      (cons (* (abs (/ n g)) s)
            (abs (/ d g)))))

  (defun numer (x) (car x))
  (defun denom (x) (cdr x))

  (defun print-rat (x)
    (insert (format "\n%d/%d"
                    (numer x)
                    (denom x))))

  (defun add-rat (x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (defun sub-rat (x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (defun mul-rat (x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (defun div-rat (x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))

  (defun equal-rat? (x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))

  (let ((one-third (make-rat -1 -3)))
    (print-rat (add-rat one-third one-third)))


#+END_SRC

** Implementation of pairs using procedures
#+BEGIN_SRC elisp
(defun sicp-cons (x y)
  `(lambda (m)
    (cond ((= m 0) ,x)
          ((= m 1) ,y)
          (t (error "Argument not 0 or 1 -- CONS")))))
(defun sicp-car (z) (funcall z 0))
(defun sicp-cdr (z) (funcall z 1))

(let ((p (sicp-cons 1 5)))
     (insert (format "car: %d\ncdr: %d\n"
                     (sicp-car p)
                     (sicp-cdr p))))
#+END_SRC

** Counting leaves in a tree
#+BEGIN_SRC elisp
    (defun count-leaves (x)
      (cond ((null x) 0)
            ((not (consp x)) 1)
            (t (+ (count-leaves (car x))
                  (count-leaves (cdr x))))))

  (count-leaves (cons (list 1 2) (list 3 4)))
#+END_SRC

** Scale tree
#+BEGIN_SRC elisp
   (defun scale-tree (tree factor)
     (cond ((null tree) nil)
           ((not (consp tree)) (* tree factor))
           (t (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))

  (scale-tree '(1 (2 (3 4) 5) (6 7)) 10)
                ; =>  (10 (20 (30 40) 50) (60 70))

  (defun scale-tree (tree factor)
    (map (lambda (sub-tree)
           (if (consp sub-tree)
               (scale-tree sub-tree factor)
             (* sub-tree factor)))))
#+END_SRC

** 2.2.4 Sequence Operations
#+BEGIN_SRC elisp
(defun filter (predicate seq)
  (cond ((null seq) nil)
        ((funcall predicate (car seq))
         (cons (car seq)
               (filter predicate (cdr seq))))
        (t (filter predicate (cdr seq)))))

(defun accumulate (op initial seq)
  (if (null seq)
      initial
    (funcall op (car seq)
                (accumulate op initial (cdr seq)))))

(accumulate #'+ 0
            (filter #'oddp
                    (mapcar #'square (list 1 2 3 4 5))))
  ; => 35

(defun enumerate-interval (low high)
  (if (> low high)
      nil
    (cons low (enumerate-interval (1+ low) high))))

(enumerate-interval 1 7) ; => (1 2 3 4 5 6 7)

(defun enumerate-tree (tree)
  (cond ((null tree) nil)
        ((consp tree)
         (append (enumerate-tree (car tree))
                 (enumerate-tree (cdr tree))))
        (t (list tree))))

(enumerate-tree '(1 (2 (3 4)) 5))

(defun sum-odd-squares (tree)
  (accumulate #'+
              0
              (mapcar #'square
                   (filter #'oddp
                           (enumerate-tree tree)))))

(sum-odd-squares ' (1 (2 (3 4)) 5)) ; => 35

(defun even-fibs (n)
  (accumulate #'cons
              nil
              (filter #'evenp
                      (mapcar #'fib
                           (enumerate-interval 0 n)))))

(even-fibs 8) ; => (0 2 8)
#+END_SRC

** 2.2.4 Flatmap
#+BEGIN_SRC elisp
; If we try to generate the ordered pairs using map, then
; lists of pairs will be generated, the list size depends
; on the current value of `i'
(mapcar (lambda (i)
          (mapcar (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
        (enumerate-interval 1 5))

;; To solve this, we can accumulate each pair using append
(accumulate #'append
            nil
            (mapcar (lambda (i)
                   (mapcar (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 5)))

; Accumulating with append is so common that `flatmap' is
; made an isolated procedure
(defun flatmap (proc seq)
  (accumulate #'append nil (mapcar proc seq)))

(flatmap (lambda (i)
           (mapcar (lambda (j) (list i j))
                   (enumerate-interval 1 (- i 1))))
          (enumerate-interval 1 5))

(defun prime-sum? (pair)
  (prime? (+ (car pair) (cadr pair))))

(defun make-pair-sum (pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(defun prime-sum-pairs (n)
  (mapcar 'make-pair-sum
          (filter 'prime-sum
               (flatmap (lambda (i)
                          (mapcar (lambda(j) (list i j))
                                  (enumerate-interval 1 (- i 1))))
                        (enumerate-interval 1 n)))))

(prime-sum-pairs 5) ; => ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7))
#+END_SRC

** 2.24 permutations
#+BEGIN_SRC elisp
(defun permutations (s)
  (if (null s)
      (list nil)
    (flatmap (lambda (x)
               (mapcar (lambda (p) (cons x p))
                    (permutations (remove x s))))
             s)))
(defun remove (item seq)
  (filter (lambda (x) (not (= x item)))
          seq))

(permutations '(1 2 3))
  ; => ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))
#+END_SRC

** 2.2.4 Picture Language
#+BEGIN_SRC elisp
  ; giving vectors v = (x, y) with 0<= x,y<= 1 within the
  ; unit square, the result will be within the frame.
  (defun frame-coord-map (frame)
    (lambda (v)
      (add-vect
       (origin-frame frame)
       (add-vect (scale-vect (xcor-vect v)
                             (edge1-frame frame))
                 (scale-vect (ycor-vect v)
                             (edge2-frame frame))))))

  (defun segments->painter (segment-list)
    (lambda (frame)
      (for-each
        (lambda (segment)
          (draw-line
            (funcall (frame-coord-map frame) (start-segment segment))
            (funcall (frame-coord-map frame) (end-segment segment))))
        segment-list)))

  (defun transform-painter (painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
        (let ((new-origin (funcall m origin)))
          (funcall painter
            (make-frame new-origin
                        (sub-vect (funcall m corner1) new-origin)
                        (sub-vect (funcall m corner2) new-origin)))))))

  ; flip painter vertically
  (defun flip-vert (painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)  ; new origin
                       (make-vect 1.0 1.0)  ; new end of edge1
                       (make-vect 0.0 0.0))); new end of edge2

  (defun shrink-to-upper-right (painter)
    (transform-painter painter
                       (make-vect 0.5 0.5)
                       (make-vect 1.0 0.5)
                       (make-vect 0.5 1.0)))

  (defun rotate90 (painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))

  (defun squash-inwards (painter)
    (transform-painter painter
                       (make-vect 0.0 0.0)
                       (make-vect 0.65 0.35)
                       (make-vect 0.35 0.65)))

  (defun beside (painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                split-point
                                (make-vect 0.0 1.0)))
            (paint-right
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.0)
                                (make-vect 0.5 1.0))))
        (lambda (frame)
          (funcall paint-left frame)
          (funcall paint-right frame)))))

(defun corner-split (painter n)
  (if (= n 0)
      painter
    (let* ((up (up-split painter (- n 1)))
           (right (right-split painter (1- n)))
           (top-left (beside up up))
           (bottom-right (below right right))
           (corner (corner-split painter (1- n))))
      (beside (below painter top-left)
              (below bottom-right corner)))))
#+END_SRC

** 2.3.2 Symbolic Differentiation
#+BEGIN_SRC elisp
(defun deriv (exp var)
  (cond ((numberp exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (t (error "unknown expression type == DREIV"))))

(defun =number? (a b)
  (and (numberp a) (numberp b) (= a b)))

(defun variable? (x) (symbolp x))
(defun same-variable? (v1 v2) (eq v1 v2))

(defun make-sum (a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (numberp a1) (numberp a2)) (+ a1 a2))
        (t `(+ ,a1 ,a2))))

(defun make-product (m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (numberp m1) (numberp m2)) (* m1 m1))
        (t `(* ,m1 ,m2))))

(defun sum? (x)
  (and (consp x) (eq (car x) '+)))

(defun addend (s) (cadr s))
(defun augend (s) (caddr s))
(defun product? (x)
  (and (consp x) (eq (car x) '*)))
(defun multiplier (p) (cadr p))
(defun multiplicand (p) (caddr p))

(deriv '(+ x 3) 'x) ; => 1
(deriv '(* x y) 'x) ; => y
(deriv '(* (* x y) (+ x 3)) 'x)
 ; => (+ (* x y) (* y (+ x 3)))
#+END_SRC

** 2.3.3 Representing Sets
#+BEGIN_SRC elisp
(defun element-of-set? (x set)
  (cond ((null set) nil)
        ((equal x (car set)) t)
        (t (element-of-set? x (cdr set)))))
(defun adjoin-set (x set)
  (if (element-of-set? x set) set (cons x set)))
(defun intersection-set (set1 set2)
  (cond ((or (null set1) (null set2)) nil)
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (t (intersection-set (cdr set1) set2))))

; For the case of ordered lists
(defun element-of-set? (x set)
  (cond ((null set) nil)
        ((= x (car set)) t)
        ((< x (car set)) nil)
        (t (element-of-set? x (cdr set)))))
(defun intersection-set? (set1 set2)
  (if (or (null set1) (null set2))
      nil
    (let ((x1 (car set1)) (x2 (car set2)))
      (cond ((= x1 x2)
             (cons x1
                   (intersection-set? (cdr set1)
                                      (cdr set2))))
            ((< x1 x2)
             (intersection-set? (cdr set1) set2))
            ((< x2 x1)
             (intersection-set? set1 (cdr set2)))))))
#+END_SRC

** 2.3.3 Sets as binary trees
#+BEGIN_SRC elisp
(defun entry (tree)
  (if (consp tree)
      (car tree)
    tree))
(defun left-branch (tree)
  (if (consp tree)
      (cadr tree)
    nil))
(defun right-branch (tree)
  (if (consp tree)
      (caddr tree)
    nil))
(defun make-tree (entry left right)
  (list entry left right))

(defun element-of-set? (x set)
  (cond ((= x (entry set)) t)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        (t
         (element-of-set? x (right-branch set)))))

(defun adjoin-set (x set)
  (cond ((null set) (make-tree x nil nil))
        ((< x (entry set))
         (make-tree (entry-set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry-set)
                    (left-branch set)
                    (adjoin-set x (right-branch set))))))
#+END_SRC

** 2.3.4 Huffman code
#+BEGIN_SRC elisp
(defun make-leaf (symbol weight)
  (list 'leaf symbol weight))
(defun leaf? (object)
  (eq 'leaf (car object)))
(defun symbol-leaf (x) (cadr x))
(defun weight-leaf (x) (caddr x))

(defun make-code-tree (left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(defun left-branch (tree) (car tree))
(defun right-branch (tree) (cadr tree))
(defun symbols (tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
    (caddr tree)))
(defun weight (tree)
  (if (leaf? tree)
      (weight-leaf tree)
    (cadddr tree)))

(defun decode (bits tree)
  (defun decode-1 (bits current-branch)
    (if (null bits)
        nil
      (let ((next-branch
            (choose-branch (car bits) current-branch)))
           (if (leaf? next-branch)
               (cons (symbols next-branch)
                     (decode-1 (cdr bits) tree))
             (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(defun choose-branch (bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (t (error "bad bit -- CHOOSE-BRANCH"))))

(defun adjoin-set (x set)
  (cond ((null set) (list x))
        ((< (weight x) (weight (car set)))
         (cons x set))
        (t (cons (car set)
                 (adjoin-set x (cdr set))))))

(defun make-leaf-set (pairs)
  (if (null pairs)
      nil
    (let ((pair (car pairs)))
         (adjoin-set (make-leaf (car pair)
                                (cadr pair))
                      (make-leaf-set (cdr pairs))))))

(make-leaf-set '((A 4) (B 2) (C 1) (D 1)))
  ; => ((leaf D 1) (leaf C 1) (leaf B 2) (leaf A 4))

#+END_SRC
** 2.4.1 Representations for Complex Numbers
#+BEGIN_SRC elisp
  (defun add-complex (z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))

  (defun sub-complex (z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))

  (defun mul-complex (z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))

  (defun div-complex (z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  (defun attach-tag (type-tag contents)
    (cons type-tag contents))

  ; polar representation
  (defun install-polar-package
    (defun magnitude (z) (car z))
    (defun angle (z) (cdr z))
    (defun make-from-mag-ang (r a) (cons r a))
    (defun real-part (z)
      (* (magnitude-polar z) (cos (angle-polar z))))
    (defun imag-part (z)
      (* (magnitude-polar z) (sin (angle-polar z))))
    (defun make-from-real-imag (x y)
      (cons (sqrt (+ (square x) (square y))) (atan y x)))

    ;; interface to the rest of the system
    (defun tag (x) (attach-tag 'polar x))
    (sicp-put 'real-part '(polar) 'real-part)
    (sicp-put 'imag-part '(polar) 'imag-part)
    (sicp-put 'magnitude '(polar) 'magnitude)
    (sicp-put 'angle '(polar) 'angle)
    (sicp-put 'make-from-real-imag 'polar
              '(lambda (x y) (tag (make-from-real-imag x y))))
    (sicp-put 'make-from-mag-ang 'polar
              '(lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  ; rectangular representation
  (defun install-rectangular-package
    (defun real-part (z) (car z))
    (defun imag-part (z) (cdr z))
    (defun angle (z)
      (atan (imag-part-rectangular z)
            (real-part-rectangular z)))
    (defun magnitude (z)
      (sqrt (+ (square (real-part-rectangular z))
               (square (imag-part-rectangular z)))))
    (defun make-from-real-imag (x y) (cons x y))
    (defun make-from-mag (x y)
      (cons (* r (cos a)) (* r (sin a))))

    ;; interface to the rest of the system
    (defun (tag x) (attach-tag 'rectangular x))
    (sicp-put 'real-part '(rectangular) 'real-part)
    (sicp-put 'imag-part '(rectangular) 'imag-part)
    (sicp-put 'magnitude '(rectangular) 'magnitude)
    (sicp-put 'angle '(rectangular) 'angle)
    (sicp-put 'make-from-real-imag 'rectangular
              '(lambda (x y) (tag (make-from-real-imag x y))))
    (sicp-put 'make-from-mag-ang 'rectangular
              '(lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (defun type-tag (datum)
    (if (consp datum)
        (car datum)
      (error "Bad tagged datum -- TYPE-TAG")))

  (defun contents (datum)
    (if (consp datum)
        (cdr datum)
      (error "Bad tagged datum -- CONTENTS")))

  (defun apply-generic (op &optional args)
    (let ((type-tags (mapcar 'type-tag args)))
      (let ((proc (sicp-get op type-tags)))
        (if proc
            (apply proc (mapcar contents args))
          (error "No method for these types -- APPLY-GENERIC")))))

  (defun real-part (z) (apply-generic 'real-part z))
  (defun imag-part (z) (apply-generic 'imag-part z))
  (defun magnitude (z) (apply-generic 'magnitude z))
  (defun angle (z) (apply-generic 'angle z))

  (defun make-from-real-imag (x y)
    (funcall (get 'make-from-real-imag 'rectangular) x y))
  (defun make-from-mag-ang (r a)
    (funcall (get 'make-from-mag-ang 'polar) r a))
#+END_SRC

** 2.5.1 Generic Arithmetic Operations
#+BEGIN_SRC elisp
  (defun install-generic-arithmetic-package ()
    (defun add (x y) (apply-generic 'add x y))
    (defun sub (x y) (apply-generic 'sub x y))
    (defun mul (x y) (apply-generic 'mul x y))
    (defun div (x y) (apply-generic 'div x y))
    (defun equ? (x y) (apply-generic 'equ? x y))

    (defun install-scheme-number-package ()
      (defun tag (x)
        (attach-tag 'scheme-number x))
      (sicp-put 'add '(scheme-number scheme-number)
                (lambda (x y) (tag (+ x y))))
      (sicp-put 'sub '(scheme-number scheme-number)
                (lambda (x y) (tag (- x y))))
      (sicp-put 'mul '(scheme-number scheme-number)
                (lambda (x y) (tag (* x y))))
      (sicp-put 'div '(scheme-number scheme-number)
                (lambda (x y) (tag (/ x y))))
      (sicp-put 'equ? '(scheme-number scheme-number)
                (lambda (x y) (= x y)))
      'done)

    (defun install-rational-package ()
      ;; internal procedures
      (defun numer (x) (car x))
      (defun denom (x) (cdr x))
      (defun make-rat (n d)
        (let ((g (gcd n d)))
          (cons (/ n g) (/ d g))))
      (defun add-rat (x y)
        (make-rat (+ (* (numer x) (denom y))
                     (* (numer y) (denom x)))
                  (* (denom x) (denom y))))
      (defun sub-rat (x y)
        (make-rat (- (* (numer x) (denom y))
                     (* (numer y) (denom x)))
                  (* (denom x) (denom y))))
      (defun mul-rat (x y)
        (make-rat (* (numer x) (numer y))
                  (* (denom x) (denom y))))
      (defun div-rat (x y)
        (make-rat (* (numer x) (denom y))
                  (* (denom x) (numer y))))

      ;; interface to rest of the system
      (defun tag (x) (attach-tag 'rational x))
      (sicp-put 'add '(rational rational)
                (lambda (x y) (tag (add-rat x y))))
      (sicp-put 'sub '(rational rational)
                (lambda (x y) (tag (add-rat x y))))
      (sicp-put 'mul '(rational rational)
                (lambda (x y) (tag (mul-rat x y))))
      (sicp-put 'div '(rational rational)
                (lambda (x y) (tag (div-rat x y))))
      (sicp-put 'equ? (rational rational)
                (lambda (x y) (and (= (numer x) (numer y))
                                   (= (denom x) (denom y)))))
      'done)

    (defun (make-rational n d)
      (funcall (sicp-get 'make 'rational) n d))

    (defun install-complex-package ()
      (defun make-from-real-imag (x y)
        (funcall (sicp-get 'make-from-real-imag 'rectangular) x y))
      (defun (make-from-mag-ang (x y)
                                (funcall (sicp-get 'make-from-mag-ang 'polar) r a)))

      ;; internal procedures
      (defun add-complex (z1 z2)
        (make-from-real-imag (+ (real-part z1) (real-part z2))
                             (+ (imag-part z1) (imag-part z2))))
      (defun sub-complex (z1 z2)
        (make-from-real-imag (- (real-part z1) (real-part z2))
                             (- (imag-part z1) (imag-part z2))))
      (defun mul-complex (z1 z2)
        (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                           (+ (angle z1) (angle z2))))
      (defun div-complex (z1 z2)
        (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                           (- (angle z1) (angle z2))))

      ;; interface to rest of the system
      (defun (tag z) (attach-tag 'complex z))
      (sicp-put 'add '(complex complex)
                (lambda (z1 z2) (tag (add-complex z1 z2))))
      (sicp-put 'sub '(complex complex)
                (lambda (z1 z2) (tag (sub-complex z1 z2))))
      (sicp-put mul '(complex complex)
                (lambda (z1 z2) (tag (mul-complex z1 z2))))
      (sicp-put 'div '(complex complex)
                (lambda (z1 z2) (tag (div-complex z1 z2))))
      (sicp-put 'equ? '(complex complex)
                (lambda (z1 z2) (and (= (real-part z1) (real-part z2))
                                     (= (imag-part z1) (real-part z2)))))
      'done)

    (defun make-complex-from-real-imag (x y)
      (funcall (sicp-get 'make-from-real-imag 'complex) x y))

    (defun make-complex-from-mag-ang (r a)
      (funcall (sicp-get 'make-from-mag-ang 'complex) r a))
#+END_SRC

** 2.5.2 Combining Data of Different Types
*** Coercion
#+BEGIN_SRC elisp
  (defun scheme-number->complex (n)
    (make-complex-from-real-imag (contents n) 0))

  ;; there's a special table to put coercion procedures
  (sicp-put-coersion 'scheme-number 'complex scheme-number->complex)

  ;; new version of apply generic that considers coersion
  (defun apply-generic (op &optional args)
    (let ((type-tags (map type-tags args)))
      (let ((proc (sicp-get op type-args)))
        (if proc
            (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (sicp-get-coercion type1 type2))
                      (t2->t1 (sicp-get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (t (error "No method for these types")))))
            (error "No method for these types"))))))
#+END_SRC

** 2.5.3 Example: Symbolic Algebra
#+BEGIN_SRC elisp
  (defun install-polynomial-package ()
    ;; internal procedures
    ;; representation of poly
    (defun make-poly (variable term-list)
      (cons variable term-list))
    (defun variable (p) (car p))
    (defun term-list (p) (cdr p))
    (defun variable? (x) (symbolp x))
    (defun same-variable? (v1 v2) (eq v1 v2))

    (defun adjoin-term (term term-list)
      (if (=zero? (coeff term))
          term-list
        (cons term term-list)))

    (defun the-empty-termlist '())
    (defun first-term (term-list) (car term-list))
    (defun rest-terms (term-list) (cdr term-list))
    (defun empty-termlist? (term-list) (null? term-list))
    (defun make-term (order coeff) (list order coeff))
    (defun order (term) (car term))
    (defun coeff (term) (cdr term))

    (defun add-poly (p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (add-terms (term-list p1)
                                (term-list p2)))
        (error "Polys not in same var -- ADD-POLY")))

    (defun mul-poly (p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (mul-terms (term-list p1)
                                (term-list p2)))
        (error "Polys not in same var -- MUL-POLY")))

    (defun add-terms (l1 l2)
      (cond ((empty-termlist? l1) l2)
            ((empty-termlist? l2) l1)
            (t
             (let ((t1 (first-term l1))
                   (t2 (first-term l2)))
               (cond ((> (order t1) (order t2))
                      (adjoin-term
                       t1 (add-terms (rest-terms l1) l2)))
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (add-terms l1 (rest-terms l2))))
                     (t
                      (adjoin-term
                       (make-term (order t1)
                                  (add (coeff t1) (coeff t2)))
                       (add-terms (rest-terms l1)
                                  (rest-terms l2)))))))))
    (defun mul-terms (l1 l2)
      (if (empty-termlist? l1)
          (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first term l1) l2)
                   (mul-terms (rest-terms l1) l2))))
      (defun mul-term-by-all-terms (t1 l)
        (if (empty-termlist? l)
            (the-empty-termlist)
          (let ((t2 (first-term l)))
            (adjoin-term
             (make-term (+ (order t1) (order t2))
                        (mul (coeff t1) (coeff t2)))
             (mul-term-by-all-terms t1 (rest-terms l))))))

    (defun tag (p) (attach-tag 'polynomial p))
    (sicp-put 'add '(polynomial polynomial)
              (lambda (p1 p2) (tag (add-poly p1 p2))))
    (sicp-put 'mul '(polynomial polynomial)
              (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (sicp-put 'make 'polynomial
              (lambda (var terms) (tag (make-poly var terms))))
    (defun make-polynomial (var terms)
      ((sicp-get 'make 'polynomial) var terms))
    'done)
#+END_SRC
** Exercises
*** Exercise 2.1
#+BEGIN_SRC elisp
(defun make-rat (n d)
  (let ((g (gcd n d))
        (s (if (< (/ n (float d)) 0) -1 1)))
    (cons (* (abs (/ n g)) s)
          (abs (/ d g)))))

;; Here's a cool solution I saw on the internet
;; http://community.schemewiki.org/?sicp-ex-2.1
(defun make-rat (n d)
  (let ((g (funcall (if (< d 0) '- '+) (gcd n d))))
    (cons (/ n g) (/ d g))))

(make-rat  2  6)
(make-rat -2  6)
(make-rat  2 -6)
(make-rat -2 -6)
#+END_SRC

*** Exercise 2.2
#+BEGIN_SRC elisp
  (defun print-point (p)
    (insert (format "(%.2f,%.2f)"
                   (x-point p)
                   (y-point p))))

  (defun make-point (x y) (cons (float x) (float y)))
  (defun x-point (p) (car p))
  (defun y-point (p) (cdr p))

  (print-point (make-point 1.5 -4.0))

  (defun make-segment (a b) (cons a b))
  (defun start-segment (segment) (car segment))
  (defun end-segment (segment) (cdr segment))

  (defun average (a b)
    (/ (+ a b) 2))
  (defun midpoint-segment (seg)
    (make-point (average (x-point (start-segment seg))
                         (x-point (end-segment seg)))
                (average (y-point (start-segment seg))
                         (y-point (end-segment seg)))))

  (print-point (midpoint-segment
                (make-segment (make-point 1 2)
                              (make-point 2 1))))
#+END_SRC
*** Exercise 2.3
#+BEGIN_SRC elisp
  (defun rectangle-area (r)
    (* (rectangle-height r) (rectangle-base r)))

  (defun rectangle-perimeter (r)
    (* 2 (+ (rectangle-height r)
            (rectangle-base r))))

  ;;  first implementation represent rectangle with 2 points
  (defun make-rectangle (x y) (cons x y))
  (defun rectangle-p1 (r) (car r))
  (defun rectangle-p2 (r) (cdr r))

  (defun rectangle-height (r)
    (abs (- (y-point (rectangle-p1 r))
            (y-point (rectangle-p2 r)))))

  (defun rectangle-base (r)
    (abs (- (x-point (rectangle-p1 r))
            (x-point (rectangle-p2 r)))))

  (rectangle-area (make-rectangle
                    (make-point 2 0)
                    (make-point 0 4)))

  ;; Second implementation build rectangle with 2
  ;; perpendicular segments that have a point in common
  (defun make-rectangle-2 (s1 s2)
    (cons (start-segment s1)
          (if (or (= (x-point (start-segment s1))
                     (x-point (start-segment s2)))
                  (= (y-point (start-segment s1))
                     (y-point (start-segment s2))))
              (end-segment s2)
            (start-segment s2))))

  (rectangle-area (make-rectangle-2
                    (make-segment (make-point 2 0)
                                  (make-point 0 0))
                    (make-segment (make-point 0 4)
                                  (make-point 0 0))))
#+END_SRC

*** Exercise 2.4
#+BEGIN_SRC elisp
(defun sicp-cons (x y)
  `(lambda (m) (funcall m ,x ,y)))
(defun sicp-car (z)
  (funcall z (lambda (p q) p)))
(defun sicp-cdr (z)
  (funcall z (lambda (p q) q)))

(let ((p (sicp-cons 1 5)))
  (insert (format "car: %d\ncdr: %d\n"
                  (sicp-car p)
                  (sicp-cdr p))))

;; Substitution model
(sicp-cdr (sicp-cons (x y)))
(sicp-cdr (lambda (m) (m x y)))
((lambda (m) (m x y)) (lambda (p q) q))
((lambda (p q) q) x y)
((lambda (x y) y))))
y
#+END_SRC
*** Exercise 2.5
#+BEGIN_SRC elisp
(2 4) -> 2^3 * 3^4 -> (* (expt 2 3) (expt 3 4))

(/ (/ (/ (/ (/ (/ 324 2.0) 2) 3) 3) 3) 3)
(/ (/ (/ (/ (/ (/ 324 3.0) 3) 3) 3) 2) 2)

(defun integer-cons (x y)
  (* (expt 2 x) (expt 3 y)))

(defun integer-count-remainder (z b)
  (defun iter (r count)
    (if (= 0 (% r b) )
      (iter (/ r b) (1+ count))
      count))
  (iter z 0))

(defun integer-count-remainder (z b)
  (if (= 0 (% z b))
    (1+ (integer-count-remainder (/ z b) b))
    0))

(integer-count-remainder 324 3)

(defun integer-car (z)
  (integer-count-remainder z 2))

(defun integer-cdr (z)
  (integer-count-remainder z 3))

#+END_SRC

*** Exercise 2.6
#+BEGIN_SRC scheme
  ; read this article https://en.wikipedia.org/wiki/Church_encoding

  (define zero
    (lambda (f)
      (lambda (x) x)))

  (define (add-1 n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x)))))

  ;; Apply substitution to reduce 1
  (add-1 zero)
  (add-1 (lambda (f) (lambda (x) x)))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) x) x))))
  (lambda (f) (lambda (x) (f x))) ; <= this is the reduction of one

  (define one
    (lambda (f)
      (lambda (x)
        (f x))))

  ;; apply substitution to reduce 2
  (add-1 one)
  (add-1 (lambda (f) (lambda (x) (f x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
  (lambda (f) (lambda (x) (f (f x)))) ; <= this is the reduction of two

  (define two
    (lambda (f)
      (lambda (x)
        (f (f x)))))

  ;; found great help here:
  ;; http://jlongster.com/2011/12/16/sicp-26-church-notation.html
  (define (add a b)
    (lambda (f)
      (lambda (x)
        ((a f) ((b f) x)))))
#+END_SRC

*** Exercise 2.7
#+BEGIN_SRC elisp
   ; Had to adjust this constructor in order to make
   ; range arithmetic work when range spans negative
   ; numbers
   (defun make-interval (a b)
     (if (< a b) (cons a b) (cons b a)))

   (defun lower-bound (x) (car x))
   (defun upper-bound (x) (cdr x))

  (lower-bound (make-interval 1.2 2.7))
  (upper-bound (make-interval 1.2 2.7))

   (defun add-interval (x y)
     (make-interval (+ (lower-bound x) (lower-bound y))
                    (+ (upper-bound x) (upper-bound y))))

   (defun mul-interval (x y)
     (let ((p1 (* (lower-bound x) (lower-bound y)))
           (p2 (* (lower-bound x) (upper-bound y)))
           (p3 (* (upper-bound x) (lower-bound y)))
           (p4 (* (upper-bound x) (upper-bound y))))
       (make-interval (min p1 p2 p3 p4)
                      (max p1 p2 p3 p4))))

  (defun div-interval (x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))

  (add-interval (make-interval -1.2 0)
                (make-interval 3 5.2))
  (mul-interval (make-interval -1.2 0)
                (make-interval 3 5.2))
  (div-interval (make-interval -1.2 0)
                (make-interval 3 5.2))
#+END_SRC

*** Exercise 2.8
#+BEGIN_SRC elisp
   (defun sub-interval (x y)
     (add-interval x (make-interval (- (upper-bound y))
                                    (- (lower-bound y)))))

   (sub-interval (make-interval 0 6)
                 (make-interval -5 3))
#+END_SRC
*** Exercise 2.9
#+BEGIN_SRC elisp
  (defun width-interval (x)
    (/ (- (upper-bound x) (lower-bound x)) 2))

  ; It can be shown that the width of the sum and the
  ; width of the subtraction  of 2 ranges is equal to
  ; the sum of the sum of the widths of each range.

  ; The width of the sum of 2 ranges is defined as
  ;   1/2 [(aH + bH) - (aL + bL)] => W(a+b)
  ; = 1/2 [(aH - aL) + (bH - bL)]
  ; = 1/2(aH - aL) + 1/2(bH - bL) => W(a) + W(b)

  ; The width of the sub of 2 ranges is defined as:
  ;   1/2 [(aH - bL) - (aL - bH)] => W(a-b)
  ; = 1/2 [(aH - aL) + (bH - bL)]
  ; = 1/2(aH - aL) + 1/2(bH - bL) => W(a) + W(b)

  ; Show that the width of the sum of 2 intervals is
  ; the same as the sum of the widths of each interval
  (let ((x (make-interval  1 3.5))
        (y (make-interval -5 2.8)))
    (= (width-interval (add-interval x y))
       (+ (width-interval x) (width-interval y)))) ; => t

  ; Same thing for subtractions
  (let ((x (make-interval   1 3.5))
        (y (make-interval  -5 2.8)))
    (= (width-interval (sub-interval x y))
       (+ (width-interval x) (width-interval y)))) ; => t

  ; Give examples to show that this is not true for mult and div
  ; Intuitively we can say that since the lower and upper values
  ; of the resulting range in a mul or a div depend of the max and
  ; min result of their products, then there is no a feasible way
  ; to combine the widths of each range and generate the width of
  ; the resulting range.
  (width-interval (mul-interval (make-interval   1 3.5)
                                (make-interval  -5 2.8))) ; => -13.65

  (width-interval (make-interval   1 3.5)) ; => -1.25
  (width-interval (make-interval  -5 2.8)) ; => -3.9
#+END_SRC

*** Exercise 2.10
#+BEGIN_SRC elisp
  (defun div-interval (x y)
    (if (or (= 0 (upper-bound y))
            (= 0 (lower-bound y)))
        (error "Div by zero -- DIV-INTERVAL")
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))))
  (div-interval (make-interval 1 1) (make-interval 0 0))
#+END_SRC

*** Exercise 2.11
#+BEGIN_SRC elisp
       (defun mul-interval (x y)
         (let ((p1 (* (lower-bound x) (lower-bound y)))
               (p2 (* (lower-bound x) (upper-bound y)))
               (p3 (* (upper-bound x) (lower-bound y)))
               (p4 (* (upper-bound x) (upper-bound y))))
           (make-interval (min p1 p2 p3 p4)
                          (max p1 p2 p3 p4))))

      (defun mul-interval-new (x y)
        (defun bound-sign (a) (if (< a 0) '- '+))
        (defun upper-signs ()
          (cons (bound-sign (upper-bound x))
                (bound-sign (upper-bound y))))
        (defun lower-signs ()
          (cons (bound-sign (lower-bound x))
                (bound-sign (lower-bound y))))
        (defun test-upper-signs (s1 s2)
          (equal (cons s1 s2) (upper-signs)))
        (defun test-lower-signs (s1 s2)
          (equal (cons s1 s2) (lower-signs)))

        (let ((xL (lower-bound x))
              (xU (upper-bound x))
              (yL (lower-bound y))
              (yU (upper-bound y)))
          (cond ((and (test-lower-signs '- '-)
                      (test-upper-signs '+ '+))
                 (make-interval (min (* xL yU) (* yL xU))
                                (max (* xL yL) (* xU yU))))
                ((test-upper-signs '+ '+)
                 (make-interval (cond
                                 ((test-lower-signs '- '+) (* xL yU))
                                 ((test-lower-signs '+ '-) (* xU yL))
                                 ((test-lower-signs '+ '+) (* xL yL)))
                                (* xU yU)))
                ((test-upper-signs '- '-)
                 (make-interval (* xL yL) (* xU yU)))
                ((test-upper-signs '- '+)
                 (make-interval (* xL yU)
                                (if (test-lower-signs '- '-)
                                    (* xL yL)
                                (* xU yL))))
                ((test-upper-signs '+ '-)
                 (make-interval (* xU yL)
                                (if (test-lower-signs '- '-)
                                    (* xL yL)
                                  (* xL yU)))))))

  (mul-interval (make-interval   +1 +3.5)
                (make-interval   +5 +2.8))
  (mul-interval-new (make-interval   +1 +3.5)
                    (make-interval   +5 +2.8))
#+END_SRC

*** Exercise 2.12
#+BEGIN_SRC elisp
  (defun make-center-width (c w)
    (make-interval (- c w) (+ c w)))

  (defun center-interval (i)
    (/ (+ (lower-bound i) (upper-bound i)) 2.0))


  (defun make-center-percent (c p)
    (make-center-width c (* c (/ p 100.0))))

  (defun percent-interval (i)
    (let ((c (center-interval i))
          (w (width-interval i)))
      (* (/ w c) 100)))

  (percent-interval (make-center-percent 256 3))
#+END_SRC

*** Exercise 2.13
#+BEGIN_SRC elisp
      ; the multiplication of 2 ranges with the following representation:
      ; [Ac, T1] * [Bc, T2] where Xc is the center and Ty is the tolerance
      ; for each range.
      ; The representation of the ranges using lower and higher values is:
      ; [Ac(1-T1), Ac(1+T2)] *  [Bc(1-T2), Bc(1+T2)]
      ; The result of the multiplication of 2 ranges is [AlBl, AhBh] where
      ; Xl and YH are the lower and higher values of the range, so resolving
      ; generates a new range C:
      ; C = [Ac(1-T1)*Bc(1-T2), Ac(1+T1)*Bc(1+T2)]
      ; Calculating the Center of C (Cc) and the width (Cw):
      ; Cc = 1/2 [Ac(1-T1)*Bc(1-T2) + Ac(1+T1)*Bc(1+T2)]
      ;    = AcBc(1 + T1T2)
      ; Cw = 1/2  [Ac(1+T1)*Bc(1+T2) - Ac(1-T1)*Bc(1-T2)]
      ;    = AcBC(T1 + T2)
      ; Then calculate the tolerance:
      ; T3 = AcBC(T1+T2)/ AcBc(1 + T1T2) = (T1+T2) / (1 + T1T2)
      ; In the case when T1 and T2 then T1T2 tends to zero so the tolerance
      ; can be calculated as:
      ; T3 = T1 + T2
#+END_SRC

*** Exercise 2.14
#+BEGIN_SRC elisp
  (defun par1 (r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))

  (defun par2 (r1 r2)
    (let ((one (make-center-percent 1 0)))
      (div-interval one
                    (add-interval (div-interval one r1)
                                  (div-interval one r2)))))

   ; Lem is right, in the following example it shows that there's difference
   ; in the results between both versions of par.
   (let* ((one (make-center-percent 1 0))
          (r1  (make-center-percent 250 0.01))
          (r2  (make-center-percent 250 0.01))
          (inv-r1 (div-interval one r1))
          (inv-r2 (div-interval one r2)))
     (add-interval inv-r1 inv-r2))

   (let* ((one (make-center-percent 1 0))
          (r1  (make-center-percent 250 0.01))
          (r2  (make-center-percent 250 0.01))
          (inv-r1 (div-interval one r1))
          (inv-r2 (div-interval one r2)))
     (div-interval (add-interval r1 r2)
                   (mul-interval r1 r2)))

  ; more details about the pitfalls in designing interval arithmetic systems
  ; http://wiki.drewhess.com/wiki/SICP_exercise_2.16
#+END_SRC

*** Exercise 2.15
    Not sure about this.

*** Exercise 2.16
    No feasible answer

*** Exercise 2.17
#+BEGIN_SRC elisp
 (defun last-pair (list1)
   (if (null (cdr list1))
     list1
     (last-pair (cdr list1))))

 (last-pair (list 23 72 149 34)) ; => (34)
#+END_SRC

*** Exercise 2.18
#+BEGIN_SRC elisp
  (defun reverse (lst)
    (defun iter (l acc)
      (if (null l)
        acc
        (iter (cdr l) (cons (car l) acc))))
    (iter lst ()))

  (reverse (list 1 2 3 4)) ; => (4 3 2 1)
#+END_SRC

*** Exercise 2.19
#+BEGIN_SRC elisp
   (defvar us-coins (list 50 25 10 5 1))
   (defvar uk-coins (list 100 50 20 10 5 2 1 0.5))

   (defun counting-change (amount coin-values)

     (defun cc (amount coin-values)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (no-more? coin-values)) 0)
             (t (+ (cc amount (except-first-denomination coin-values))
                   (cc (- amount (first-denomination coin-values))
                       coin-values)))))

     (defun first-denomination (coin-values) (car coin-values))
     (defun except-first-denomination (coin-values) (cdr coin-values))
     (defun no-more? (coin-values) (null coin-values))

     (cc amount coin-values))

   (counting-change 100 us-coins)
#+END_SRC

*** Exercise 2.20
#+BEGIN_SRC elisp
    (defun same-parity (first &rest args)
      (defun iter (l acc)
        (if (null l)
            (reverse acc)
          (iter (cdr l)
                (if (= (% first 2) (% (car l) 2))
                    (cons (car l) acc)
                  acc))))
      (iter args (list first)))

    (same-parity 1 2 3 4 5 6 7)

    (defun same-parity-rec (first &rest args)
      (defun recur (par-test l)
        (cond ((null l) nil)
              ((funcall par-test (car l))
               (cons (car l) (recur par-test (cdr l))))
              (t (recur par-test (cdr l)))))
      (let ((l (cons first args))
             (par-test (if (evenp first) 'evenp 'oddp)))
        (recur par-test l)))

    (same-parity-rec 2 3 4 5 6 7)
#+END_SRC
*** Exercise 2.21
#+BEGIN_SRC elisp
    (defun square-list (items)
      (if (null items)
          nil
        (cons (* (car items) (car items))
              (square-list (cdr items)))))

    (square-list (list 1 2 3 4)) ; => (1 4 9 16)

    (defun square-list (items)
      (mapcar (lambda (x) (* x x)) items))

    (square-list (list 1 2 3 4)) ; => (1 4 9 16)
#+END_SRC

*** Exercise 2.22
#+BEGIN_SRC elisp
  (defun square-list (items)
    (defun iter (things answer)
      (if (null things)
          answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
    (iter items nil))
  (square-list (list 1 2 3 4)) ; => (16 9 4 1)

  ; The result is in reverse order because the list is being
  ; constructing the list as `(cons (square (car things)) answer)'
  ; where the processed items are being stored in answer so the
  ; newly processed items are put in front and pushing back the
  ; items that where processed first.

  (defun square-list (items)
    (defun iter (things answer)
      (if (null things)
          answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
    (iter items nil))
  (square-list (list 1 2 3 4)) ; => ((((nil . 1) . 4) . 9) . 16)

  ; The second fix doesn't work either because the `answer' list
  ; is being put at the car position of the pair making the `answer'
  ; list a single element in the car position. So if `answer'
  ; is a list `(((1) 4) 9)' then constructing a new pair to insert `16'
  ; the result will be `(((1) 4) 9) 16)'
#+END_SRC

*** Exercise 2.23
#+BEGIN_SRC elisp
  (defun for-each (f items)
    (if (null items)
        nil
      (funcall f (car items))
      (for-each f (cdr items))))

  (for-each (lambda (x) (insert (format "%d\n" x)))
            (list 1 2 3 4))
#+END_SRC

*** Exercise 2.24
#+BEGIN_SRC elisp
(list 1 (list 2 (list 3 4)))
 ; interpreter notation:> (1 (2 (3 4)))
 ; point box notation:
 ;
 ; (1(2(3 4)))  +---+---+         +---+---+
 ;         ---->| * | *-+-------->| * | / |
 ;              +-|-+---+         +-|-+---+
 ;                |                 |
 ;                V                 V
 ;              +---+             +---+---+       +---+---+
 ;              | 1 |  (2(3 4))-> | * | *-+------>| * | / |
 ;              +---+	          +-|-+---+       +-|-+---+
 ; 			            |               |
 ; 			            V               V
 ;                                +---+           +---+---+      +---+---+
 ; 			          | 2 |  (3 4) -> | * | *-+----->| * | / |
 ; 			          +---+	          +-|-+---+      +-|-+---+
 ; 					            |              |
 ; 					            V              V
 ;                                                +---+          +---+
 ; 					          | 3 |	         | 4 |
 ; 					          +---+	         +---+
 ; Tree notation:
 ;    (1 (2 (3 4)))
 ;       ^
 ;     /   \
 ;     1   (2 (3 4))
 ;           ^
 ;         /   \
 ;        2   (3 4)
 ;              ^
 ;            /  \
 ;           3    4
#+END_SRC

*** Exercise 2.25
#+BEGIN_SRC elisp

  (car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9)))))) ; => 7
  (car (car (list (list 7)))) ; => 7
  (car(cdr(car(cdr(car(cdr(car(cdr(car(cdr(car(cdr '(1 (2 (3 (4 (5 (6 7))))))))))))))))))

#+END_SRC
*** Exercise 2.26
#+BEGIN_SRC elisp
  (defvar x (list 1 2 3))
  (defvar y (list 4 5 6))
  (append x y) ; => (1 2 3 4 5 6)
  (cons x y)   ; => ((1 2 3) 4 5 6)
  (list x y)   ; => ((1 2 3) (4 5 6))
#+END_SRC

*** Exercise 2.27
#+BEGIN_SRC elisp
  (defun reverse-deep (l)
    (cond ((consp l)
           (if (null (cdr l))
               (reverse-deep (car l))
             (list (reverse-deep (cdr l))
                   (reverse-deep (car l)))))
          (t  l)))

  (reverse '((1 2) (3 4)))       ; => ((3 4) (1 2))
  (reverse-deep '((1 2) (3 4)))  ; => ((4 3) (2 1))

#+END_SRC

*** Exercise 2.28
#+BEGIN_SRC elisp
  (defun sicp-fringe (lst)
    (cond ((null lst) nil)
          ((consp lst) (append (sicp-fringe (car lst))
                               (sicp-fringe (cdr lst))))
          (t (list lst))))

  (sicp-fringe '((1 2) (3 4))) ; => (1 2 3 4)
#+END_SRC

*** Exercise 2.29
#+BEGIN_SRC elisp
  (defun make-mobile (left right)
    (list left right))

  ; a. Selectors
  (defun left-branch  (m) (car m))
  (defun right-branch (m) (cadr m))

  (defun make-branch (length structure)
    (list length structure))

  ; a. selectors
  (defun branch-length    (b) (car b))
  (defun branch-structure (b) (cadr b))

  ; b. total weight
  (defun total-weight (m)
    (defun branch-weight (b)
      (let ((structure (branch-structure b)))
        (if (consp structure)
            (+ (branch-weight (left-branch  structure))
               (branch-weight (right-branch structure)))
          structure)))
    (+ (branch-weight (left-branch  m))
       (branch-weight (right-branch m))))

  ; Test total weight
  (total-weight (make-mobile
                 (make-branch 1 5)
                 (make-branch 2 (make-mobile
                                 (make-branch 1 6)
                                 (make-branch 1 1)))))
  ; c. balanced
  ; I'm not familiar with this data structure, so this is what
  ; I understood by testing if the mobile is balanced.
  (defun mobile-balanced? (m)
    (defun branch-torque (b)
      (* (branch-length b) (branch-weight b)))
    (let ((l (left-branch m))
          (r (right-branch m)))
      (and (= (branch-torque (left-branch  m))
              (branch-torque (right-branch m)))
         (if (consp l) (mobile-balanced? l) t)
         (if (consp r) (mobile-balanced? r) t))))

  ; d. Not much, just change the selectors.
  (defun right-branch     (m) (cdr m))
  (defun branch-structure (b) (car b))
#+END_SRC

*** Exercise 2.30
#+BEGIN_SRC elisp
  (defun square-tree (tree)
    (mapcar (lambda (sub-tree)
              (if (consp sub-tree)
                  (square-tree sub-tree)
                (* sub-tree sub-tree)))
            tree))

  (square-tree '(1 (2 (3 4) 5) (6 7))) ; => (1 (4 (9 16) 25) (36 49))

  (defun square-tree (tree)
    (cond ((null tree) nil)
          ((consp tree) (cons (square-tree (car tree))
                              (square-tree (cdr tree))))
          (t (* tree tree))))

  (square-tree '(1 (2 (3 4) 5) (6 7))) ; => (1 (4 (9 16) 25) (36 49))
#+END_SRC

*** Exercise 2.31
#+BEGIN_SRC elisp
  (defun tree-map (f tree)
    (mapcar (lambda (sub-tree)
           (if (consp sub-tree)
               (tree-map f sub-tree)
             (funcall f sub-tree)))
         tree))

  (defun square-tree (tree)
    (tree-map (lambda (x) (* x x)) tree))

  (square-tree '(1 (2 (3 4) 5) (6 7))) ; => (1 (4 (9 16) 25) (36 49))
#+END_SRC

*** Exercise 2.32
#+BEGIN_SRC elisp
  (defun subsets (s)
    (if (null s)
        (list nil)
        (let ((rest (subsets (cdr s))))
          (append rest (mapcar (lambda (x)
                                 (cons (car s) x))
                               rest)))))

  (subsets '(1 2 3)) ; => (nil (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))

  ; Each subset generates a list as an output, the procedure
  ; recurses until it retrieves the empty list, then for
  ; each member of the resulting list, combine the `car'
  ; member of the previous higher subset to each member of
  ; the forming list, this will generate all possible
  ; combinations.

  ; Iterations for set (1 2 3)

  ; input       return values
  ;         -> ( () (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)))
  ; (1 2 3) -> ( () (3) (2) (2 3))
  ; (2 3)   -> ( () (3) )
  ; (3)     -> ( () )
  ; ()      -> ( () )
#+END_SRC

*** Exercise 2.33
#+BEGIN_SRC elisp
(defun sicp-map (p seq)
  (accumulate (lambda (x y)
                (cons (funcall p x) y))
              nil
              seq))

(sicp-map (lambda (x) (* x x)) '(1 2 3 4 5))
   ; => (1 4 9 16 25)

(defun sicp-append (seq1 seq2)
  (accumulate #'cons seq2 seq1))

(sicp-append '(1 2 (3)) '(4 (5 6)))
   ; => (1 2 (3) 4 (5 6))

(defun sicp-length (seq)
  (accumulate (lambda (x y) (1+ y)) 0 seq))

(sicp-length '(0 1 2 3)) ; => 4
#+END_SRC
*** Exercise 2.34
#+BEGIN_SRC elisp
(defun horner-eval (x coeff-seq)
  (accumulate (lambda (this-coeff higher-terms)
                (+ this-coeff (* higher-terms x)))
              0
              coeff-seq))

f(x) = 2x^3 + x^2 + x + 1
f(2) = 16 + 4 + 2 + 1 = 23
(horner-eval 2 '(1 1 1 2)) ; => 23
#+END_SRC

*** Exercise 2.35
#+BEGIN_SRC elisp
(defun count-leaves (tree)
  (accumulate #'+
              0
              (mapcar (lambda (sub-tree)
                     (if (consp sub-tree)
                         (count-leaves sub-tree)
                       1)) tree)))

 (count-leaves '(1 2 (3 4 5) (6) (7 8)))
#+END_SRC

*** Exercise 2.36
#+BEGIN_SRC elisp
(defun accumulate-n (op init seqs)
  (if (null (car seqs))
      nil
      (cons (accumulate op
                        init
                        (mapcar (lambda (x) (car x))
                                seqs))
            (accumulate-n op
                          init
                          (mapcar (lambda (x) (cdr x))
                                  seqs)))))

(accumulate-n #'+ 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
   ; => (22 26 30)
#+END_SRC
*** Exercise 2.37
#+BEGIN_SRC elisp
(defun dot-product (v w)
  (accumulate #'+
              0
              (accumulate-n #'* 1 (list v w))))
(dot-product '(1 2 3) '(2 3 4)) ; => 20

(defun matrix-*-vector (m v)
  (mapcar (lambda (x)
         (dot-product x v)) m))

(defun transpose (m)
  (accumulate-n #'cons nil m))

(transpose ' ((1 2 3) (4 5 6)))
  ; => ((1 4) (2 5) (3 6))

(defun matrix-*-matrix (m n)
  (let ((cols (transpose n)))
    (mapcar (lambda (row)
              (matrix-*-vector cols row))
            m)))

(matrix-*-matrix '((1 3 5) (7 9 11) (13 15 17))
                 '((1 2 3) (4 5 6) (7 8 9)))
#+END_SRC

*** Exercise 2.38:
#+BEGIN_SRC elisp
(defun fold-left (op init seq)
  (defun iter (result rest)
    (if (null rest)
        result
     (iter (funcall op result (car rest))
           (cdr rest))))
  (iter init seq))

(defun fold-right (op initial seq)
  (if (null seq)
      initial
    (funcall op (car seq)
                (accumulate op initial (cdr seq)))))

(fold-right #'/ 1.0 (list 1 2 3)) ; => 1.5

(fold-left #'/ 1.0 (list 1 2 3)) ; => 0.1666

(fold-right #'list nil (list 1 2 3)) ; => (1 (2 (3 nil)))

(fold-left #'list nil (list 1 2 3))  ; => (((nil 1) 2) 3)

; commutative property is the one that `op' should satisfy,
; operations like `*', `+'

(fold-right #'+ 1.0 (list 1 2 3)) ; => 7.0
(fold-left #'+ 1.0 (list 1 2 3))  ; => 7.0

(fold-right #'* 1.0 (list 1 2 3)) ; => 6.0
(fold-left #'* 1.0 (list 1 2 3))  ; => 6.0
#+END_SRC

*** Exercise 2.39
#+BEGIN_SRC elisp
(defun reverse-right (seq)
  (fold-right (lambda (x y) (append y (list x))) nil seq))

(reverse-right '(1 2 3 4)) ; => (4 3 2 1)

(defun reverse-left (seq)
  (fold-left (lambda (x y) (cons y x)) nil seq))

(reverse-left '(1 2 3 4)) ; => (4 3 2 1)

; To understand how the parameters are passed to the `op' is
; the `x' parameter is the current parameter being processed
; and `y' is the list to be processed in the case of `fold-left'
; or the list already processed in the case of `fold-right'.
#+END_SRC

*** Exercise 2.40
#+BEGIN_SRC elisp
(defun unique-pairs (n)
  (flatmap (lambda (i)
             (mapcar (lambda (j) (list i j))
                     (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))
(unique-pairs 4)
  ; => ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3))

(defun prime-sum (pair)
  (prime? (+ (car pair) (cadr pair))))

(defun make-pair-sum (pair)
  (list (car pair)
        (cadr pair)
        (+ (car pair) (cadr pair))))

(defun prime-sum-pairs (n)
  (mapcar 'make-pair-sum
          (filter 'prime-sum (unique-pairs n))))

(prime-sum-pairs 5)
#+END_SRC

*** Exercise 2.41
#+BEGIN_SRC elisp
(defun ordered-unique-triplets (n)
  (flatmap (lambda (i)
             (flatmap (lambda (j)
                       (mapcar (lambda (k) (list i j k))
                               (enumerate-interval 1 (- j 1))))
                     (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))

(ordered-unique-triplets 4)
  ; => ((3 2 1) (4 2 1) (4 3 1) (4 3 2))

;; reusing the unique-pairs
(defun ordered-unique-triplets (n)
  (flatmap (lambda (i)
             (mapcar (lambda (pair) (cons i pair))
                     (unique-pairs (1- i))))
           (enumerate-interval 1 n)))
(ordered-unique-triplets 4)
  ; => ((3 2 1) (4 2 1) (4 3 1) (4 3 2))

(defun triplets-lower-than-n-that-sums-to-s (n s)
  (filter (lambda (triplet) (= s (accumulate '+ 0 triplet)))
          (ordered-unique-triplets n)))

(triplets-lower-than-n-that-sums-to-s 5 9)
  ; => ((4 3 2) (5 3 1))
#+END_SRC

*** Exercise 2.42
#+BEGIN_SRC elisp
  (setq max-specpdl-size 50000)
  (setq max-lisp-eval-depth 10000)

  (defun queens (board-size)
    (defun queens-cols (k)
      (if (= k 0)
          (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (mapcar (lambda (new-row)
                      (adjoin-position new-row k rest-of-queens))
                    (enumerate-interval 1 board-size)))
          (queens-cols (- k 1))))))
    (queens-cols board-size))

  (defun adjoin-position (new k rest) (cons new rest))
  (defvar empty-board nil)
  (defun safe? (k positions)
    (defun iter (i new pos)
      (cond ((null pos) t)
            ((or (same-row? new (car pos))
                 (same-diagonal? new (car pos) i))
              nil)
            (t (iter (1+ i) new (cdr pos)))))
    (iter 1 (car positions) (cdr positions)))

  (defun same-row? (new prev)
    (= prev new))

  (defun same-diagonal? (new-row old-row cols-of-sep)
    (= (abs (- new-row old-row)) cols-of-sep))

  (length (queens 8))
#+END_SRC

*** Exercise 2.43
#+BEGIN_SRC elisp
  (defun queens (board-size)
    (defun queens-cols (k)
      (if (= k 0)
          (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
          (flatmap
           (lambda (new-row)
             (mapcar (lambda (rest-of-queens)
                       (adjoin-position new-row k rest-of-queens))
                     (queens-cols (- k 1))))
           (enumerate-interval 1 board-size)))))
    (queens-cols board-size))
  (queens 8)

; Thanks to http://wqzhang.wordpress.com/2009/06/23/sicp-exercise-2-43/
; At first glance it looked to me that it should be the same, but I wasn't
; considering the difference of complexity of running `queens-cols' multiple
; times against running `enumerate-interval' multiple times.
; After considering this, now is obvious that running `queens-cols' repeatedly
; for the same `k' will highly increase the complexity, so if the first version
; of the procedure has a time of `T', then it seems that the time for the
; second procedure will be `T^board-size'
#+END_SRC

*** Exercise 2.44
#+BEGIN_SRC elisp
  (defun right-split (painter n)
    (if (= n 0)
        painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))

  (defun up-split (painter n)
    (if (= n 0)
        painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
#+END_SRC

*** Exercise 2.45
#+BEGIN_SRC elisp
     (define (right-split painter n)
       (if (= n 0)
           painter
           (let ((smaller (right-split painter (- n 1))))
             (beside painter (below smaller smaller)))))

  ; a simple split would be like
  (defun split (t1 t2)
    (lambda (painter)
      (funcall t1 painter (funcall t2 painter painter))))

  ; an nth split would be applied like
  (defun split (t1 t2)
    (lambda (painter n)
      (if (= n 0)
          painter
        (let ((smaller (right-split painter (- n 1))))
          (funcall t1 painter (funcall t2 painter painter))))))

  (defvar right-split (split #'beside #'below))
  (defvar up-split (split #'below #'beside))
#+END_SRC

*** Exercise 2.46
#+BEGIN_SRC elisp
  (defun make-vect (xcor ycor) (cons xcor ycor))
  (defun xcor-vect (v) (car v))
  (defun ycor-vect (v) (cdr v))

  (defun add-vect (v w)
    (make-vect (+ (xcor-vect v) (xcor-vect w))
               (+ (ycor-vect v) (ycor-vect w))))

  (defun sub-vect (v w)
    (make-vect (- (xcor-vect v) (xcor-vect w))
               (- (ycor-vect v) (ycor-vect w))))

  (defun scale-vect (s v)
    (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))
#+END_SRC

*** Exercise 2.47
#+BEGIN_SRC elisp
  ; First implementation
  (defun make-frame (origin edge1 edge2)
    (list origin edge1 edge2))

  (defun origin-frame (f) (car f))
  (defun edge1-frame (f) (cadr f))
  (defun edge2-frame (f) (caddr f))

  ; test
  (origin-frame (make-frame (make-vect 1 1)
                            (make-vect 2 2)
                            (make-vect 3 3)))
  (edge1-frame (make-frame (make-vect 1 1)
                           (make-vect 2 2)
                           (make-vect 3 3)))
  (edge2-frame (make-frame (make-vect 1 1)
                           (make-vect 2 2)
                           (make-vect 3 3)))

  ; Second implementation
  (defun make-frame (origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  (defun origin-frame (f) (car f))
  (defun edge1-frame (f) (cadr f))
  (defun edge2-frame (f) (cddr f))
#+END_SRC

*** Exercise 2.48
#+BEGIN_SRC elisp
  (defun make-segment (v w) (cons v w))
  (defun start-point (s) (car s))
  (defun end-point (s) (cdr s))

  ; Test
  (start-point (make-segment (make-vect 1 1) (make-vect 2 2)))
  (end-point (make-segment (make-vect 1 1) (make-vect 2 2)))
#+END_SRC

*** Exercise 2.49
#+BEGIN_SRC elisp
  ; The idea is to define the segments list that creates
  ; the corresponding painter.
  ;
  ; a. The painter that draws the outline of the designated
  ;    frame
  (defun outline-of-frame (f)
    (let* ((origin (origin-frame f))
           (edge1 (add-vect origin (edge1-frame f)))
           (edge2 (add-vect origin (edge2-frame f)))
           (opposite-corner (add-vect edge1 edge2))
           (segment-list (list (make-segment origin edge1)
                               (make-segment origin edge2)
                               (make-segment edge1 opposite-corner)
                               (make-segment edge2 opposite-corner))))
      (funcall (segments->painter segment-list) f)))

  ; b. The painter that draws an "X" by connecting the
  ;    opposite corners of the frame
  (defun connect-opposite-corner (f)
    (let* ((bottom-left (origin-frame f))
           (bottom-right (add-vect origin (edge1-frame f)))
           (top-left (add-vect origin (edge2-frame f)))
           (top-right (add-vect edge1 edge2))
           (segment-list (list (make-segment bottom-left top-right)
                               (make-segment bottom-right top-left))))
      (funcall (segments->painter segment-list) f)))

  ; c. The painter that draws a diamond shape by connecting
  ;    the midpoints of the sides of the frame
  (defun connect-diamond (f)
    (let ((mid-edge1 (funcall (frame-coord-map f) (make-vect 0.0 0.5)))
          (mid-edge2 (funcall (frame-coord-map f) (make-vect 0.5 0.0)))
          (mid-edge3 (add-vect mid-edge1 (edge2-frame f)))
          (mid-edge4 (add-vect mid-edge2 (edge1-frame f)))
          (segment-list (list (make-segment mid-edge1 mid-edge2)
                              (make-segment mid-edge1 mid-edge4)
                              (make-segment mid-edge2 mid-edge3)
                              (make-segment mid-edge3 mid-edge4))))
      (funcall (segments->painter segment-list) f)))

  ; d. The wave painter
  ; This is a tough one, save it for later.
#+END_SRC

*** Exercise 2.50
#+BEGIN_SRC elisp
(defun flip-horiz (painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))

(defun rotate-90-counterclockwise (painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))

(defun rotate-180-counterclockwise (painter)
  (rotate-90-counterclockwise
    (rotate-90-counterclockwise painter)))

(defun rotate-270-counterclockwise (painter)
  (rotate-90-counterclockwise
    (rotate-180-counterclockwise painter)))

#+END_SRC

*** Exercise 2.51
#+BEGIN_SRC elisp
(defun below (painter1 painter2)
  (let* ((split-point (make-vect 0.0 0.5))
         (paint-below
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              (make-vect 1.0 0.0)
                              split-point))
         (paint-top
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.5)
                              (make-vect 0.0 1.0))))
    (lambda (frame)
      (funcall paint-below frame)
      (funcall paint-top frame))))

(defun below2 (painter1 painter2)
  (let* ((top-painter (rotate-90-counterclockwise painter1))
         (bot-painter (rotate-90-counterclockwise painter2))
         (both-painter (beside bot-painter top-painter)))
    (rotate-270-counterclockwise both-painter)))

#+END_SRC

*** Exercise 2.52
#+BEGIN_SRC elisp
  ; a. Add some segments to the primitive `wave' painter
  ;    Haven't written `wave' yet.
  ;
  ; b. Change the pattern constructed by `corner-split'
  ;   (for example by using only one copy of the `up-split'
  ;   and `right-split' images instead of two).
  ;
  (defun corner-split (painter n)
    (if (= n 0)
        painter
      (let* ((up (up-split painter (- n 1)))
             (right (right-split painter (1- n)))
             (corner (corner-split painter (1- n))))
        (beside (below painter up)
                (below right corner)))))

  ; c. Modify the version of `square-limit' that uses the
  ;   `square-of-four' so as to assemble the corners in a
  ;   different pattern. (For example, you might make the
  ;   big Mr. Rogers look outward from each corner of the
  ;   square.)

  (defun square-limit (painter n)
    (let ((combine4 (square-of-four identity  flip-horiz
                                    flip-vert rotate180)))
      (combine4 (corner-split painter n))))

#+END_SRC

*** Exercise 2.53
#+BEGIN_SRC elisp
(list 'a 'b 'c)                         ; => (a b c)
(list (list 'george))                   ; => ((george))
(cdr '((x1 x2) (y1 y2)))                ; => ((y1 y2))
(cadr '((x1 x2) (y1 y2)))               ; =>  (y1 y2)
(consp (car '(a short list)))           ; => nil
(memq 'red '((red shoes) (blue socks))) ; => nil
(memq 'red '(red shoes blue socks))     ; => (red shoes blue socks)
#+END_SRC

*** Exercise 2.54
#+BEGIN_SRC elisp
(defun equal? (a b)
  (cond ((and (null a) (null b)) t)
        ((not (eq (car a) (car b))) nil)
        (t (equal? (cdr a) (cdr b)))))

(equal? '(this is a list) '(this is a list))    ; => t
(equal? '(this is a list) '(this (is a) list))  ; => nil
#+END_SRC

*** Exercise 2.55
#+BEGIN_SRC elisp
(car ''abracadabra) ; => quote

; As mentioned in the text `'' is a shorthand for quote,
; so the first quote is "quoting" the second call to quote.
; If we expand the expression without the car, it will
; look like this:
(quote (quote abracadabra)) ; => (quote abracadabra)

; and extracting the `car' of the expression, will retrieve
; the symbol `quote'.

(car (quote (quote abracadabra))) ; => quote
#+END_SRC

*** Exercise 2.56
#+BEGIN_SRC elisp
(defun exponentiation? (exp)
  (and (consp exp) (eq (car exp) '**)))
(defun base (exp) (cadr exp))
(defun exponent (exp) (caddr exp))
(defun make-exponentiation (base exp)
  (cond ((=number? exp 0) 1)
        ((=number? exp 1) base)
        (t `(** ,base ,exp))))

(defun deriv (exp var)
  (cond ((numberp exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
          (make-product (exponent exp)
                        (make-exponentiation (base exp)
                                             (make-sum (exponent exp) -1)))
          (deriv (base exp) var)))
        (t (error "unknown expression type == DREIV"))))

(deriv '(+ (** x 3) (** (* 6 x) 2)) 'x)
  ; => (+ (* 3 (** x 2)) (* (* 2 (* 6 x)) 6))

(deriv '(+ (** x 3) (* 6 (** x 2))) 'x)
  ; => (+ (* 3 (** x 2)) (* 6 (* 2 x)))
#+END_SRC

*** Exercise 2.57
#+BEGIN_SRC elisp
(defun augend (s)
  (if (null (cdddr s))
      (caddr s)
    (cons '+ (cddr s))))

(defun multiplicand (p)
  (if (null (cadddr p))
      (caddr p)
    (cons '* (cddr p))))

(augend '(+ 1 2 3))       ; => (+ 2 3)
(multiplicand '(* 1 2 3)) ; => (* 2 3)

(augend '(+ 1 3))       ; => 3
(multiplicand '(+ 1 3)) ; => 3

; As expected
(deriv '(* x y (+ x 3)) 'x)
  ; => (+ (* x y) (* y (+ x 3)))
#+END_SRC

*** Exercise 2.58
#+BEGIN_SRC elisp
; a. using parenthesized infix notation
(defun make-sum (a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (numberp a1) (numberp a2) (+ a1 a2)))
        (t `(,a1 + ,a2))))

(defun make-product (m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (numberp m1) (numberp m2)) (* m1 m1))
        (t `(,m1 * ,m2))))

(defun sum? (x)
  (and (consp x) (eq (cadr x) '+)))
(defun addend (s) (car s))
(defun augend (s) (caddr s))

(defun product? (x)
  (and (consp x) (eq (cadr x) '*)))
(defun multiplier (p) (car p))
(defun multiplicand (p) (caddr p))

(deriv '(x + (3 * (x + (y + 2)))) 'x) ; => 4
(deriv '(3 * (x * x)) 'x) ; => (3 * (x + x))

b.
; The idea behind this approach is to
; split all the sums first, isolating
; products and resolving them first.
; This is done by testing if at the highest
; level of the equation if it contains a '+
; which is achieved by rewriting `sum?'.
; Then just re-write the selectors to return
; the values according to this approach, so for
; '((x + y) + x * (2 + x))
; addend will return '(x + y)
; augend will return (x * (2 + x))

(defun sum? (x)
  (and (consp x) (memq '+ x)))

(defun addend (s)
  (defun iter (remind acc)
    (cond ((eq (car remind) '+) acc)
          (t (iter (cdr remind)
                   (cons (car remind) acc)))))
  (let ((exp (reverse (iter s nil))))
    (if (null (cdr exp)) (car exp) exp)))

; test
(addend '((x + y) + x * (2 + x))) ; => (x + y)

(defun augend (s)
  (cond ((eq (car s) '+)
         (if (null (cddr s)) (cadr s) (cdr s)))
        (t (augend (cdr s)))))

; test
(augend '((x + y) + x * (2 + x))) ; => (x * (2 + x))

(defun multiplicand (p)
  (if (null (cdddr p))
      (caddr p)
    (cddr p)))

; test
(deriv '(x + 3 * (x + y + 2)) 'x)
(deriv '(x * 3 + (x + y + 2)) 'x)
(deriv '((3 * x * x) + y + 2 * x) 'x)

#+END_SRC

*** Exercise 2.59
#+BEGIN_SRC elisp
; define it as a iterative process

(defun union-set (set1 set2)
  (cond ((null set1) set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1) set2))
        (t (union-set (cdr set1)
                      (cons (car set1) set2)))))

(union-set '(1 2 3 5 5) '(3 4 5 6))
#+END_SRC

*** Exercise 2.60
#+BEGIN_SRC elisp
(defun element-of-set? (x set) (memq x set))
(defun adjoin-set (x set) (cons x set))
(defun union-set (set1 set2) (append set1 set2))

; for intersect is not clear if intersected values
; can be repeated or not, if that doesn't matter
; then the definition stays the same.
(defun intersection-set (set1 set2)
  (cond ((or (null set1) (null set2)) nil)
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (t (intersection-set (cdr set1) set2))))

; If repetition is allowed, then the procedures are
; easier to write. In the case of `adjoin-set' and
; `union-set' the efficiency is better since there's
; no need to call the `element-of-set?', and the effort
; is reduced to constant time. For the case of
; `element-of-set?' and `intersection-set' the efficiency
; remains the same.
#+END_SRC

*** Exercise 2.61
#+BEGIN_SRC elisp
; The implementation shows that as soon the placeholder is
; found the element is inserted, the place holder can be
; the last place in the worst case, or the first place in
; the best case, so in average the element will be inserted
; in [theta](n/2) which is still [theta](n).
(defun adjoin-set (x set)
  (cond ((< x (car set)) (cons x set))
        ((= x (car set)) set)
        (t (cons (car set)
                 (adjoin-set x (cdr set))))))

(adjoin-set 6 '(1 2 3 6 7 8 9)) ; => (1 2 3 6 7 8 9)
(adjoin-set 6 '(1 2 3 7 8 9))   ; => (1 2 3 6 7 8 9)
#+END_SRC

*** Exercise 2.62
#+BEGIN_SRC elisp
; Similarly to intersection-set, this implementation takes
; advantage of the ordered list to execute in order of `2n'
; in the worst case so the complexity is [theta](n).
(defun union-set (set1 set2)
  (cond ((null set1) set2)
        ((null set2) set1)
        (t (let ((x1 (car set1)) (x2 (car set2)))
             (cond ((< x1 x2)
                    (cons x1 (union-set (cdr set1) set2)))
                   ((< x2 x1)
                    (cons x2 (union-set set1 (cdr set2))))
                   (t (cons x1 (union-set (cdr set1)
                                          (cdr set2)))))))))
(union-set '(1) '(2 3 4 5))
#+END_SRC

*** Exercise 2.63
#+BEGIN_SRC elisp
;             7          3             5
;             /\         /\            /\
;            3  9       1  7          3  9
;           /\   \         /\        /   /\
;          1  5  11       5  9      1   7  11
;                             \
;                             11
(defun tree->list-1 (tree)
  (if (null tree)
      nil
    (append (tree->list-1 (left-branch tree))
            (cons (entry tree)
                  (tree->list-1 (right-branch tree))))))

(defun tree->list-2 (tree)
  (defun copy-to-list (tree result-list)
    (if (null tree)
        result-list
      (copy-to-list (left-branch tree)
                    (cons (entry tree)
                          (copy-to-list (right-branch tree)
                                        result-list)))))
  (copy-to-list tree nil))

; a. Yes, the produce the same result for every tree.
;    They produce this list: (1 3 5 7 9 11)
; b. Pend
#+END_SRC

*** Exercise 2.64
#+BEGIN_SRC elisp
(defun list->tree (elements)
  (car (partial-tree elements (length elements))))

(defun partial-tree (elts n)
  (if (= n 0)
      (cons nil elts)
    (let ((left-size (/ (- n 1) 2)))
      (let ((left-result (partial-tree elts left-size)))
        (let ((left-tree (car left-result))
              (non-left-elts (cdr left-result))
              (right-size (- n (+ left-size 1))))
          (let ((this-entry (car non-left-elts))
                (right-result (partial-tree (cdr non-left-elts)
                                            right-size)))
            (let ((right-tree (car right-result))
                  (remaining-elts (cdr right-result)))
              (cons (make-tree this-entry left-tree right-tree)
                    remaining-elts))))))))

; a. the idea behind this algorithm is to cut in half and choose
;    that element of the list and use it as as the pivot for the
;    sub-tree, so it cuts in  half recursively until there's no
;    way to keep cutting and solve first for the left side of the
;    tree and then for the right side of the tree.
;
;    Produced tree:
;    (5 (1 nil (3 nil nil)) (9 (7 nil nil) (11 nil nil)))
;                        5
;                      /   \
;                     1     9
;                      \   / \
;                       3 7  11

; b. All operations in `partial-tree' execute in constant time, and
;    all n nodes need to be visited in order to accommodate them in
;    the tree, so the growth is [theta](n).
#+END_SRC

*** Exercise 2.65
#+BEGIN_SRC elisp
; The idea is to take the balanced tree, then
; convert the representation to an ordered list
; (growth [theta](n)), then apply the procedures
; previously implemented that run in [theta](n)
; and then finally change back the representation
; to balanced tree, the growth will be 3n which
; is still [theta](n).
(defun union-set-balanced (set1 set2)
  (list->tree (union-set (tree->list-1 set1)
                         (tree->list-2 set2))))

(defun intersection-set-balanced (set1 set2)
  (list->tree (intersection-set (tree->list-1 set1)
                                (tree->list-2 set2))))

(union-set-balanced (list->tree '(1 2 5 6))
                    (list->tree '(2 3 4)))
; => (3 (1 nil (2 nil nil)) (5 (4 nil nil) (6 nil nil)))

;                       3
;                     /   \
;                    1     5
;                     \   / \
;                      2 4   6

(intersection-set-balanced (list->tree '(0 2 4 5 6 8 9))
                           (list->tree '(0 2 5 6 7 8 9)))
; (5 (0 nil (2 nil nil)) (8 (6 nil nil) (9 nil nil)))
;
;                       5
;                     /   \
;                    0     8
;                     \   /  \
;                      2 6    9
#+END_SRC

*** Exercise 2.66
#+BEGIN_SRC elisp
(defun lookup (given-key set-of-records)
  (cond ((null set-of-records) nil)
        ((equal given-key (entry set-of-records)) t)
        ((< given-key (entry set-of-records))
         (lookup given-key (left-branch set-of-records)))
        ((> given-key (entry set-of-records))
         (lookup given-key (right-branch set-of-records)))))

(lookup 5 (list->tree '(-4 0 1 2 3 4 5 10))) ; => t
(lookup 9 (list->tree '(-4 0 1 2 3 4 5 10))) ; => nil
#+END_SRC

*** Exercise 2.67
#+BEGIN_SRC elisp
(defvar sample-tree
  (make-code-tree
    (make-leaf 'A 4)
    (make-code-tree (make-leaf 'B 2)
                    (make-code-tree (make-leaf 'D 1)
                                    (make-leaf 'C 1)))))
(defvar sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(decode sample-message sample-tree)
  ; => ((A) (D) (A) (B) (B) (C) (A))
#+END_SRC

*** Exercise 2.68
#+BEGIN_SRC elisp
  (defun encode (message tree)
    (if (null message)
        nil
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))

  (defun encode-symbol (symbol tree)
    (cond ((leaf? tree) nil)
          ((memq symbol (symbols (left-branch tree)))
           (cons '0 (encode-symbol symbol (left-branch tree))))
          ((memq symbol (symbols (right-branch tree)))
           (cons '1 (encode-symbol symbol (right-branch tree))))
          (t (error "Symbol doesn't exist in tree -- ENCODE-SYMBOL"))))

  (encode-symbol 'D sample-tree) ; => (1 1 0)
  (equal (encode'(A D A B B C A) sample-tree) sample-message) ; => t
#+END_SRC

*** Exercise 2.69
#+BEGIN_SRC elisp
    (defun generate-huffman-tree (pairs)
      (successive-merge (make-leaf-set pairs)))

    (defun successive-merge (leafs)
      (defun merge (nodes acc)
        (if (null nodes)
            acc
          (merge (cdr nodes) (make-code-tree (car nodes) acc))))
      (merge (cdr leafs) (car leafs)))

    ; Compare the result of `successive-merge' against manual
    ; construction of the tree
    (equal
      (successive-merge '((leaf C 1) (leaf D 1) (leaf B 2) (leaf A 4)))
      (make-code-tree
        '(leaf A 4)
         (make-code-tree
           '(leaf B 2)
            (make-code-tree '(leaf D 1) '(leaf C 1))))) ; => t

    ; Now encode the message from the exercise 2.67 and compare
    ; against the expected result
    (defvar sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
    (equal sample-message
           (encode '(A D A B B C A)
                     (generate-huffman-tree '((A 4) (B 2) (D 1) (C 1)))))
      ; => t
#+END_SRC

*** Exercise 2.70
#+BEGIN_SRC elisp
  (defvar rock-alphabet
    '((A 2) (NA 16) (BOOM 1) (SHA 3)
      (GET 2)  (YIP 9) (JOB 2)  (WAH 1)))

  (setq rock-song
    '(GET A JOB
      SHA NA NA NA NA NA NA NA NA
      GET A JOB
      SHA NA NA NA NA NA NA NA NA
      WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP
      SHA BOOM))

a. How many bits are required for encoding? 84
  (length (encode rock-song
                  (generate-huffman-tree rock-alphabet))) ; => 84

b. What would be the smallest number of bits that would be needed
   to encode this song if we used a fixed-length code for the
   eight symbol alphabet? 108 bits.
   (* (length rock-song) (logb 8)) ; => 108
#+END_SRC

*** Exercise 2.71
#+BEGIN_SRC elisp
a.
n=5
((0 1) (1 2) (2 4) (3 8) (4 16))
(({0 1} 3) (2 4) (3 8) (4 16))
(({0 1 2} 7) (3 8) (4 16))
(({0 1 2 3} 15) (4 16))
({0 1 2 3 4} 31)

n=10
((0 1) (1 2) (2 4) (3 8) (4 16) (5 32) (6 64) (7 128) (8 256) (9 512))
(({0 1} 3) (2 4) (3 8) (4 16)(5 32) (6 64) (7 128) (8 256) (9 512))
(({0 1 2} 7) (3 8) (4 16) (5 32) (6 64) (7 128) (8 256) (9 512))
(({0 1 2 3} 15) (4 16) (5 32) (6 64) (7 128) (8 256) (9 512))
(({0 1 2 3 4} 31) (5 32) (6 64) (7 128) (8 256) (9 512))
(({0 1 2 3 4 5} 63) (6 64) (7 128) (8 256) (9 512))
(({0 1 2 3 4 5 6} 127) (7 128) (8 256) (9 512))
(({0 1 2 3 4 5 6 7} 255) (8 256) (9 512))
(({0 1 2 3 4 5 6 7 8} 511) (9 512))
(({0 1 2 3 4 5 6 7 8 9} 1023))

The tree grows unbalanced with `n-1' levels, but balanced in weight
where at every step the probability to find the symbol splits in
50-50, so in the best scenario the symbol is found in one step and
in the worst case it will be found in `n-1' steps. The probability of
occurrence of a new symbol reduces in 50% in every level. It's hard
to define exactly the number of steps that takes to encode a symbol
but it should be around [theta](1).
#+END_SRC

*** Exercise 2.72
#+BEGIN_SRC elisp
  ; Consider the encoding procedure that you designed in exercise 2.68.
  ; a. What is the order of growth in the number of steps needed to
  ;    encode a symbol?
  ;    In a balanced tree, every node at each level contains a set of
  ;    size n/(2^l) where `l' is the current level of the tree. If we
  ;    consider that the node contains an unordered set, the search for
  ;    a symbol in the node will take  `n/(2^l)' in the worst case.
  ;    The scanning through the complete tree will be in the order of
  ;    `sum_{l} n/(2^l)'. An example of a tree with n=16 the
  ;    procedure will scan in `8+4+2` symbols which is in the order
  ;    of `n'. If the symbol set is ordered, the growth would reduce
  ;    to half `n/2'.
  ;    For the case of the Huffman tree, the growth depends in
  ;    measure of the symbol histogram.
  ; b. For the special case of the tree described in Exercise 2.71
  ;    the most frequent symbol takes `[theta](1)' to encode, and for
  ;    the case of the least frequent symbol, the scan will reduce in
  ;    one symbol at each level, so the scan will accumulate as a sum
  ;    of the type `(+ 2 3 4 5 ... n-1)' which can be represented as
  ;    the `sum_{i=1}^{n-1} k' which the same as `(n-1)n/2' this is
  ;    of quadratic growth `[theta](n^2)'.
#+END_SRC

*** Exercise 2.73
#+BEGIN_SRC elisp
(defun deriv (exp var)
  (cond ((numberp exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (t (error "Unknown expression type -- DERIV"))))

;; Rewriting the basic derivative
(defun deriv (exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (t (funcall (get 'deriv (operator exp)) (operands exp) var))))

(defun operator (exp) (car exp))
(defun operands (exp) (cdr exp))

, a. The expression `exp' now contains tagged information about what it
,    represents, like '+, '*, etc. and the operation is `deriv'. For the
,    case of number? and same-variable?, it wouldn't make much sense to
,    have an expression of type `number?' or `same-variable?' for the
,    operation `deriv'. Numbers and variables would have to be tagged so
,    they could be dispatched, something like: '(number 8) or ' ('var x),
,    that would be inefficient.

; b.
(defun install-deriv-sum-package ()

  (defun make-sum (a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (numberp a1) (numberp a2)) (+ a1 a2))
          (t `(+ ,a1 ,a2))))

  (defun addend (s) (cadr s))
  (defun augend (s) (caddr s))

  (defun sum-deriv (exp var)
    (make-sum (deriv (addend exp) var)))

  (sicp-put 'deriv '+ 'sum-deriv)
  'done)

(defun install-deriv-product-package ()
  (defun make-product (m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (numberp m1) (numberp m2)) (* m1 m1))
          (t `(* ,m1 ,m2))))

  (defun multiplier (p) (cadr p))
  (defun multiplicand (p) (caddr p))

  (defun product-deriv (exp var)
    (make-sum
      (make-product (multiplier exp)
                    (deriv (multiplicand exp) var))
      (make-product (deriv (multiplier exp) var)
                    (multiplicand exp))))

  (sicp-put 'deriv '* 'product-deriv)
  'done)

; c.
(defun install-deriv-exponentiation-package ()
  (defun make-exponentiation (base exp)
    (cond ((=number? exp 0) 1)
          ((=number? exp 1) base)
          (t `(** ,base ,exp))))
  (defun base (exp) (cadr exp))
  (defun exponent (exp) (caddr exp))

  (defun exponentiation-deriv (exp var)
    (make-product
      (make-product (exponent exp)
                    (make-exponentiation (base exp)
                      (make-sum (exponent exp) -1)))
      (deriv (base exp) var)))

  (sicp-put 'deriv '** exponentiation-deriv)
  'done)

; d.
; (funcall (get-sicp (operator exp) 'deriv) (operands exp) var)
; It would be required to modify the `put' so the algebraic symbol
; represents the operation <OP> and the `deriv' represents the type
; <TYPE>.
#+END_SRC

*** Exercise 2.74
#+BEGIN_SRC elisp
; a. need to use the `get' defined in the lesson
;    to retrieve the corresponding procedure name
;    from the procedure table
;    (get <OP> <TYPE>)
;    The implementation  has to include a procedure
;    named `division' that extracts the division name
;    where the file or record belongs.
;    The implementation of get-record for each division
;    must be able to manage that the data structures
;    contain the division tag.
  (defun get-record (employee-name division-file)
    (funcall (get 'get-record (division division-file))
             employee-name division-file))

; b. Implement get-salary
  (defun get-salary (emp-record)
    (funcall (get 'get-salary (division emp-record))
             emp-record))

; c. Implement `find-employee-record'
;    Assuming that no duplicates exist
  (defun find-employee-record (name files)
    (cond ((null files) nil)
          ((consp (get-record name (car files)))
                  (get-record name (car files)))
          (t (find-employee-record name (cdr files)))))

; d. They require to tag the division-file structure with
;    the division name, also need to tag the record
;    structure of each employee so the system knows how
;    to search for the correct procedure in the procedure
;    table.
#+END_SRC

*** Exercise 2.75
#+BEGIN_SRC elisp
(defun make-from-mag-ang (r a)
  `(lambda (op)
    (cond ((eq op 'real-part) (* ,r (cos ,a)))
          ((eq op 'imag-part) (* ,r (sin ,a)))
          ((eq op 'magnitude) ,r)
          ((eq op 'angle) ,a)
          (t (error "Unknown op - MAKE-FROM-MAG-ANGE")))))

(funcall (make-from-mag-ang 1 (/ pi 2)) 'imag-part) ; => 1.0
(funcall (make-from-mag-ang 1 (/ pi 2)) 'real-part) ; => 6.123031769111886e-017
(funcall (make-from-mag-ang 1 (/ pi 2)) 'magnitude) ; => 1
(funcall (make-from-mag-ang 1 (/ pi 2)) 'angle)     ; => 1.5707963267948966
#+END_SRC

*** Exercise 2.76
#+BEGIN_SRC elisp
;   - EXPLICIT DISPATCH: Add the new type to the system being careful
;     of name collision and make the user procedures aware of the new type.
;     so it can dispatch the procedure appropriately.
;   - DATA-DIRECTED: Install the package of the new type and operations
;     the table dispatcher will take care of dispatching the correct
;     procedure. Here the installer needs to be careful of name collision
;     when subscribing procedures in the procedure table.
;   - MESSAGE-PASSING: Create the new type with it's own procedures
;     enclosed, the type will take care of dispatching its own procedures.
;
; Data-directed and message-passing are appropriate to expand the system
; either if adding new procedures or new types. For the case of data-directed
; don't know at what point the procedure table grow extremely large that it
; would be inefficient to dispatch a procedure name, if this could happen,
; then message-passing would be a better choice.
#+END_SRC

*** Exercise 2.77
#+BEGIN_SRC elisp
  ;; when the procedure name is requested, it returns the generic
  ;; name of the procedure from the underlying package.
  ;; The apply generic will be called twice.
  (sicp-put 'real-part '(complex) 'real-part)
  (sicp-put 'imag-part '(complex) 'imag-part)
  (sicp-put 'magnitude '(complex) 'magnitude)
  (sicp-put 'angle '(complex) 'angle)

  ;; Trace for (magnitude '(complex rectangular 3 4))
  (magnitude '(complex rectangular 3 4))
  (apply-generic 'magnitude '(complex rectangular 3 4))
  (apply (sicp-get 'magnitude 'complex) '(rectangular 3 4))

  ; Go down one layer
  (magnitude '(rectangular 3 4))
  (apply-generic 'magnitude '(rectangular 3 4))
  (apply (sicp-get 'magnitude 'rectangular) '(3 4))

  ; Go down another layer
  (magnitude '(3 4))
#+END_SRC

*** Exercise 2.78
#+BEGIN_SRC elisp
  (defun attach-tag (type-tag contents)
    (if (numberp contents)
      contents
        (cons type-tag contents)))

  (defun type-tag (datum)
    (cond ((numberp datum) datum)
          ((consp datum) (car datum))
          (t (error "Bad tagged datum -- TYPE-TAG"))))

  (defun contents (datum)
    (cond ((numberp datum) datum)
          ((consp datum) (cdr datum))
          (t (error "Bad tagged datum -- CONTENTS"))))
#+END_SRC
*** Exercise 2.79
#+BEGIN_SRC elisp
  (defun install-generic-arithmetic-package ()
    (defun equ? (x y) (apply-generic 'equ? x y)))

  (defun install-scheme-number-package ()
    (sicp-put 'equ? '(scheme-number scheme-number)
              (lambda (x y) (= x y))))

  (defun install-rational-package ()
    (sicp-put 'equ? (rational rational)
              (lambda (x y)
                (and (= (numer x) (numer y))
                     (= (denom x) (denom y))))))

  (defun (make-rational n d)
    (sicp-put 'equ? '(complex complex)
              (lambda (z1 z2)
                (and (= (real-part z1) (real-part z2))
                      (= (imag-part z1) (real-part z2))))))
#+END_SRC

*** Exercise 2.80
#+BEGIN_SRC elisp
  (defun install-generic-arithmetic-package ()
    (defun =zero? (x) (apply-generic '=zero? x)))

  (defun install-scheme-number-package ()
    (sicp-put '=zero? 'scheme-number
              (lambda (x) (= x 0))))

  (defun install-rational-package ()
    (sicp-put '=zero? 'rational
              (lambda (x) (= (numer x) 0))))

  (defun install-complex-package ()
    (sicp-put '=zero? 'complex
              (lambda (z1) (and (= (real-part z1) 0)
                                 (= (imag-part z1) 0)))))
#+END_SRC

*** Exercise 2.81
#+BEGIN_SRC elisp
; a. The `apply-generic` procedure will recurse indefinetly trying find the correct
;    procedure, coercing the types over and over.
; b. Louis' code isn't right, it will make `apply-generic` to recurse indefinetly
; c.
  (defun apply-generic (op &optional args)
    (let ((type-tags (map type-tags args)))
      (let ((proc (sicp-get op type-args)))
        (if proc
            (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (eq type1 type2)
                    (error "No method for these types")
                  (let ((t1->t2 (sicp-get-coercion type1 type2))
                        (t2->t1 (sicp-get-coercion type2 type1)))
                    (cond (t1->t2
                           (apply-generic op (t1->t2 a1) a2))
                          (t2->t1
                           (apply-generic op a1 (t2->t1 a2)))
                          (t (error "No method for these types"))))))
            (error "No method for these types"))))))
#+END_SRC
*** Exercise 2.82
#+BEGIN_SRC elisp
  ; This approach for multiple arguments assumes that
  ; the final operation will take all the argumets of
  ; the same type
    (defun apply-generic (op &optional args)
      (let ((type-tags (mapcar 'type-tags args)))
        (let ((proc (sicp-get op type-args)))
          (if proc
              (apply proc (mapcar contents args))
            ;; generate coercion procedure list for a given type
            (defun coercion-list-for-type (type to-coerce)
              (cond ((null to-coerce) nil)
                    (t
                     (let ((c (if (eq type (car to-coerce))
                                  'same-type
                                (sicp-get-coercion type (car to-coerce)))))
                       (if c
                           (append c (coercion-list-for-type type
                                                             (cdr to-coerce)))
                         nil)))))
            ;; provide a type until we get a coercion list
            (defun coercion-procs (type-list)
              (if (null type-list)
                  nil
                (let ((c (coercion-list-for-type (car type-list) type-tags)))
                  (or c (coercion-procs (cdr type-list))))))
            ;; generate a coerced args list that will serve for apply-generic
            (defun coerce-args (procs args)
              (if (or (null procs) (null args))
                  nil
                (cons
                 (if (eq (car procs) 'same-type)
                     (car args)
                   (list (car procs) (car args)))
                 (coerce-args (cdr procs) (cdr args)))))
            (let ((coerce-procs (coercion-procs type-tags)))
              (if coerce-procs
                  (apply-generic
                   op (mapcar 'eval (coerce-args coerce-procs args)))
                (error "No method for these types")))))))

  ;; The approach above assumes theat the final operation will take
  ;; all the arguments of the same type. This approach won't work
  ;; correctly if there are any procedures that take multiple typed
  ;; i.e. the procedure table contains an entry defined by
  (sicp-put 'some-op '(scheme-number complex)
    (lambda (x y) (tag (- x y))))
  ;; As can be seen, the procedure will take different typed arguments,
  ;; but our `apply-generic` will only try to coerce the arguments in
  ;; the following order:
  ;; 1. (scheme-number scheme-number)
  ;; 2. (complex complex)
  ;; (scheme-number complex) won't be tried.
#+END_SRC
*** Exercise 2.83
#+BEGIN_SRC elisp
  (defun rise-int (x) (make-rational x 1))
  (defun rise-rat (x) (make-real (/ (numer x) (denom x))))
  (defun rise-real (x) (make-complex x 0))
  (sicp-put 'rise 'int 'rise-int)
  (sicp-put 'rise 'rat 'rise-rat)
  (sicp-put 'rise 'real 'rise-real)
  (defun rise (x) (apply-generic 'rise x))
#+END_SRC
*** Exercise 2.84
#+BEGIN_SRC elisp
  ; Determine if a t1 is lower that t2 in the
  ; hierarchy tower.
  (defun is-lower-type (t1 t2)
    (defvar type-hierarchy '(int rat real complex))
    (defun type-index (type hier acc)
      (cond ((>= acc (length type-hierarchy))
             (error "Type doesn't exist"))
            ((eq type (car hier)) acc)
            (t (type-index type (cdr hier) (1+ acc)))))
    (< (type-index t1 type-hierarchy 0)
       (type-index t2 type-hierarchy 0)))

  ;; usng rise to coerce the arguments
  (defun apply-generic (op &optional args)
     (let ((type-tags (map type-tags args)))
      (let ((proc (sicp-get op type-args)))
        (if proc
            (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (cond ((eq type1 type2)
                       (apply-generic op a1 a2))
                      ((is-lower-type type1 type2)
                       (apply-generic op (raise a1) a2))
                      ((is-lower-type type2 type1)
                       (apply-generic op a1 (raise a2)))))
            (error "No method for these types"))))))

#+END_SRC
*** Exercise 2.85
#+BEGIN_SRC elisp
  ; hierarcy tower '(int rat real complex)
  (sicp-put project 'complex
            (lambda (z) (make-real (real-part z))))

  ;; simplistic way to convert real to rational
  (sicp-put project 'real
            (lambda (x)
              (let ((int-part (floor x))
                    (dec-part (- (abs x) (abs (floor x)))))
                (add (make-rat (int-part) 1)
                     (make-rat (round (* dec-part 1000)) 1000)))))

  (sicp-put project 'rat
            (lambda (x)
              (make-scheme-number (round (/ (numer x) (denom))))))

  (defun drop (x)
    (let ((proc (sicp-get 'project (type-tag x))))
      (if proc
          (let ((projected (funcall proc x)))
            (if (equ? projected (raise projected))
                (drop projected)
              x))
        x)))
#+END_SRC

*** Exercise 2.86
#+BEGIN_SRC elisp
; PENDING
#+END_SRC
*** Exercise 2.87
#+BEGIN_SRC elisp
  (defun zero-poly (p)
    (defun zero-terms (terms)
      (cond ((empty-termlist? terms) t)
            ((=zero? (coeff (first-term terms)))
             (zero-terms (rest-terms terms)))
            (t nil)))
    (zero-terms (term-list p)))

  (sicp-put '=zero? 'polynomial 'zero-poly)
#+END_SRC

*** Exercise 2.88
#+BEGIN_SRC elisp
  (sicp-put 'negate 'scheme-number
            (lambda (n) (tag (-n))))

  (sicp-put 'negate 'rational
            (lambda (n)
              (tag (make-rat (- (numer-rat n))
                             (- (denom-rat n))))))
  (sicp-put 'negate 'complex
            (lambda (z)
              (tag (make-complex (- (real-part z))
                                 (- (imag-part z))))))
  (sicp-put 'negate 'polynomial
            (lambda (p)
              (defun negate-terms (terms)
                (if (empty-termlist? terms)
                    (the-empty-termlist)
                   (let ((t (first-term terms)))
                     (adjoin-term (make-term (order t) (negate (coeff t)))
                                  (negate-terms (rest-terms terms))))))
              (make-polynomial (variable p) (negate-terms (term-list p)))))

  (sicp-put 'sub '(polynomial polynomial)
            (lambda (p1 p2) (add-polynomial p1 (negate p2))))
#+END_SRC

*** Exercise 2.89
#+BEGIN_SRC elisp
  ; The poly representation has to change from a list:
  ;   '(var ((order1 elem1) (order2 elem2) ...))
  ; To a list in the form of:
  ;   '(var (elem1 elem2 elem3 ...))

  ; insert a new element in the right place within the list
  (defun adjoin-term (term term-list)
    (let ((poly-order (1- (length term-list)))
          (term-order (order term)))
      (cond ((= poly-order (1- term-order))
             (append (coeff term) term-list))
            ((< poly-order (1- term-order))
             (adjoin-term term
                          (adjoin-term (make-term (1+ poly-order) 0)
                                       term-list)))
            (t (error "Trying to join existing term -- ADJOIN-TERM")))))

  ; create a term element every time the first term is pulled
  (defun first-term (term-list)
    (make-term (1- (length term-list) (car term-list))))
#+END_SRC

*** Exercise 2.90
#+BEGIN_SRC elisp
; PENDING
#+END_SRC

*** Exercise 2.91
#+BEGIN_SRC elisp
; PENDING
#+END_SRC

*** Exercise 2.92
#+BEGIN_SRC elisp
; PENDING
#+END_SRC
*** Exercise 2.93
#+BEGIN_SRC elisp
; PENDING
#+END_SRC

*** Exercise 2.94
#+BEGIN_SRC elisp
; PENDING
#+END_SRC

*** Exercise 2.95
#+BEGIN_SRC elisp
; PENDING
#+END_SRC

*** Exercise 2.96
#+BEGIN_SRC elisp
; PENDING
#+END_SRC

*** Exercise 2.97
#+BEGIN_SRC elisp
; PENDING
#+END_SRC

* Chapter 3
** 3.1.1 Local State Variables
#+BEGIN_SRC elisp
    (defun withdraw (amount)
      (if (>= balance amount)
          (progn
            (setq balance (- balance amount))
            balance)
        "Insufficient funds"))

    (defun new-withdraw ()
      (lexical-let ((balance 100))
        (lambda (amount)
          (if (>= balance amount)
              (progn
                (setq balance (- balance amount))
                balance)
            "Insufficient funds"))))

    (setq withdraw1 (new-withdraw))
    (setq withdraw2 (new-withdraw))
    (funcall withdraw1 15)
    (funcall withdraw2 20)

    (setq lexical-binding t)
    (defun make-withdraw (balance)
      (lambda (amount)
        (if (>= balance amount)
            (progn (setq balance (- balance amount))
                   balance)
          "Insufficient funds")))

    (setq W1 (make-withdraw 100))
    (setq W2 (make-withdraw 100))
    (funcall W1 50) ; => 50
    (funcall W2 70) ; => 30
    (funcall W2 40) ; => "Insufficient funds"
    (funcall W1 40) ; => 10

  (defun make-account (balance)
    (defun withdraw (amount)
      (if (>= balance amount)
          (progn (setq balance (- balance amount))
                 balance)
        "Insufficient funds"))
    (defun deposit (amount)
      (setq balance (+ balance amount))
      balance)
    (lambda (m)
      (cond ((eq m 'withdraw) (lambda (a) (withdraw a)))
            ((eq m 'deposit) (lambda (a) (deposit a)))
            (t (error "Unknown request MAKE-ACCOUNT")))))

  (setq acc (make-account 100))
  (funcall (funcall acc 'withdraw) 50) ; => 50
  (funcall (funcall acc 'withdraw) 60) ; => "Insufficient funds"
  (funcall (funcall acc 'deposit)  40) ; => 90
  (funcall (funcall acc 'withdraw) 60) ; => 30
#+END_SRC

** 3.1.2 The Benefits of Introducing Assignment
#+BEGIN_SRC elisp
    (defun rand ()
      (let ((x random-int))
        (lambda ()
          (setq x (rand-update x))
          x)))

  (defun estimate-pi (trials)
    (sqrt (/ 6 (monte-carlo trials 'cesaro-test))))

  (defun cesaro-test ()
    (= (gcd (random 1000) (random 1000)) 1))

  (defun monte-carlo (trials experiment)
    (defun iter (trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ (float trials-passed) trials))
            ((funcall experiment)
             (iter (1- trials-remaining) (1+ trials-passed)))
            (t
             (iter (1- trials-remaining) trials-passed))))
    (iter trials 0))

  (estimate-pi 250) ; => 3.1517891481565017
#+END_SRC

** 3.3.1 Mutation is just assignment
#+BEGIN_SRC elisp
  (defun my/cons (x y)
    (lambda (m)
      (cond ((eq m 'car) x)
            ((eq m 'cdr) y)
            ((eq m 'set-car!) (lambda(v) (setq x v)))
            ((eq m 'set-cdr!) (lambda(v) (setq y v)))
            (t (error "Undefined operation -- MY/CONS")))))

  (defun my/car (z) (funcall z 'car))
  (defun my/cdr (z) (funcall z 'cdr))
  (defun my/set-car! (z new-val)
    (funcall (funcall z 'set-car!) new-val)
    z)
  (defun my/set-cdr! (z new-val)
    (funcall (funcall z 'set-cdr!) new-val)
    z)

  (setq z (my/cons '(a b) 'c))
  (my/car z) ; => (a b)
  (my/cdr z) ; => c

  (my/set-cdr! z 'd)
  (my/car z) ; => (a b)
  (my/cdr z) ; => d

  (my/set-car! z 'e)
  (my/car z) ; => e
  (my/cdr z) ; => d
#+END_SRC

** 3.3.2 Representing Queues
#+BEGIN_SRC elisp
  (defun front-ptr (queue) (car queue))
  (defun rear-ptr (queue) (cdr queue))
  (defun set-front-ptr! (queue item) (setcar queue item))
  (defun set-rear-ptr! (queue item) (setcdr queue item))

  (defun empty-queue? (queue) (null (front-ptr queue)))
  (defun make-queue () (cons nil nil))
  (defun front-queue (queue)
    (if (empty-queue? queue)
        (error "FRONT called with an empty queue")
      (car (front-ptr queue))))

  (defun insert-queue! (queue item)
    (let ((new-pair (cons item nil)))
      (cond ((empty-queue? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
            (t
             (setcdr (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))

  (defun delete-queue! (queue)
    (cond ((empty-queue? queue)
           (error "DELETE! called with an empty queue"))
          (t
           (set-front-ptr! queue (cdr (front-ptr queue)))
           queue)))

  (setq p1 (make-queue))
  (insert-queue! p1 'a) ; => ((a) a)
  (insert-queue! p1 'b) ; => ((a b) b)
  (delete-queue! p1)    ; => ((b) b)
  (delete-queue! p1)    ; => (nil b)
#+END_SRC

** 3.3.3 Representing Tables
#+BEGIN_SRC elisp
  (defun table/make-table ()
    (lexical-let ((local-table (list '*table*)))
      (defun my-table/lookup (key table)
        (let ((record (my-table/assoc key (cdr table))))
          (if record
              (cdr record)
            nil)))

      (defun my-table/assoc (key records)
        (cond ((null records) nil)
              ((equal key (caar records)) (car records))
              (t (my-table/assoc key (cdr records)))))

      (defun my-table/insert! (key value table)
        (let ((record (my-table/assoc key (cdr table))))
          (if record
              (setcdr record value)
            (setcdr table (cons (cons key value) (cdr table)))))
        'ok)

      (defun my-table2D/lookup (key-1 key-2)
        (let ((subtable (my-table/assoc key-1 (cdr local-table))))
          (if subtable
              (my-table/lookup key-2 subtable)
            nil)))

      (defun my-table2D/insert! (key-1 key-2 value)
        (let ((subtable (my-table/assoc key-1 (cdr local-table))))
          (if subtable
              (my-table/insert! key-2 value subtable)
            (setcdr local-table (cons (list key-1 (cons key-2 value))
                                      (cdr local-table)))))
        'ok)
      (lambda (m)
        (cond ((eq m 'lookup-proc)
               (lambda (key-1 key-2)
                 (my-table2D/lookup key-1 key-2)))
              ((eq m 'insert-proc)
               (lambda (key-1 key-2 val)
                 (my-table2D/insert! key-1 key-2 val)))))))

  (setq p1 (table/make-table))
  (defun sicp-get (key-1 key-2)
    (funcall (funcall p1 'lookup-proc) key-1 key-2))
  (defun sicp-put (key-1 key-2 val)
    (funcall (funcall p1 'insert-proc) key-1 key-2 val))

  (sicp-put 'one 'one 11)  ; => ok
  (sicp-get 'one 'one)     ; => 11
  (sicp-put 'one 'two 12)  ; => ok
  (sicp-get 'one 'two)     ; => 12
  (sicp-put 'ten 'two 102) ; => ok
  (sicp-get 'ten 'two)     ; => 102
#+END_SRC

** 3.3.4 A Simulator for Digital Circuits
#+BEGIN_SRC elisp
  ;              +--------------------------------------+
  ;              |         ____                         |
  ;          A --------*---\   \ D               ___    |
  ;              |     |    >   >---------------|   \   |
  ;              |  +--|---/___/                |    )
----- S
  ;              |  |  |              |\  E  +--|___/   |
  ;              |  |  |           +--| >o---+          |
  ;              |  |  |    ___    |  |/                |
  ;              |  |  +---|   \   |                    |
  ;              |  |      |    )--*----------------------- C
  ;          B -----*------|___/                        |
  ;              |                                      |
  ;              +--------------------------------------+
  ;
  (let ((a (make-wire))
        (b (make-wire))
        (c (make-wire))
        (d (make-wire))
        (e (make-wire))
        (s (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s))

  ;; half adder
  (defun half-adder (a b s c)
    (let ((d (make-wire))
          (e (make-wire)))
      (or-gate a b d)
      (and-gate a b c)
      (inverter c e)
      (and-gate d e s)
      'ok))

  (defun full-adder (a b c-in sum c-out)
    (let ((s (make-wire))
          (c1 (make-wire))
          (c2 (make-sire)))
      (half-adder b c-in s c1)
      (half-adder a s sum c2)
      (or-gate c1 c2 c-out)
      'ok))

  ;; Primitive function boxes
  ; (get-signal <WIRE>)
  ; (set-signal! <WIRE> <NEW VALUE>)
  ; (add-action! <WIRE> <PROCEDURE OF NO ARGUMENTS>)

  (defun inverter (input output)
    (lexical-let* ((a input)
                   (c output)
                   (invert-input
                    (lambda ()
                      (let ((new-value (logical-not (get-signal a))))
                        (after-delay inverter-delay
                                     (lambda ()
                                       (set-signal! c new-value)))))))
      (add-action! a invert-input)
      'ok))

  (defun logical-not (s)
    (cond ((= s 0) 1)
          ((= s 1) 0)
          (t (error "Invalid signal -- LOGICAL-NOT"))))

  (defun and-gate (a1 a2 output)
    (lexical-let* ((a a1)
                   (b a2)
                   (c output)
                   (and-action-procedure
                    (lambda ()
                      (let ((new-value
                             (logical-and (get-signal a)
                                          (get-signal b))))
                        (after-delay and-gate-delay
                                     (lambda ()
                                       (set-signal! c new-value)))))))
      (add-action! a and-action-procedure)
      (add-action! b and-action-procedure)
      'ok))

  (defun logical-and (a b)
    (if (and (is-logic a) (is-logic b))
        (if (and (= a 1) (= b 1))
            1
          0)
      (error "Invalid signal -- LOGICAL-AND")))

  (defun or-gate (a1 a2 output)
    (lexical-let* ((a a1)
                  (b a2)
                  (c output)
                  (or-action-procedure
                   (lambda ()
                     (let ((new-value
                            (logical-or (get-signal a) (get-signal b))))
                       (after-delay or-gate-delay
                                    (lambda ()
                                      (set-signal! c new-value)))))))
      (add-action! a or-action-procedure)
      (add-action! b or-action-procedure)
      'ok))

  (defun logical-or (a b)
    (if (and (is-logic a) (is-logic b))
        (if (or (= a 1) (= b 1))
            1
          0)
      (error "Invalid signal. -- LOGICAL-OR")))

  (defun is-logic (a) (or (= a 0) (= a 1)))

  (defun make-wire ()
    (lexical-let ((signal-value 0)
                  (action-procedures nil))
      (lambda (m)
        (cond ((eq m 'get-signal) signal-value)
              ((eq m 'set-signal)
               (lambda (new-value)
                 (if (not (= signal-value new-value))
                     (progn (setq signal-value new-value)
                            (call-each action-procedures))
                   'done)))
              ((eq m 'add-action)
               (lambda (proc)
                 (setq action-procedures (cons proc action-procedures))
                 (funcall proc)))
              (t (error "Unknown operation -- WIRE"))))))


  (defun call-each (procedures)
    (if (null procedures)
        'done
      (funcall (car procedures))
      (call-each (cdr procedures))))

  (defun get-signal (wire)
    (funcall wire 'get-signal))

  (defun set-signal! (wire new-value)
    (funcall (funcall wire 'set-signal) new-value))

  (defun add-action! (wire action-procedure)
    (funcall (funcall wire 'add-action) action-procedure))

  ; Implementation of the agenda
  (defun after-delay (delay action)
    (add-to-agenda! (+ delay (agenda-current-time the-agenda))
                    action
                    the-agenda))

  (defun propagate ()
    (if (empty-agenda? the-agenda)
        'done
      (let ((first-item (first-agenda-item the-agenda)))
        (funcall first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))

  (defun make-time-segment (time queue)
    (cons time queue))
  (defun segment-time (s) (car s))
  (defun segment-queue (s) (cdr s))

  (defun make-agenda () (list 0))
  (defun agend a-current-time (agenda) (car agenda))
  (defun set-current-time! (agenda time)
    (setcar agenda time))
  (defun segments (agenda) (cdr agenda))
  (defun set-segments! (agenda segments)
    (setcdr agenda segments))
  (defun first-segment (agenda) (car (segments agenda)))
  (defun rest-segments (agenda) (cdr (segments agenda)))
  (defun empty-agenda? (agenda) (null (segments agenda)))

  (defun add-to-agenda! (time action agenda)
    (defun belongs-before? (segments)
      (or (null segments)
          (< time (segment-time (car segments)))))
    (defun make-new-time-segment (time action)
      (lexical-let ((q (make-queue)))
        (insert-queue! q action)
        (make-time-segment time q)))
    (defun add-to-segments! (segments)
      (if (= (segment-time (car segments)) time)
          (insert-queue! (segment-queue (car segments))
                         action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (setcdr
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
            (add-to-segments! rest)))))
    (let ((segments (segments agenda)))
      (if (belongs-before? segments)
          (set-segments!
           agenda
           (cons (make-new-time-segment time action)
                 segments))
        (add-to-segments! segments))))

  (defun remove-first-agenda-item! (agenda)
    (let ((q (segment-queue (first-segment agenda))))
      (delete-queue! q)
      (if (empty-queue? q)
          (set-segments! agenda (rest-segments agenda)))))

  (defun first-agenda-item (agenda)
    (if (empty-queue? agenda)
        (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))

  ; Sample simulation
  (defun probe (name wire)
    (lexical-let ((nam name)
                  (wir wire))
      (add-action! wire
                   (lambda ()
                     (insert (format "%s %s New-value = %s\n"
                                     nam
                                     (agenda-current-time the-agenda)
                                     (get-signal wir)))))))
  ; Begin of simulation example
  (setq inverter-delay 2)
  (setq and-gate-delay 3)
  (setq or-gate-delay 5)

  (setq the-agenda (make-agenda))
  (setq input-1 (make-wire))
  (setq input-2 (make-wire))
  (setq sum (make-wire))
  (setq carry (make-wire))

  (probe 'sum sum) ; => sum 0 New-value = 0
  (probe 'carry carry); => carry 0 New-value = 0
  (half-adder input-1 input-2 sum carry) ; => ok

  (set-signal! input-1 1) ; => done
  (propagate) ; => sum 8 New-value = 1

  (set-signal! input-2 1) ; => done
  (propagate) ; => carry 11 New-value = 1  sum 16 New-value = 0
#+END_SRC

** 3.3.5 Propagation of Constraints
#+BEGIN_SRC elisp
  ; Using the constraint system by implementing 9C = 5(F-32)
  (setq C (make-connector))
  (setq F (make-connector))
  (celsius-fahrenheit-converter C F) ; => ok

  (defun celsius-fahrenheit-converter (c f)
    (lexical-let ((u (make-connector))
                  (v (make-connector))
                  (w (make-connector))
                  (x (make-connector))
                  (y (make-connector)))
      (multiplier c w u)
      (multiplier v x u)
      (adder v y f)
      (constant 9 w)
      (constant 5 x)
      (constant 32 y)
      'ok))

  (probe "Celsius: " C)
  (probe "Fahrenheit: " F)

  (set-value! C 25 'user)
   ; => Probe: Celsius:  = 25
   ; => Probe: Fahrenheit:  = 77

  (set-value! F 212 'user)  ; ERROR: Contradiction

  (forget-value! C 'user)
   ; => Probe: Celsius:  = ?
   ; => Probe: Fahrenheit:  = ?

  (set-value! F 212 'user)
   ; => Probe: Fahrenheit:  = 212
   ; => Probe: Celsius:  = 100

  ; Implementing the constraint propagation system
  (defun adder (a1 a2 sum)
    (lexical-let
        ((a a1)
         (b a2)
         (c sum)
         (me nil)
         (process-new-value nil)
         (process-forget-value nil))

      ; procedure definition
      (setq me
            (lambda (request)
              (cond ((eq request 'I-have-a-value)
                     (funcall process-new-value))
                    ((eq request 'I-lost-my-value)
                     (funcall process-forget-value))
                    (t (error "Unknown request -- ADDER" request)))))

      (setq process-new-value
            (lambda ()
              (cond ((and (has-value? a) (has-value? b))
                     (set-value! c
                                 (+ (get-value a) (get-value b))
                                 me))
                    ((and (has-value? a) (has-value? c))
                     (set-value! b
                                 (- (get-value c) (get-value a))
                                 me))
                    ((and (has-value? b) (has-value? c))
                     (set-value! a
                                 (- (get-value c) (get-value b))
                                 me)))))

      (setq process-forget-value
            (lambda ()
              (forget-value! c me)
              (forget-value! a me)
              (forget-value! b me)
              (funcall process-new-value)))

      (connect a me)
      (connect b me)
      (connect c me)
      me))

  (defun multiplier (m1 m2 product)
    (lexical-let ((a m1)
                  (b m2)
                  (c product)
                  (process-new-value nil)
                  (process-forget-value nil)
                  (me nil))

      ; function definitions
      (setq me
            (lambda (request)
              (cond ((eq request 'I-have-a-value)
                     (funcall process-new-value))
                    ((eq request 'I-lost-my-value)
                     (funcall process-forget-value))
                    (t (error "Unknown request -- MULTIPLIER")))))

      (setq process-new-value
            (lambda ()
              (cond ((or (and (has-value? a) (= (get-value a) 0))
                         (and (has-value? b) (= (get-value b) 0)))
                     (set-value! c 0 me))
                    ((and (has-value? a) (has-value? b))
                     (set-value! c
                                 (* (get-value a) (get-value b))
                                 me))
                    ((and (has-value? c) (has-value? a))
                     (set-value! b
                                 (/ (get-value c) (get-value a))
                                 me))
                    ((and (has-value? c) (has-value? b))
                     (set-value! a
                                 (/ (get-value c) (get-value b))
                                 me)))))

      (setq process-forget-value
            (lambda ()
              (forget-value! c me)
              (forget-value! a me)
              (forget-value! b me)
              (funcall process-new-value)))

      (connect a me)
      (connect b me)
      (connect c me)
      me))

  (defun constant (value connector)
    (lexical-let
        ((a value)
         (b connector)
         (me nil))

      ; procedure definition
      (setq me
            (lambda (request)
              (error "Unknown request -- CONSTANT")))

      (connect connector me)
      (set-value! connector value me)
      me))

  (defun inform-about-value (constraint)
    (funcall constraint 'I-have-a-value))

  (defun inform-about-no-value (constraint)
    (funcall constraint 'I-lost-my-value))

  (defun probe (name connector)
    (lexical-let ((n name)
                  (c connector)
                  (print-probe nil)
                  (process-new-value nil)
                  (process-forget-value nil)
                  (me nil))

      ; Procedure definition
      (setq print-probe
            (lambda (value)
              (insert (format "\nProbe: %s = %s" n value))))

      (setq process-new-value
            (lambda ()
              (funcall print-probe (get-value c))))

      (setq process-forget-value
            (lambda ()
              (funcall print-probe "?")))

      (setq me
            (lambda (request)
              (cond ((eq request 'I-have-a-value)
                     (funcall process-new-value))
                    ((eq request 'I-lost-my-value)
                     (funcall process-forget-value))
                    (t
                     (error "Unknow request -- PROBE")))))
      (connect c me)
      me))

  ; Connector representation
  (defun make-connector ()
    (lexical-let ((value nil)
                  (informant nil)
                  (constraints nil)
                  (set-my-value nil)
                  (forget-my-value nil)
                  (connect nil)
                  (me nil))
      ; Procedure definition
      (setq set-my-value
            (lambda (newval setter)
              (cond ((not (has-value? me))
                     (setq value newval)
                     (setq informant setter)
                     (for-each-except setter
                                      'inform-about-value
                                      constraints))
                    ((not (= value newval))
                     (insert (format "Error: Contradiction %s\n" (list value newval))))
                    (t 'ignored))))

      (setq forget-my-value
            (lambda (retractor)
              (if (eq retractor informant)
                  (progn (setq informant nil)
                         (for-each-except retractor
                                          'inform-about-no-value
                                          constraints))
                'ignored)))

      (setq connect
            (lambda (new-constraint)
              (if (not (memq new-constraint constraints))
                  (setq constraints
                        (cons new-constraint constraints)))
              (if (has-value? me)
                  (inform-about-value new-constraint))
              'done))

      (setq me
            (lambda (request)
              (cond ((eq request 'has-value?)
                     (if informant t nil))
                    ((eq request 'value) value)
                    ((eq request 'set-value!) set-my-value)
                    ((eq request 'forget) forget-my-value)
                    ((eq request 'connect) connect)
                    (t (error "Unknown operation -- CONNECTOR")))))
      me))

  (defun for-each-except (exception procedure list)
    (defun my-loop (items)
      (cond ((null items) 'done)
            ((eq (car items) exception) (my-loop (cdr items)))
            (t (funcall procedure (car items))
               (my-loop (cdr items)))))
    (my-loop list))

  (defun has-value? (connector)
    (funcall connector 'has-value?))

  (defun get-value (connector)
    (funcall connector 'value))

  (defun set-value! (connector new-value informant)
    (funcall (funcall connector 'set-value!) new-value informant))

  (defun forget-value! (connector retractor)
    (funcall (funcall connector 'forget) retractor))

  (defun connect (connector new-constraint)
    (funcall (funcall connector 'connect) new-constraint))
#+END_SRC

** 3.4.2 Implementing serializers
#+BEGIN_SRC elisp
  (defun make-serializer ()
    (lexical-let ((mutex (make-mutex))
                  (serialized-p nil))
      (lambda (p)
        (setq serialized-p
              (lambda (&optional args)
                (mutex 'acquire)
                (let ((val (apply p args)))
                  (mutex 'release)
                  val)))
        serialized-p)))

  (defun make-mutex ()
    (lexical-let ((cell (list nil))
                  (the-mutex nil))
      (setq the-mutex
            (lambda (m)
              (cond ((eq m 'acquire)
                     (if (test-and-set! cell)
                         (funcall the-mutex 'acquire)))
                    ((eq m 'release) (clear! cell)))))
      the-mutex))

  (defun clear! (cell)
    (setcar cell nil))

  (defun test-and-set (cell)
    (if (car cell)
        t
      (progn (setcar cell t)
             nil)))
#+END_SRC

** 3.5 Streams
#+BEGIN_SRC elisp
  ; This is the core for streams structures
  (setq the-empty-stream nil)
  (defun stream-null? (s) (eq s the-empty-stream))
  (defun sicp-delay (exp) (memo-proc (lambda () exp)))
  (defun sicp-force (exp) (funcall exp))

  ; for now use cons-stream as the most basic procedure
  ; to generate streams, deferring the task to add the
  ; lambda of the cdr to the user
  (defun cons-stream (a b) (cons a (memo-proc b)))
  (defun stream-car (stream) (car stream))
  (defun stream-cdr (stream) (sicp-force (cdr stream)))

  ; Memoize a procedure, do don't we evaluate
  ; the same procedure when calling `stream-cdr'
  (defun memo-proc (proc)
    (lexical-let ((already-run? nil)
                  (result nil))
      (lambda ()
        (if (not already-run?)
            (progn (setq result (funcall proc))
                   (setq already-run? t)))
        result)))

  ; create a stream based on an existing list
  (defun  make-stream (list)
    "Create a stream from list"
    (lexical-let ((l list))
      (if (stream-null? l)
          the-empty-stream
        (cons-stream
         (car l)
         (lambda () (make-stream (cdr l)))))))

  (defun stream-enumerate-interval (low high)
    (lexical-let ((l low)
                  (h high))
      (if (> l h)
          the-empty-stream
        (cons-stream low
                     (lambda ()
                       (stream-enumerate-interval (1+ l) h))))))

  (defun stream-ref (s n)
    "Return the Nth element of Stream being 0 the
  first element"
    (if (= n 0)
        (stream-car s)
      (stream-ref (stream-cdr s) (1- n))))

  (defun stream-map (proc stream)
    (lexical-let ((p proc)
                  (s stream))
      (if (stream-null? stream)
          the-empty-stream
        (cons-stream (funcall p (stream-car s))
                     (lambda ()

  (defun stream-for-each (proc s)
    "Evaluate PROC for every element in stream S"
    (if (stream-null? s)
        'done
      (funcall proc (stream-car s))
      (stream-for-each proc (stream-cdr s))))

  (defun stream-filter (pred stream)
    (cond ((stream-null? stream) the-empty-stream)
          ((funcall pred (stream-car stream))
           (cons-stream (stream-car stream)
                        (lambda ()
                          (stream-filter pred (stream-cdr stream)))))
          (t
           (stream-filter pred (stream-cdr stream)))))

  (defun display-stream (stream)
    (stream-for-each (lambda (x) (insert (format "%d " x)))
                     stream))

  ;; Another way to implement using macros for `cons-stream' and `delay'
  (setq the-empty-stream nil)
  (defun stream-null? (s) (eq s the-empty-stream))
  (defmacro my/delay (exp) (list 'my/memo-proc `(lambda () ,exp)))
  (defmacro my/cons-stream (a b) (list 'cons a `(my/delay ,b)))
  (defun my/stream-car (stream) (car stream))
  (defun my/stream-cdr (stream) (my/sicp-force (cdr stream)))
  (defun my/sicp-force (exp) (funcall exp))

  (defun my/memo-proc (proc)
    (lexical-let ((already-run? nil)
                  (result nil)
                  (p proc))
      (lambda ()
        (if (not already-run?)
            (progn (setq result (funcall p))
                   (setq already-run? t)))
        result)))

  ; create a stream based on an existing list
  (defun  my/make-stream (list)
    "Create a stream from list"
    (lexical-let ((l list))
      (if (stream-null? l)
          the-empty-stream
        (my/cons-stream
         (car l)
         (my/make-stream (cdr l))))))

  (defun my/stream-enumerate-interval (low high)
    (lexical-let ((l low)
                  (h high))
      (if (> l h)
          the-empty-stream
        (my/cons-stream low
                        (my/stream-enumerate-interval (1+ l) h)))))

  (defun my/stream-ref (s n)
    "Return the Nth element of Stream being 0 the
  first element"
    (if (= n 0)
        (my/stream-car s)
      (my/stream-ref (my/stream-cdr s) (1- n))))

  (defun my/stream-map (proc stream)
    (lexical-let ((p proc)
                  (s stream))
      (if (stream-null? stream)
          the-empty-stream
        (my/cons-stream (funcall p (my/stream-car s))
                        (my/stream-map p (my/stream-cdr s))))))

  ;; Using second (generalized) implementation of streams
  (defun my/stream-map-g (proc &optional argstreams)
    (lexical-let ((p proc)
                  (a argstreams))
      (if (null (car a))
          the-empty-stream
        (my/cons-stream (apply p (mapcar 'car a))
                        (my/stream-map-g p (mapcar 'my/stream-cdr a))))))

  (defun my/stream-for-each (proc s)
    "Evaluate PROC for every element in stream S"
    (if (stream-null? s)
        'done
      (funcall proc (my/stream-car s))
      (my/stream-for-each proc (my/stream-cdr s))))

  (defun my/stream-filter (predicate s)
    (lexical-let  ((pred predicate)
                   (stream s))
      (cond ((stream-null? stream) the-empty-stream)
            ((funcall pred (my/stream-car stream))
             (my/cons-stream (my/stream-car stream)
                             (my/stream-filter pred (my/stream-cdr stream))))
            (t
             (my/stream-filter pred (my/stream-cdr stream))))))

  (defun my/display-stream (stream)
    (my/stream-for-each (lambda (x) (insert (format "%d " x)))
                        stream))
  (defun my/first-n-elements (stream n)
    (defun iter (i)
      (cond ((>= i n) the-empty-stream)
            (t (cons (my/stream-ref stream i)
                     (iter (1+ i))))))
    (iter 0))
#+END_SRC

*** Infinite streams
#+BEGIN_SRC elisp
  (defun my/integers-starting-from (number)
    (lexical-let ((n number))
      (my/cons-stream n (my/integers-starting-from (1+ n)))))

  (setq my/integers (my/integers-starting-from 1))

  (defun divisible? (x y) (= (% x y) 0))
  (setq no-seven-divisibles
    (my/stream-filter (lambda (x) (not (divisible? x 7)))
                      my/integers))

  (my/stream-ref no-seven-divisibles 100)    ; => 117

  (defun fibgen (x y)
    (lexical-let ((a x)
                  (b y))
      (my/cons-stream a (fibgen b (+ a b)))))

  (setq fibs (fibgen 0 1))
  (my/stream-ref fibs 10)  ; => 55

  (defun sieve (s)
    (lexical-let ((stream s))
      (my/cons-stream
        (my/stream-car stream)
        (sieve (my/stream-filter
                 (lambda (x)
                   (not (divisible? x (my/stream-car stream))))
                 (my/stream-cdr stream))))))

  (setq primes (sieve (my/integers-starting-from 2)))
  (my/stream-ref primes 10) ; => 31
#+END_SRC
*** Defining streams implicitly
#+BEGIN_SRC elisp
  (setq my/ones (my/cons-stream 1 my/ones))

  (defun my/add-streams (s1 s2)
    (my/stream-map-g '+ (list s1 s2)))

  (setq my/integers (my/cons-stream 1 (my/add-streams my/ones my/integers)))

  (setq fibs
    (my/cons-stream 0
                    (my/cons-stream 1
                                    (my/add-streams (my/stream-cdr fibs)
                                                    fibs))))
  (my/stream-ref fibs 10) ; => 55

  ; use the generic version of the `my/stream-map'
  (defun my/scale-stream (stream factor)
    (lexical-let ((f factor))
      (my/stream-map-g (lambda (x) (* x f)) (list stream))))

  (setq my/double (my/cons-stream 1 (my/scale-stream my/double 2)))


  (setq my/primes
    (my/cons-stream
      2
      (my/stream-filter 'prime? (my/integers-starting-from 3))))

  (defun prime? (n)
    (defun square (x) (* x x))
    (defun divisible? (x y) (= 0 (% x y)))
    (defun iter (ps)
      (cond ((> (square (my/stream-car ps)) n) t)
            ((divisible? n (my/stream-car ps)) nil)
            (t (iter (my/stream-cdr ps)))))
    (iter my/primes))

  (my/stream-ref my/primes 20) ; => 73
#+END_SRC

** 3.5.3 Exploiting the Stream Paradigm
#+BEGIN_SRC elisp
  (defun my/average (a b &rest c)
    (let ((input (if (null c)
                     (list a b)
                   (append (list a b) c))))
      (/ (reduce '+ input :initial-value 0.0) (length input))))

  (defun my/sqrt-improve (guess x)
    (my/average guess (/ x guess)))

  (defun my/sqrt-stream (num)
    (lexical-let ((x num))
      (setq my/guesses
            (my/cons-stream 1.0
                            (my/stream-map (lambda (guess)
                                             (my/sqrt-improve guess x))
                                           (list my/guesses))))
      my/guesses))

  (my/stream-ref (my/sqrt-stream 2) 4) ; => 1.4142135623746899

  (defun my/pi-summands (num)
    (lexical-let ((n num))
      (my/cons-stream (/ 1.0 n)
                      (my/stream-map '- (list (my/pi-summands (+ n 2)))))))

  (setq my/pi-stream
    (my/scale-stream (my/partial-sums (my/pi-summands 1)) 4))

  (my/stream-ref my/pi-stream 7) ; => 3.017071817071818

  (defun my/euler-transform (stream)
    (lexical-let ((s stream))
      (let ((s0 (my/stream-ref s 0))
            (s1 (my/stream-ref s 1))
            (s2 (my/stream-ref s 2)))
        (my/cons-stream (- s2 (/ (square (- s2 s1))
                                 (+ s0 (* -2 s1) s2)))
                        (my/euler-transform (my/stream-cdr s))))))

  (my/stream-ref (my/euler-transform my/pi-stream) 7) ; => 3.1412548236077655

  (defun my/make-tableau (transform stream)
    (lexical-let ((s stream)
                  (t transform))
      (my/cons-stream s
                      (my/make-tableau t (funcall t s)))))

  (defun my/accelerated-sequence (transform stream)
    (my/stream-map 'my/stream-car
                   (list (my/make-tableau transform stream))))

  (my/stream-ref
    (my/accelerated-sequence 'my/euler-transform my/pi-stream)
    7) ; => 3.141592653589778
#+END_SRC
*** Infinite streams of pairs
#+BEGIN_SRC elisp
    (defun pairs (s1 s2)
      (lexical-let ((S s1)
                    (T s2))
        (my/cons-stream
         (list (my/stream-car S) (my/stream-car T))
         (my/interleave
          (my/stream-map (lambda (x) (list (my/stream-car S) x))
                         (my/stream-cdr T))
          (pairs (my/stream-cdr S) (my/stream-cdr T))))))

    (defun my/stream-append (str1 str2)
      (if (stream-null? s1)
          s2
        (my/cons-stream (my/stream-car s1)
                        (my/stream-append (my/stream-cdr s1) s2))))

  ; using stream-append as the glue
  (my/stream-ref (pairs my/integers my/integers) 100) ; => (1 101)

  (defun my/interleave (str1 str2)
    (lexical-let ((s1 str1)
                  (s2 str2))
      (if (stream-null? s1)
          s2
        (my/cons-stream (my/stream-car s1)
                        (my/interleave s2 (my/stream-cdr s1))))))

  ; using interleave as the glue
  (my/stream-ref (pairs my/integers my/integers) 166) ; => (4 14)
#+END_SRC
*** Streams as signals
#+BEGIN_SRC elisp
  (defun my/integral (integrand initial-value dt)
    (lexical-let* ((integ integrand)
                   (init-v initial-value)
                   (increment dt)
                   (int nil))
      (setq int
            (my/cons-stream init-v
                            (my/add-streams (my/scale-stream integ increment)
                                            int)))
      int))

  (setq my/S (my/integral my/integers 0.0 0.5))
  (my/stream-ref my/S 3)
#+END_SRC

** 3.5.4 Streams and Delayed Evaluation
#+BEGIN_SRC elisp
  (defun my/integral2 (delayed-integrand initial-value dt)
    (lexical-let ((d-i delayed-integrand)
                  (i-v initial-value)
                  (d-t dt)
                  (int nil))
      (setq int
            (my/cons-stream i-v
                         (let ((integrand (my/sicp-force d-i)))
                           (my/add-streams (my/scale-stream integrand d-t)
                                           int))))
      int))

  (defun my/solve (F Y0 Dt)
    (lexical-let ((f F)
                  (y0 Y0)
                  (dt Dt)
                  (y nil)
                  (dy nil))
      (setq y (my/integral2 (my/delay dy) y0 dt))
      (setq dy (my/stream-map f y))
      y))

  (my/stream-ref (my/solve (lambda (y) y) 1 0.001) 1000) ; => 2.716923932235896
#+END_SRC

** 3.5.5 Modularity of Functional Programs and Modularity of Objects
#+BEGIN_SRC elisp
  (setq my/random-numbers
        (my/cons-stream (random 1000)
                        (my/stream-map 'random my/random-numbers)))

  (defun my/map-successive-pairs (f s)
    (my/cons-stream
     (funcall f (my/stream-car s) (my/stream-car (my/stream-cdr s)))
     (my/map-successive-pairs f (my/stream-cdr (my/stream-cdr s)))))

  (setq my/cesaro-stream
        (my/map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))
                                 my/random-numbers))

  (defun monte-carlo (experiment-stream passed failed)
    (defun next (passed failed)
      (my/cons-stream
       (/ (float passed) (+ passed failed))
       (monte-carlo
        (my/stream-cdr experiment-stream) passed failed)))
    (if (my/stream-car experiment-stream)
        (next (1+ passed) failed)
      (next passed (1+ failed))))

  (setq my/pi
        (my/stream-map (lambda (p) (sqrt (/ 6 p)))
                       (monte-carlo my/cesaro-stream 0 0)))

  (my/stream-ref my/pi 2000) ; => 3.255249003129289
#+END_SRC

** Exercises
*** Exercise 3.1
#+BEGIN_SRC elisp
  (defun make-accumulator (initial)
    (lexical-let ((acc initial))
      (lambda (x)
        (setq acc (+ acc x))
        acc)))

  ; This version requires enabling `lexical-binding'
  ; (setq lexical-binding t)
  (defun make-accumulator (acc)
    (lambda (x)
      (setq acc (+ acc x))
      acc))

  (setq A (make-accumulator 5))
  (funcall A 10) ; => 15
  (funcall A 10) ; => 25
#+END_SRC

*** Exercise 3.2
#+BEGIN_SRC elisp
  (defun make-monitored (f)
    (lexical-let ((counter 0))
      (lambda (msg)
        (cond ((eq msg 'how-many-calls?) counter)
              ((eq msg 'reset-count) (setq counter 0))
              (t
               (progn (funcall f msg)
                      (setq counter (1+ counter))))))))

  (setq s (make-monitored 'sqrt))
  (funcall s 100)
  (funcall s 'how-many-calls?)
  (funcall s 'reset-count)
#+END_SRC

*** Exercise 3.3
#+BEGIN_SRC elisp
  (defun make-account (balance passwd)
    (defun withdraw (amount)
      (if (>= balance amount)
          (progn (setq balance (- balance amount))
                 balance)
        "Insufficient funds"))
    (defun deposit (amount)
      (setq balance (+ balance amount))
      balance)
    (lambda (p m)
      (if (eq p passwd)
          (cond ((eq m 'withdraw) (lambda (a) (withdraw a)))
                ((eq m 'deposit) (lambda (a) (deposit a)))
                (t (error "Unknown request MAKE-ACCOUNT")))
        (lambda (a) "Incorrect password"))))

  (setq acc (make-account 100 'secret-password))
  (funcall (funcall acc 'secret-password 'withdraw) 50) ; => 50
  (funcall (funcall acc 'secret-password 'withdraw) 60) ; => "Insufficient funds"
  (funcall (funcall acc 'secret-password 'deposit)  40) ; => 90
  (funcall (funcall acc 'wrong-password 'withdraw) 60)  ; => "Incorrect password"
#+END_SRC

*** Exercise 3.4
#+BEGIN_SRC elisp
  (defun make-account (balance passwd)
    (defun withdraw (amount)
      (if (>= balance amount)
          (progn (setq balance (- balance amount))
                 balance)
        "Insufficient funds"))
    (defun deposit (amount)
      (setq balance (+ balance amount))
      balance)
    (defun call-the-cops () "Calling the police.")
    (lexical-let ((attempts 0))
      (lambda (p m)
        (if (eq p passwd)
            (progn
              (setq attempts 0)
              (cond ((eq m 'withdraw) (lambda (a) (withdraw a)))
                    ((eq m 'deposit) (lambda (a) (deposit a)))
                    (t (error "Unknown request MAKE-ACCOUNT"))))
          (lambda (a)
            (setq attempts (1+ attempts))
            (if (>= attempts 7)
                (call-the-cops)
              "Incorrect password"))))))

    (setq acc (make-account 100 'secret-password))
    (funcall (funcall acc 'wrong-password 'withdraw) 60)  ; => "Calling the police."
#+END_SRC
*** Exercise 3.5
#+BEGIN_SRC elisp
  (defun monte-carlo (trials experiment)
    (defun iter (trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ (float trials-passed) trials))
            ((funcall experiment)
             (iter (1- trials-remaining) (1+ trials-passed)))
            (t
             (iter (1- trials-remaining) trials-passed))))
    (iter trials 0))

(defun estimate-integral (predicate x1 x2 y1 y2 trials)
  (defun enclosing-area () (* (- x2 x1) (- y2 y1)))
  (defun random-in-range (n1 n2)
    (+ n1 (random (- n2 n1))))
  (defun experiment ()
    (funcall predicate (random-in-range x1 x2)
                       (random-in-range y1 y2)))
  (* (enclosing-area) (monte-carlo trials 'experiment)))

  (defun lays-in-circle-p (x y)
    (defun square (n) (* n n))
      (<= (+ (square (- x 5)) (square (- y 7))) (square 3)))

  ; expected area (* pi (square 3)) ; => 28.274333882308138
  (estimate-integral 'lays-in-circle-p 2 8 4 10 200)  ; => 28.8

  ; estimate pi with the same circle area estimation
  (/ (estimate-integral 'lays-in-circle-p 2 8 4 10 200) (square 3)) ; => 3.26
#+END_SRC

*** Exercise 3.6
#+BEGIN_SRC elisp
    (defun rand (arg)
      (cond ((eq arg 'reset)
             (lambda (init) (setq x init) x))
            ((eq arg 'generate)
             (lambda () (setq x (rand-update x)) x))
            (t (error "Unknown argument -- RAND"))))
#+END_SRC
*** Exercise 3.7
#+BEGIN_SRC elisp
  (defun make-account (balance passwd)
    (defun withdraw (amount)
      (if (>= balance amount)
          (progn (setq balance (- balance amount))
                 balance)
        "Insufficient funds"))
    (defun deposit (amount)
      (setq balance (+ balance amount))
      balance)
    (lexical-let ((passwd-list (list passwd)))
      (lambda (p m)
        (if (memq p passwd-list)
            (cond ((eq m 'withdraw) (lambda (a) (withdraw a)))
                  ((eq m 'deposit) (lambda (a) (deposit a)))
                  ((eq m 'joint)
                   (lambda (a)
                     (setq passwd-list (append (list a) passwd-list))))
                  (t (error "Unknown request MAKE-ACCOUNT")))
          (lambda (a) "Incorrect password")))))

  (defun make-joint (account orig-passwd joint-passwd)
    (funcall (funcall account orig-passwd 'joint) joint-passwd)
    account)

  (setq peter-acc (make-account 100 'peter-password))
  (setq paul-acc (make-joint peter-acc 'peter-password 'paul-password))

  (funcall (funcall paul-acc 'paul-password 'withdraw) 20) ; => 80
  (funcall (funcall peter-acc 'peter-password 'deposit) 5) ; => 85
  (funcall (funcall paul-acc 'wrong-password 'withdraw) 6) ; => "Incorrect password"
#+END_SRC

*** Exercise 3.8
#+BEGIN_SRC elisp
  (defun sicp-f ()
    (lexical-let ((state nil)
                  (prev-state nil))
      (lambda (arg)
        (setq prev-state state)
        (setq state arg)
        (* state (or prev-state state)))))

  (setq my-f (sicp-f))

  (+ (funcall my-f 0) (funcall my-f 1)) ; => 0
  (+ (funcall my-f 1) (funcall my-f 0)) ; => 1
#+END_SRC

*** Exercise 3.9
#+BEGIN_SRC elisp
; Recursive version (Will illustrate n = 4 instead of n = 6)
;                     +-----------------------------------------------------+
;           global -->|                                                     |
;           env       +-----------------------------------------------------+
;                       ^              ^                ^               ^
;   (factorial 4)       |              |                |               |
;                   +------+       +-------+        +------+        +-------+
;             E1 -->| n: 4 |  E2 ->| n: 3  |  E3 -->| n: 2 |  E4 -->| n: 1  |
;                   |      |       |       |        |      |        |       |
;                   +------+       +-------+        +------+        +-------+
;             (* 4              (* 3              (* 2              1
;                (factorial 3))    (factorial 2))   (factorial 1))

; Iterative version (Will illustrate n = 3)
;                     +--------------------------------------------------------------------+
;           global -->|                                                                    |
;           env       +--------------------------------------------------------------------+
;                       ^              ^                ^               ^                ^
;   (factorial 4)       |              |                |               |                |
;                   +------+       +-------+        +------+        +-------+        +-------+
;             E1 -->| n: 3 |  E2 ->| p: 1  |  E3 -->| p: 1 |  E4 -->| p: 2  |  E5 -->| p: 6  |
;                   |      |       | c: 1  |        | c: 2 |        | c: 3  |        | c: 4  |
;                   |      |       | m: 3  |        | m: 3 |        | m: 3  |        | m: 3  |
;                   +------+       +-------+        +------+        +-------+        +-------+
;             (fact-iter 1 1 3)   (fact-iter       (fact-iter      (fact-iter        6
;                                   (* 1 1)          (* 2 1)         (* 3 2)
;                                   (+ 1 1)          (+ 2 1)         (+ 3 1)
;                                   3)               3)              3)
#+END_SRC

*** Exercise 3.10
#+BEGIN_SRC elisp
  (defun make-withdraw (initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (progn (setq balance (- balance amount))
                   balance)
          "Insufficient funds"))))

  (funcall (make-withdraw 100) 75) ; => 25

  ;; Replacing the previous expression with
  ;; its actual representation
  (defun make-withdraw (initial-amount)
    (funcall (lambda (balance)
               (lambda (amount)
                 (if (>= balance amount)
                     (progn
                       (setq balance (- balance amount))
                       balance)
                   "Insufficient funds")))
             initial-amount))

  (funcall (make-withdraw 100) 75) ; => 25

  ; 1. (defvar W1 (make-withdraw 100))
  ;
  ;                     +------------------------------------------------------------------------------+
  ;                     | make-withdraw: -----------------------+                                      |
  ;           global -->|                                       |                                      |
  ;                     | W1: --+                               |                                      |
  ;                     +-------|-------------------------------|--------------------------------------+
  ;                             |                ^              |     ^                         ^
  ;                             |                |              V     |  (make-withdraw 100)    |
  ;                             |        +-------+------+   .---.---. |           +-------+-------------+
  ;                             |  E2 -->| balance: 100 |   | O | O-+-+     E1 -->| initial-amount: 100 |
  ;                             |        +--------------+   `-|-^---'             +---------------------+
  ;                             V                ^            |
  ;                         .---.---.            |            V
  ;                       +-+-O | O-+------------+            parameters: initial-amount
  ;                       | `---^---'                         body: (funcall (lambda (balance)
  ;                       V                                            (lambda (amount)
  ;               parameters: amount                                     (if (>= balance amount)
  ;               body: (if (>= balance amount)                            (progn
  ;                         (progn                                           (setq balance (- balance amount))
  ;                           (set! balance (- balance amount))              balance)
  ;                           balance)                                     "Insufficient funds"))
  ;                         "Insufficient funds")                       initial-amount))
  ;

  ; 2. (funcall W1 50)
  ;
  ;                    +---------------------------------------------------+
  ;                    | make-withdraw: ...                                |
  ;          global -->|                                                   |
  ;          env       | W1: --+                                           |
  ;                    +-------|-------------------------------------------+
  ;                            |               ^
  ;                            |               |
  ;                            |       +-------+------+ Here is the balance
  ;                            | E1 -->| balance: 100 | that will be changed
  ;                            |       +--------------+ by the set!.
  ;                            V               ^   ^
  ;                        .---.---.           |   +----+
  ;                        | O | O-+-----------+        |
  ;                        `-|-^---'             +------+-----+
  ;                          |                   | amount: 50 |
  ;                          V                   +------------+
  ;                parameters: amount   (if (>= balance amount)
  ;                body: ...                (begin (set! balance
  ;                                                      (- balance amount))
  ;                                                balance)
  ;                                         "Insufficient funds")
  ;
  ; 3. (defvar W2 (make-withdraw 100))
  ;
  ;                    +------------------------------------------------------------------------------+
  ;                    | make-withdraw: -----------------------+                                      |
  ;          global -->|                                       |                                      |
  ;                    | W2: --+                               |                                      |
  ;                    +-------|-------------------------------|--------------------------------------+
  ;                            |                ^              |     ^                         ^
  ;                            |                |              V     |  (make-withdraw 100)    |
  ;                            |        +-------+------+   .---.---. |           +-------+-------------+
  ;                            |  E3 -->| balance: 100 |   | O | O-+-+     E1 -->| initial-amount: 100 |
  ;                            |        +--------------+   `-|-^---'             +---------------------+
  ;                            V                ^            |
  ;                        .---.---.            |            V
  ;                      +-+-O | O-+------------+            parameters: initial-amount
  ;                      | `---^---'                         body: (funcall (lambda (balance)
  ;                      V                                            (lambda (amount)
  ;              parameters: amount                                     (if (>= balance amount)
  ;              body: (if (>= balance amount)                            (progn
  ;                        (progn                                           (setq balance (- balance amount))
  ;                          (set! balance (- balance amount))              balance)
  ;                          balance)                                     "Insufficient funds"))
  ;                        "Insufficient funds")                       initial-amount))

#+END_SRC

*** Exercise 3.11
#+BEGIN_SRC elisp
  (define (make-account balance)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch)

  ;  1. (define acc (make-account 50))
  ;            +------------------------------------------------------------------------+
  ;  global -->| make-account:-----------------------------------------------+          |
  ;  env       |                                                             |          |
  ;            | acc ----+                                                   |          |
  ;            +---------|--------------------------------------------------------------+
  ;                      |                    ^                              |        ^
  ;                      |                    |                              V        |
  ;                      |        +----------+------------+              .---.---.    |
  ;                      |        | balance: 50           |       +------+-O | O-+---+
  ;                      |  E1 -->| dispatch    : --+     |       |      `---^---'
  ;                      |        | deposit: ...    |     |       V
  ;                      |        | withdraw: ...   |     |  parameters: balance
  ;                      |        +---------------- |-----+  body: (defun withdraw)
  ;                      |                          |    ^         (defun deposit)
  ;                      |                          V    |         (defun dispatch)
  ;                      |                     .---.---. |
  ;                      +-------------------->| O | O-+-+
  ;                                            `-|-^---'
  ;                                              V
  ;                                          parameters: m
  ;                                          body: body of dispatch
  ;
  ;  2. ((acc 'deposit) 40): This call  generates environment E2
  ;
  ;            +------------------------------------------------------------------------+
  ;  global -->| make-account: ...                                                      |
  ;  env       |                                                                        |
  ;            | acc +                                                                  |
  ;            +-----|------------------------------------------------------------------+
  ;                  |                    ^
  ;                  |                    |
  ;                  |        +----------+--------------------------------------+
  ;                  |        | balance: 50                                     |
  ;                  | E1 --> | deposit:                                        |
  ;                  |        | dispatch:                                       |
  ;                  |        | withdraw:                                       |
  ;                  |        +-------------------------------------------------+
  ;                  |             ^       ^      ^        ^               ^
  ;                  |             |       |      |        |               |
  ;                  |           .-|-.---. |    .-|-.---.  |         +-----|------+
  ;                  +---------->| O | O-+-+    | O | O-+--+   E2 -->| amount: 40 |
  ;                              `-|-^---'      `-|-^---'            +------------+
  ;                                V              V
  ;                            parameters: m    parameters: amount
  ;                            body: dispatch   body: deposit
  ;
  ;
  ;  3. ((acc 'withdraw) 60): Similarly to the previous call the following structure is generated
  ;
  ;            +------------------------------------------------------------------------+
  ;  global -->| make-account: ...                                                      |
  ;  env       |                                                                        |
  ;            | acc +                                                                  |
  ;            +-----|------------------------------------------------------------------+
  ;                  |                    ^
  ;                  |                    |
  ;                  |        +----------+--------------------------------------+
  ;                  |        | balance: 50                                     |
  ;                  | E1 --> | deposit:                                        |
  ;                  |        | dispatch:                                       |
  ;                  |        | withdraw:                                       |
  ;                  |        +-------------------------------------------------+
  ;                  |             ^       ^      ^        ^               ^
  ;                  |             |       |      |        |               |
  ;                  |           .-|-.---. |    .-|-.---.  |         +-----|------+
  ;                  +---------->| O | O-+-+    | O | O-+--+   E2 -->| amount: 60 |
  ;                              `-|-^---'      `-|-^---'            +------------+
  ;                                V              V
  ;                            parameters: m    parameters: withdraw
  ;                            body: dispatch   body: deposit
  ;
  ;
  ;  Q. Where is the local state for `acc' kept?
  ;  A. The symbol definition lives in the global environment, but the state
  ;     of the object lives in the environment created by the `make-account' call
  ;
  ;  Q. Suppose we define another account. How are the local states for the two
  ;     accounts kept distinct?
  ;  A. For every  `make-account' call, a new environment is created so for an
  ;     account `acc2' its state is maintained in a different environment
  ;
  ;  Q. Which parts of the environment structure are shared between `acc' and `acc2'
  ;  A. The Symbol definitions share the pointers to the actual code text
#+END_SRC

*** Exercise 3.12
#+BEGIN_SRC elisp
  ; 1. (cdr x) -> (b)
  ; 2. (cdr x) -> (b c d)

  ; firstly x, y and z are defined as:

  ;        +---+---+
  ;   z -->| * | * + ------------------------+
  ;        +-|-+---+                         |
  ;          |                               |
  ;          V                               V
  ;        +---+---+     +---+---+         +---+---+     +---+---+
  ;   x -->| * | *-+---->| * | / +    y -->| * | *-+---->| * | / +
  ;        +-|-+---+     +-|-+---+         +-|-+---+     +-|-+---+
  ;          a             b                 c             d
  ;
  ; After the mutator is applied, the new structure is:

  ;        +---+---+
  ;   z -->| * | * + ----------------------+
  ;        +-|-+---+                       |
  ;          |                   y ---+    |
  ;          V                        |    V
  ;        +---+---+     +---+---+    +->+---+---+     +---+---+
  ;   x -->| * | *-+---->| * | * +------>| * | *-+---->| * | / +
  ;   w -->+-|-+---+     +-|-+---+       +-|-+---+     +-|-+---+
  ;          a             b               c             d
#+END_SRC

*** Exercise 3.13
#+BEGIN_SRC elisp
;          +---------------------------------+
;          V                                 |
;        +---+---+     +---+---+       +---+-|-+
;   z -->| * | *-+---->| * | * +------>| * | * |
;        +-|-+---+     +-|-+---+       +-|-+---+
;          a             b	        c

; If we try to compute `(last-pair z)' the procedure will never find the
; `nil' value and will fall into an infinite loop
#+END_SRC

*** Exercise 3.14
#+BEGIN_SRC elisp

  (defun mystery (x)
    (defun (loop x y)
      (if (null? x)
          y
          (let ((temp (cdr x)))
            (set-cdr! x y)
            (loop temp x))))
    (loop x '()))

  ; (defvar v (list 'a 'b 'c 'd))

  ;        +---+---+     +---+---+    +->+---+---+     +---+---+
  ;   v -->| * | *-+---->| * | * +------>| * | *-+---->| * | / +
  ;        +-|-+---+     +-|-+---+       +-|-+---+     +-|-+---+
  ;          a             b               c             d
  ;
  ; (mystery v)
  ;   (loop '(a b c d) '())
  ;   (loop '(b c d) '(a))
  ;   (loop '(c d) '(b a))
  ;   (loop '(d) '(c b a))
  ;   (loop nil '(d c b a))

  ; The `mystery procedure will reverse the argument list in place
  ; the final structure after calling the procedure is:

  ;                                                  v --+
  ;                                                      V
  ;        +---+---+     +---+---+    +->+---+---+     +---+---+
  ;   w -->| * | *-+---->| * | * +------>| * | *-+---->| * | / +
  ;        +-|-+---+     +-|-+---+       +-|-+---+     +-|-+---+
  ;          d             c               b             a
  ;
  ; w will point to the reversed structure and v will remain pointing
  ; to the original "first" element of the list which is the pair
  ;; pointing to the value `a'.
#+END_SRC

*** Exercise 3.15
#+BEGIN_SRC text
 1. After calling set-to-wow! on z1, its new structure is:

                +---+---+
          z1 -->| * | * |
                +-|-+-|-+
                  V   V
                +---+---+     +---+---+
           x -->| * | *-+---->| * | / |
                +-|-+---+     +-|-+---+
                  V             V
                +---+         +---+
                |wow|         |wow|
                +---+         +---+

 2. After calling set-to-wow! on z1, its new structure is:

                              +---+
                              |wow|
                              +---+
                                ^
                +---+---+     +-|-+---+     +---+---+
          z2 -->| * | *-+---->| * | *-+---->| * | / |
                +-|-+---+     +---+---+     +-|-+---+
                  |                           V
                  |           +---+         +---+
                  |           | a |         | b |
                  |           +---+         +---+
                  |             ^             ^
                  |             |             |
                  |           +-|-+---+     +-|-+---+
                  +---------->| * | *-+---->| * | / |
                              +---+---+     +---+---+

#+END_SRC

(setcar x 'wow)
*** Exercise 3.16
#+BEGIN_SRC elisp
  (defun count-pairs (x)
    (if (not (consp x))
        0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))

  (count-pairs '(1 2 3))

  ;; build a list that will return 4
  (setq p1 (cons 'a 'b))
  (setq p2 (cons 'c 'd))
  (setq p3 (cons 'e 'f))

  (setcdr p1 p2)
  (setcar p1 p3)
  (setcdr p2 p3)

  (count-pairs p1) ; => 4

  ;        e   f
  ;        ^   ^
  ;      +-|-+-|-+
  ; p3 ->| * | * |
  ;      +---+---+
  ;        ^ ^
  ;        | |
  ;        | +-------------+
  ;      +-|-+---+   +---+-|-+
  ; p1 ->| * | * +-->| * | * | <- p2
  ;      +---+---+   +-|-+---+
  ;                    V
  ;                    c

  ;; build list that will return 7
  (setq p1 (cons 'a 'b))
  (setq p2 (cons 'c 'd))
  (setq p3 (cons 'e 'f))

  (setcar p1 p2)
  (setcdr p1 p2)
  (setcar p2 p3)
  (setcdr p2 p3)

  p1 ; => (((e . f) e . f) (e . f) e . f)

  (count-pairs p1) ; => 7

  ;  +---+---+
  ;  | * | * | <- p1
  ;  +-|-+-|-+
  ;    |   |
  ;    |   V
  ;    | +---+---+
  ;    +>| * | * | <- p2
  ;      +-|-+-|-+
  ;        |   |
  ;        |   V
  ;        | +---+---+
  ;        +>| * | * | <- p3
  ;          +-|-+-|-+
  ;            V   V
  ;            e   f

  ;; build a list that won't return at all using 2 pairs
  (setq p1 (cons 'a 'b))
  (setq p2 (cons 'c 'd))

  (setcar p1 p2)
  (setcar p2 p1)

  (count-pairs p1) ; Infinite loop

   ;        +---+---+
   ;  p1 -> | * | * +-> b
   ;        +---+---+
   ;         | ^
   ;         v |
   ;        +---+---+
   ;  p2 -> | * | * +-> d
   ;        +---+---+

#+END_SRC

*** Exercise 3.17
#+BEGIN_SRC elisp
  (defun count-pairs2 (x)
    ; the maintained list should always be
    ; visible to the original algorithm.
    (lexical-let ((counted '()))
      (defun count-aux (lst)
        (if (or (not (consp lst))
                (memq lst counted))
            0
          (setq counted (cons lst counted))
          (+ (count-aux (car lst))
             (count-aux (cdr lst))
             1)))
      (count-aux x)))


  (count-pairs2 '(1 2 3)) ; => 3

  (setq p1 (cons 'a 'b))
  (setq p2 (cons 'c 'd))
  (setq p3 (cons 'e 'f))

  (setcdr p1 p2)
  (setcar p1 p3)
  (setcdr p2 p3)

  (count-pairs2 p1) ; => 3

    ;; build list that will return 7
  (setq p1 (cons 'a 'b))
  (setq p2 (cons 'c 'd))
  (setq p3 (cons 'e 'f))

  (setcar p1 p2)
  (setcdr p1 p2)
  (setcar p2 p3)
  (setcdr p2 p3)

  (count-pairs2 p1) ; => 3

#+END_SRC

*** Exercise 3.18
#+BEGIN_SRC elisp

  (defun last-pair (x)
    (if (null (cdr x))
        x
      (last-pair (cdr x))))

  (defun contains-cycle-p (x)
    (defun helper (lst acc)
      (cond ((null (cdr lst)) nil)
            ((memq lst acc) t)
            (t (helper (cdr lst) (cons lst acc)))))
    (helper x '()))

  (setq p1 '(a b))
  (setq p2 '(c))
  (setq z (cons p1 p2))
  (setcdr p2 z)

  (contains-cycle-p '(1 2 3)) ; => nil
  (contains-cycle-p z)        ; => t

  ;           +---------------------------------+
  ;           V                                 |
  ;         +---+---+     +---+---+    +->+---+-|-+
  ;    z -->| * | *-+---->| * | * +------>| * | * +
  ;         +-|-+---+     +-|-+---+       +-|-+---+
  ;           a             b               c

#+END_SRC

*** Exercise 3.19
#+BEGIN_SRC elisp
  ; Hare and tortoise algorithm

  (defun is-cycle-p (x)
    (defun hare-and-tortoise (x)
      (let ((tortoise (car x))
            (hare (caddr x)))
        (cond ((null hare) nil)
              ((eq hare tortoise) t)
              (t (hare-and-tortoise (cdr x))))))
    (hare-and-tortoise x))

  (setq p1 '(a b c d e f))
  (setq p2 '(g))
  (setq z (cons p1 p2))
  (setcdr p2 z)

  (is-cycle-p '(1 2 3)) ; => nil
  (is-cycle-p z)        ; => t
#+END_SRC

*** Exercise 3.20
#+BEGIN_SRC text
  ;  (define x (cons 1 2))

                 +---------------------------------------------+
     global      | cons +-----+            x +--+              |
     environment |            |                 |              |
                 |            |                 |              |
                 +------------|-----------------|--------------+
                              |       ^         |           ^
                              |       |         |           |
                            +-|-+---+ |         |        +------+
                        ----+ * | * +--         |   E1 ->| x: 1 |
                        |   +---+---+           |        | y: 2 |
                        |                       |        +------+
                        V                       |           ^
                        params: x y             |           |
                        body: cons              |           |
                                              +-|-+---+     |
                                          ----+ * | * +------
                                          |   +---+---+
                                          |
                                          V
                                         params: m
                                         body: dispatch
  ;  (define z (cons x x))

                 +-----------------------------------------------------------------------+
     global      | cons +-----+            x +--+                   z +---+              |
     environment |            |                 |                         |              |
                 |            |                 |                         |              |
                 +------------|-----------------|-------------------------|--------------+
                              |       ^         |           ^             |           ^
                              |       |         |           |             |           |
                            +-|-+---+ |         |        +------+         |        +------+
                        ----+ * | * +--         |   E1 ->| x: 1 |         |   E2 ->| x: x |
                        |   +---+---+           |        | y: 2 |         |        | y: x |
                        |                       |        +------+         |        +------+
                        V                       |           ^             |           ^
                        params: x y             |           |             |           |
                        body: cons              |           |             |           |
                                              +-|-+---+     |           +-|-+---+     |
                                          ----+ * | * +------       ----+ * | * +------
                                          |   +---+---+             |   +---+---+
                                          |                         |
                                          V                         V
                                         params: m                 params: m
                                         body: dispatch            body: dispatch

  ;  (set-car! (cdr z) 17)

                 +-----------------------------------------------------------------------+
     global      |                                                                       |
     environment |                                                                       |
                 |   x                        z                                          |
                 +-----------------------------------------------------------------------+
                     ^                        ^                    ^                 ^
                     |                        |                    |                 |
              +---------------+        +---------------+        +------+        +-------------+
              | x:  1         |        | x:  x         |        | z: z |        | z: x        |
         E1 ->| y:  2         |   E2 ->| y:  x         |   E3 ->|      |   E5 ->| new-val: 17 |
              | dispatch: ... |        | dispatch: ... |        |      |        |             |
              +---------------+        +---------------+        +------+        +-------------+
              (cons 1 2)     ^          (cons x x)              (cdr z)         (set-car! (cdr z) 17)
                ^            |                 ^
                |            |                 |
           +-------------+   |            +---------+
      E6 ->| m: set-car! |   |       E4 ->| m: cdr  |
           |             |   |            +---------+
           +-------------+   |            dispatch
           dispatch          |
                        +---------+
                        | v: 17   |
                   E7 ->|         |
                        +---------+
                        set-x!

    ; (car x)

                 +---------------------------+
     global      |                           |
     environment |                           |
                 |              x            |
                 +---------------------------+
                                ^
                                |
                         +---------------+
                         | x:  17        |
                    E1 ->| y:  2         |
                         | dispatch: ... |
                         +---------------+
                                ^
                                |
                         +---------------+
                         | m: car        |
                    E2 ->|               |
                         +---------------+
                          dispatch


#+END_SRC

*** Exercise 3.21
#+BEGIN_SRC elisp
  ; The queue is just a pointer to the first and last
  ; elements in the queue, when the evaluator reads this
  ; pair it'll print a construction of the first element
  ; that represents the whole list and a the last item of
  ; the list, that's why the second element is always the
  ; last element of the list. When an item is deleted, the
  ; rear pointer remains untouched that's why it doesn't
  ; change in the result displayed by the evaluator.

  ; The `print-queue` definition should only try to print
  ; what is pointed by the front pointer.

  (defun print-queue (queue) (front-ptr queue))

  (setq p1 (make-queue))
  (insert-queue! p1 'a) ; => ((a) a)
  (print-queue p1)      ; => (a)

  (insert-queue! p1 'b) ; => ((a b) b)
  (print-queue p1)      ; => (a b)

  (delete-queue! p1)    ; => ((b) b)
  (print-queue p1)      ; => (b)

  (delete-queue! p1)    ; => (nil b)
  (print-queue p1)      ; => nil
#+END_SRC

*** Exercise 3.22
#+BEGIN_SRC elisp
  (defun make-queue ()
    (lexical-let ((front-ptr (cons nil nil))
                  (rear-ptr  (cons nil nil)))
      (defun empty-queue () (null (car front-ptr)))

      (defun print-q () (car front-ptr))
      (defun front-queue ()
        (cond ((empty-queue)
               (error "FRONT called with an empty queue"))
              (t (car (car front-ptr)))))

      (defun insert-queue (item)
        (let ((new-item (cons item nil)))
          (cond ((empty-queue)
                 (setcar front-ptr new-item)
                 (setcar rear-ptr new-item))
                (t
                  (setcdr (car rear-ptr) new-item)
                  (setcar rear-ptr new-item)))))

      (defun delete-queue ()
        (cond ((empty-queue)
               (error "DELETE called with an empty queue"))
              (t (setcar front-ptr (cdr (car front-ptr))))))

      ;; Dispatcher
      (lambda (m)
        (cond ((eq m 'empty-queue?) (empty-queue))
              ((eq m 'print-queue) (print-q))
              ((eq m 'front-queue?) (front-queue))
              ((eq m 'delete-queue!) (delete-queue))
              ((eq m 'insert-queue!)
               (lambda (i) (insert-queue i)))))))

   (defun empty-queue? (q)
     (funcall q 'empty-queue?))

   (defun print-queue (q)
     (funcall q 'print-queue))

   (defun front-queue? (q)
     (funcall q 'front-queue?))

   (defun insert-queue! (queue item)
     (funcall (funcall queue 'insert-queue!) item))

   (defun delete-queue! (q)
     (funcall q 'delete-queue!))

  (setq p1 (make-queue))
  (empty-queue? p1)

  (insert-queue! p1 'a) ; => (a)
  (print-queue p1)      ; => (a)

  (insert-queue! p1 'b) ; => (b)
  (print-queue p1)      ; => (a b)

  (delete-queue! p1)    ; => (b)
  (print-queue p1)      ; => (b)

  (delete-queue! p1)    ; => nil
  (print-queue p1)      ; => nil
#+END_SRC

*** Exercise 3.23
#+BEGIN_SRC elisp
  ;; For this data structure, new items must
  ;; point to the next and previous item cells
  ;; this is needed for the operation of
  ;; `rear-delete-deque!' we need to know what
  ;; the previous cell is in order to update the
  ;; `rear-ptr'.
  ;; Cells will look like this:
  ;;
  ;; +-------+-------+-----+
  ;; | prev | value | next |
  ;; +------|-------|------+
  ;;
  ;; the operations for access are:
  ;; prev-ptr: 'car, i.e: (car (cons nil (cons 'a nil)))
  ;; value: 'cadr, i.e: (cadr (cons nil (cons 'a nil)))
  ;; next-ptr: cddr, i.e: (cddr (cons nil (cons 'a nil)))

  (defun make-deque ()
    (lexical-let ((front-ptr (cons nil nil))
                  (rear-ptr  (cons nil nil)))
      (defun empty-deque ()
        (and (null (car front-ptr))
             (null (car rear-ptr))))

      (defun print-d ()
        (defun print-helper (d)
          (if (null d)
              nil
            (insert (format "[%s] " (cadr d)))
            (print-helper (cddr d))))
        (print-helper (car front-ptr)))

      (defun front-deque ()
        (cond ((empty-deque)
               (error "FRONT called with an empty deque"))
              (t (cadr (car front-ptr)))))

      (defun rear-deque ()
        (cond ((empty-deque)
               (error "REAR called with an empty deque"))
              (t (cadr (car rear-ptr)))))

      (defun front-insert-deque (item)
        (let ((new-item (cons nil (cons item nil))))
          (cond ((empty-deque)
                 (setcar front-ptr new-item)
                 (setcar rear-ptr new-item))
                (t
                  (setcdr (cdr new-item) (car front-ptr))
                  (setcar (car front-ptr) new-item)
                  (setcar front-ptr new-item)))))

      (defun rear-insert-deque (item)
        (let ((new-item (cons nil (cons item nil))))
          (cond ((empty-deque)
                 (setcar front-ptr new-item)
                 (setcar rear-ptr new-item))
                (t
                 (setcar new-item (car rear-ptr))
                 (setcdr (cdr (car rear-ptr)) new-item)
                 (setcar rear-ptr new-item)))))

      (defun front-delete-deque ()
        (cond ((empty-deque)
               (error "FRONT-DELETE called with an empty deque"))
              ((eq (car front-ptr) (car rear-ptr))
               (setcar front-ptr nil)
               (setcar rear-ptr nil))
              (t (setcar front-ptr (cddr (car front-ptr)))
                 (setcar (car front-ptr) nil))))

      (defun rear-delete-deque ()
        (cond ((empty-deque)
               (error "REAR-DELETE called with an empty deque"))
              ((eq (car front-ptr) (car rear-ptr))
               (setcar front-ptr nil)
               (setcar rear-ptr nil))
              (t (setcar rear-ptr (caar rear-ptr))
                 (setcdr (cdr (car rear-ptr)) nil))))

      ;; Dispatcher
      (lambda (m)
        (cond ((eq m 'empty-deque?) (empty-deque))
              ((eq m 'print-deque) (print-d))
              ((eq m 'front-deque?) (front-deque))
              ((eq m 'rear-deque?) (rear-deque))
              ((eq m 'front-delete-deque!) (front-delete-deque))
              ((eq m 'rear-delete-deque!) (rear-delete-deque))
              ((eq m 'front-insert-deque!)
               (lambda (i) (front-insert-deque i)))
              ((eq m 'rear-insert-deque!)
               (lambda (i) (rear-insert-deque i)))))))

   (defun empty-deque? (d)
     (funcall d 'empty-deque?))

   (defun print-deque (d)
     (funcall d 'print-deque))

   (defun front-deque? (d)
     (funcall d 'front-deque?))

   (defun rear-deque? (d)
     (funcall d 'rear-deque?))

   (defun front-insert-deque! (d item)
     (funcall (funcall d 'front-insert-deque!) item))

   (defun rear-insert-deque! (d item)
     (funcall (funcall d 'rear-insert-deque!) item))

   (defun front-delete-deque! (d)
     (funcall d 'front-delete-deque!))

   (defun rear-delete-deque! (d)
     (funcall d 'rear-delete-deque!))

  ; Tests
  (setq p1 (make-deque))
  (empty-deque? p1) ; => t

  (front-insert-deque! p1 'a)
  (front-deque? p1)  ; => a
  (rear-deque? p1)   ; => a
  (print-deque p1)   ; => [a]

  (front-insert-deque! p1 'b)
  (front-deque? p1)  ; => b
  (rear-deque? p1)   ; => a
  (print-deque p1)   ; => [b] [a]


  (setq p1 (make-deque))
  (empty-deque? p1) ; => t

  (rear-insert-deque! p1 'a)
  (front-deque? p1)  ; => a
  (rear-deque? p1)   ; => a
  (print-deque p1)   ; => [a]

  (rear-insert-deque! p1 'b)
  (front-deque? p1)  ; => a
  (rear-deque? p1)   ; => b
  (print-deque p1)   ; => [a] [b]


  (setq p1 (make-deque))
  (empty-deque? p1) ; => t

  (front-insert-deque! p1 'a)
  (rear-insert-deque! p1 'b)
  (front-deque? p1)  ; => a
  (rear-deque? p1)   ; => b
  (print-deque p1)   ; => [a] [b]

  (rear-delete-deque! p1)
  (print-deque p1) ; => [a]

  (front-delete-deque! p1)
  (print-deque p1)   ; => nil

#+END_SRC

*** Exercise 3.24
#+BEGIN_SRC elisp
  (defun table/make-table (same-key)
    (lexical-let ((local-table (list '*table*))
                  (same-key? same-key))
      (defun my-table/lookup (key table)
        (let ((record (my-table/assoc key (cdr table))))
          (if record
              (cdr record)
            nil)))

      (defun my-table/assoc (key records)
        (cond ((null records) nil)
              ((funcall same-key? key (caar records)) (car records))
              (t (my-table/assoc key (cdr records)))))

      (defun my-table/insert! (key value table)
        (let ((record (my-table/assoc key (cdr table))))
          (if record
              (setcdr record value)
            (setcdr table (cons (cons key value) (cdr table)))))
        'ok)

      (defun my-table2D/lookup (key-1 key-2)
        (let ((subtable (my-table/assoc key-1 (cdr local-table))))
          (if subtable
              (my-table/lookup key-2 subtable)
            nil)))

      (defun my-table2D/insert! (key-1 key-2 value)
        (let ((subtable (my-table/assoc key-1 (cdr local-table))))
          (if subtable
              (my-table/insert! key-2 value subtable)
            (setcdr local-table (cons (list key-1 (cons key-2 value))
                                      (cdr local-table)))))
        'ok)
      (lambda (m)
        (cond ((eq m 'lookup-proc)
               (lambda (key-1 key-2)
                 (my-table2D/lookup key-1 key-2)))
              ((eq m 'insert-proc)
               (lambda (key-1 key-2 val)
                 (my-table2D/insert! key-1 key-2 val)))))))

  (setq p1 (table/make-table 'equal))
  (defun sicp-get (key-1 key-2)
    (funcall (funcall p1 'lookup-proc) key-1 key-2))
  (defun sicp-put (key-1 key-2 val)
    (funcall (funcall p1 'insert-proc) key-1 key-2 val))

  (sicp-put 'one 'one 11)  ; => ok
  (sicp-get 'one 'one)     ; => 11
  (sicp-put 'one 'two 12)  ; => ok
  (sicp-get 'one 'two)     ; => 12
  (sicp-put 'ten 'two 102) ; => ok
  (sicp-get 'ten 'two)     ; => 102

  ;; give numeric tolerance to the table keys
  (setq p1 (table/make-table
            (lambda (x y)
              (< (abs (- x y)) 0.01))))
  (defun sicp-get (key-1 key-2)
    (funcall (funcall p1 'lookup-proc) key-1 key-2))
  (defun sicp-put (key-1 key-2 val)
    (funcall (funcall p1 'insert-proc) key-1 key-2 val))

  (sicp-put 4 4 'four)    ; => ok
  (sicp-get 4 4)          ; => four
  (sicp-get 3.999 4.0001) ; =>  four
#+END_SRC

*** Exercise 3.25
#+BEGIN_SRC elisp
  (defun table/make-table (same-key)
    (lexical-let ((local-table (list '*table*))
                  (same-key? same-key))

      (defun my-table/assoc (key records)
        (cond ((null records) nil)
              ((funcall same-key? key (caar records)) (car records))
              (t (my-table/assoc key (cdr records)))))

      (defun my-table/lookup (keys table)
        (let ((record (my-table/assoc (car keys) (cdr table))))
          (if record
              (cond ((null (cdr keys)) (cdr record))
                    (t (my-table/lookup (cdr keys) record)))
            nil)))

      (defun my-table/insert! (keys value table)
        (let ((record (my-table/assoc (car keys) (cdr table))))
          (if record
              (cond ((null (cdr keys)) (setcdr record value))
                    (t (my-table/insert! (cdr keys) value record)))
            (setcdr table (cons (cons (car keys) nil) (cdr table)))
            (my-table/insert! keys value table)))
        'ok)

      (lambda (m)
        (cond ((eq m 'lookup-proc)
               (lambda (keys)
                 (my-table/lookup keys local-table)))
              ((eq m 'insert-proc)
               (lambda (keys val)
                 (my-table/insert! keys val local-table)))))))

  (setq p1 (table/make-table 'equal))
  (defun sicp-get (keys)
    (funcall (funcall p1 'lookup-proc) keys))
  (defun sicp-put (keys val)
    (funcall (funcall p1 'insert-proc) keys val))

  (sicp-put '(one one) 11)  ; => ok
  (sicp-get '(one one))     ; => 11
  (sicp-put '(one two) 12)  ; => ok
  (sicp-get '(one two))     ; => 12
  (sicp-put '(ten two) 102) ; => ok
  (sicp-get '(ten two))     ; => 102

  (setq p1 (table/make-table 'equal))
  (defun sicp-get (keys)
    (funcall (funcall p1 'lookup-proc) keys))
  (defun sicp-put (keys val)
    (funcall (funcall p1 'insert-proc) keys val))

  (sicp-put '(one two three) 123) ; => ok
  (sicp-put '(four five six) 456) ; => ok
  (sicp-get '(one two three))     ; => 123
  (sicp-get '(four five six))     ; => 456
#+END_SRC

*** Exercise 3.26
#+BEGIN_SRC elisp
  ;; +------+-------+-----+--------+
  ;; | left | right | key | values |
  ;; +------+-------+-----+--------+

  ; retrieve value
  ; (cdddr (cons 'nil (cons 'nil (cons 'key 'nil))))

  ; retrieve key
  ; (caddr (cons 'left (cons 'right (cons 'key 'val))))

  (defun table/make-table (same-key less-than greater-than)
    (lexical-let ((local-table (list '*table* nil nil nil))
                  (same-key? same-key)
                  (less-than? less-than)
                  (greater-than? greater-than))

      (defun make-node (key val)
        (cons nil (cons nil (cons key val))))

      (defun get-node-val (node) (cdddr node))
      (defun set-node-val (node val) (setcdr (cddr node) val))
      (defun get-node-left (node) (car node))
      (defun set-node-left (node val) (setcar node val))
      (defun get-node-right (node) (cadr node))
      (defun set-node-right (node val) (setcar (cdr node) val))
      (defun get-node-key (node) (caddr node))
      (defun set-node-key (node key) (setcar (cddr node) key))

      (defun my-table/assoc (key node &optional create-node?)
        (cond ((funcall same-key? key (get-node-key node)) node)
              ((funcall less-than? key (get-node-key node))
               (if (null (get-node-left node))
                   (if (null create-node?)
                       nil
                     (set-node-left node (make-node key nil))
                     (get-node-left node))
                 (my-table/assoc key (get-node-left node) create-node?)))
              ((funcall greater-than? key (get-node-key node))
               (if (null (get-node-right node))
                   (if (null create-node?)
                       nil
                     (set-node-right node (make-node key nil))
                     (get-node-right node))
                 (my-table/assoc key (get-node-right node) create-node?)))
              (t nil)))

      ;; check the table argument to pass to `assoc'
      (defun my-table/lookup (keys table)
        (let ((record (my-table/assoc (car keys) table)))
          (if record
              (cond ((null (cdr keys)) (get-node-val record))
                    (t (my-table/lookup (cdr keys) (get-node-val record))))
            nil)))

      (defun my-table/insert! (keys value table)
        (if (null (get-node-key table))
            (set-node-key table (car keys)))
        (let ((record (my-table/assoc (car keys) table t)))
          (if record
              (cond ((and (cdr keys) (null (get-node-val record)))
                     (set-node-val  record (make-node (cadr keys) nil))
                     (my-table/insert! (cdr keys) value (get-node-val record)))
                    ((null (cdr keys))
                     (set-node-val record value))
                    (t
                     (my-table/insert! (cdr keys) value (get-node-val record))))
            (error "Error inserting value. -- INSERT")))
        'ok)

      (lambda (m)
        (cond ((eq m 'lookup-proc)
               (lambda (keys)
                 (my-table/lookup keys (cdr local-table))))
              ((eq m 'insert-proc)
               (lambda (keys val)
                 (my-table/insert! keys val (cdr local-table))))))))


  ; Test with numeric keys
  (setq p1 (table/make-table '= '< '>))
  (defun sicp-get (keys)
    (funcall (funcall p1 'lookup-proc) keys))
  (defun sicp-put (keys val)
    (funcall (funcall p1 'insert-proc) keys val))

  (sicp-put '(1 1) 11)   ; => ok
  (sicp-get '(1 1))      ; => 11
  (sicp-put '(1 2) 12)   ; => ok
  (sicp-get '(1 2))      ; => 12
  (sicp-put '(10 2) 102) ; => ok
  (sicp-get '(10 2))     ; => 102

  ; test with string keys
  (defun my-string> (s1 s2) (not (string< s1 s2)))

  (setq p1 (table/make-table 'string= 'string< 'my-string>))
  (defun sicp-get (keys)
    (funcall (funcall p1 'lookup-proc) keys))
  (defun sicp-put (keys val)
    (funcall (funcall p1 'insert-proc) keys val))

  (sicp-put '("one" "two" "three") 123) ; => ok
  (sicp-put '("four" "five" "six") 456) ; => ok
  (sicp-get '("one" "two" "three"))     ; => 123
  (sicp-get '("four" "five" "six"))     ; => 456
#+END_SRC

*** Exercise 3.27
#+BEGIN_SRC elisp
;         +--------------------+
;  global | memoize            |
;  env    | memo-fib           |
;         +--------------------+
;                     ^
;                     |
;               +------------+
;          E1 ->| table      |
;               +------------+
;               (memoize ...)
;                     ^
;                     |
;               +------------+
;          E2 ->| result     |
;               +------------+
;                (memo-fib 3)
;                ^          ^
;                |          |
;            +---------+  +--------+
;       E3 ->| result  |  | result |<- E6
;            +---------+  +--------+
;           (memo-fib 2) (memo-fib 1)
;            ^         ^
;            |         |
;       +--------+ +--------+
;  E4 ->| result | | result |<- E5
;       +--------+ +--------+
;      (memo-fib 1) (memo-fib 0)
#+END_SRC

*** Exercise 3.28
#+BEGIN_SRC elisp
  (defun or-gate (a1 a2 output)
    (defun or-action-procedure
      (let ((new-value
             (logical-or (get-signal a1) (get-signal a2))))
        (after-delay or-gate-delay
                     (lambda ()
                       (set-signal! output new-value)))))
    (add-action! a1 or-action-procedure)
    (add-action! a2 or-action-procedure)
    'ok)
  (defun logical-or (a b)
    (if (and (is-logic a) (is-logic b))
        (if (or (= a 1) (= b 1))
            1
          0)
      (error "Invalid signal. -- LOGICAL-OR"))
#+END_SRC

*** Exercise 3.29
#+BEGIN_SRC elisp
  ;         |\     c
  ;    a ---| >o---+    ___
  ;         |/     +---|   \  e   |\
  ;                    |    )---- | >o---- output
  ;         |\     +---|___/      |/
  ;    b ---| >o---+
  ;         |/     d
  ;
  ; The delay of this `or-gate' implementation  is:
  (+ inverter-delay and-gate-delay inverter-delay)

  (defun or-gate (a b output)
    (let ((c (make-wire))
          (d (make-wire))
          (e (make-wire)))
      (inverter a c)
      (inverter b d)
      (and-gate c d e)
      (inverter e output)
      'ok))
#+END_SRC

*** Exercise 3.30
#+BEGIN_SRC elisp
  (defun ripple-carry (a-in b-in c sum)
    (let ((c-k (make-wire)))
      (cond ((null (cdr a))
             (set-signal! c-k 0))
            (t
             (ripple-carry (cdr a) (cdr b) c-k (cdr sum))))
      (full-adder (car a) (car b) c-k sum c))
    'ok)

  ; we can expand the delay that represents each `full-adder'
  ; ripple-carry-delay = (* n full-adder-delay)
  ; = (* n (* 2 half-adder-delay))

  ; now select `greater-delay' as the greater value between
  ; `or-gate-delay' and (+ and-gate-delay inverter-delay)

  ; = (* n (* 2 (+ greater-delay and-gate-delay)))
#+END_SRC

*** Exercise 3.31
#+BEGIN_SRC text
  Forcing the call to the added procedure assures that `after-delay'
  is called, which in turns adds items to the agenda. In the case that
  the call was missing in the definition of `accept-action-procedure!'
  then the agenda would be empty and calling propagate wouldn't have
  anything to execute.
#+END_SRC

*** Exercise 3.32
#+BEGIN_SRC elisp
  (setq and-gate-delay 3)
  (setq the-agenda (make-agenda))
  (setq input-1 (make-wire))
  (setq input-2 (make-wire))
  (setq output-1 (make-wire))

  (probe 'input-1 input-1)   ; => input-1  0 New-value = 0
  (probe 'input-2 input-2)   ; => input-2  0 New-value = 0
  (probe 'output-1 output-1) ; => output-1 0 New-value = 0

  (and-gate input-1 input-2 output-1)
  (set-signal! input-1 1)    ; => input-1 0 New-value = 1
  (set-signal! input-2 1)    ; => input-2 0 New-value = 1

  (propagate)  ; => output-1 3 New-value = 1

  ;  Following the example of the `and-gate' if any order was allowed,
  ;  let's say for example, instead of storing the signal changes as 0, 1
  ;  and then 1, 0 and save them a an order like 0, 0 and then 1, 1 the
  ;  output would be incorrect.
#+END_SRC

*** Exercise 3.33
#+BEGIN_SRC elisp
  ;   c = (a + b)/2
  ;
  ;       .-----. u  .------
  ;   a --|m1  p|----|m1  p|-- c
  ;   b --|m2  +|  --|m2  *|
  ;       `-----'  | `-----'
  ;                | v
  ;              +--+
  ;              |.5|
  ;              +--+

  (defun averager (a b c)
    (lexical-let ((u (make-connector))
                  (v (make-connector)))
    (adder a b u)
    (multiplier u v c)
    (constant 0.5 v)
    'ok))

  ; Tests
  (setq p1 (make-connector))
  (setq p2 (make-connector))
  (setq p3 (make-connector))

  (probe "p1:" p1)
  (probe "p2:" p2)
  (probe "p3:" p3)

  (averager p1 p2 p3) ; => ok

  (set-value! p1 10 'user) ; => Probe: p1: = 10
  (set-value! p2 5  'user) ; => Probe: p3: = 7.5
                           ; => Probe: p2: = 5

  (forget-value! p1 'user) ; => Probe: p3: = ?
                           ; => Probe: p1: = ?

  (forget-value! p2 'user) ; => Probe: p2: = ?

  (set-value! p3 5 'user)  ; => Probe: p3: = 5
  (set-value! p2 2 'user)  ; => Probe: p1: = 8.0
                           ; => Probe: p2: = 2
#+END_SRC

*** Exercise 3.34
#+BEGIN_SRC text
   This programmer is thinking in one direction programming,
   Louis didn't think in what would happen if the user needs to
   propagate the restriction setting the value of `b'. The
   multiplier requires a minimum of 2 values in order to operate,
   so the user can't propagate the restriction by only setting
   the value of connector `b'.
#+END_SRC

*** Exercise 3.35
#+BEGIN_SRC elisp
  (defun squarer (m1 m2)
    (lexical-let ((a m1)
                  (b m2)
                  (process-new-value nil)
                  (process-forget-value nil)
                  (me nil))

      ; function definitions
      (setq me
            (lambda (request)
              (cond ((eq request 'I-have-a-value)
                     (funcall process-new-value))
                    ((eq request 'I-lost-my-value)
                     (funcall process-forget-value))
                    (t (error "Unknown request -- MULTIPLIER")))))

      (setq process-new-value
            (lambda ()
              (cond ((has-value? a)
                     (set-value! b
                                 (* (get-value a) (get-value a))
                                 me))
                    ((has-value? b)
                     (set-value! a
                                 (sqrt (get-value b))
                                 me)))))

      (setq process-forget-value
            (lambda ()
              (forget-value! a me)
              (forget-value! b me)
              (funcall process-new-value)))

      (connect a me)
      (connect b me)
      me))

  (setq p1 (make-connector))
  (setq p2 (make-connector))
  (probe "p1:" p1)
  (probe "p2:" p2)
  (squarer p1 p2)

  (set-value! p1 6 'user) ; => Probe: p2: = 36
                          ; => Probe: p1: = 6

  (forget-value! p1 'user) ; => Probe: p2: = ?
                           ; => Probe: p1: = ?

  (set-value! p2 2 'user) ; => Probe: p1: = 1.4142...
                          ; => Probe: p2: = 2
#+END_SRC

*** Exercise 3.36
#+BEGIN_SRC elisp
  ; `b' will contain a similar structure to `a'
  ;
  ;             +--------------------------------------------------------+
  ;             | b ...                                                  |
  ; global      | for-each-except ----------------------------+          |
  ; environment | a                                           |          |
  ;             | |                                           |          |
  ;             +-|-------------------------------------------|----------+
  ;               |                     ^                     |      ^
  ;               |                     |                     V      |
  ;               |       +-------------|--------+        .---.---.  |
  ;               |       | value                |     ---+ o | o +--+
  ;               |   E1->| informant            |     |  `---^---'
  ;               |       | set-my-value         |     V
  ;               |       +----------------------+    Parameters
  ;               V             ^       ^             Body
  ;         .---.---.           |       |
  ;      ---+ o | o +-----------+       |
  ;      |  `---^---'                   |
  ;      V                      +-------|--------+
  ;     Parameters         E2 ->|                |
  ;     body                    +----------------+
  ;                             (set-my-value ...)
  ;                                     ^
  ;                                     |
  ;                             +-------|--------+
  ;                        E3 ->|                |
  ;                             +----------------+
  ;                             (for-each-except...)
#+END_SRC

*** Exercise 3.37
#+BEGIN_SRC elisp
 (defun celsius-fahrenheit-converter (x)
   (c+ (c* (c/ (cv 9) (cv 5))
           x)
       (cv 32)))
 (setq C (make-connector))
 (setq F (celsius-fahrenheit-converter C))

 (forget-value! C 'user)
 (set-value! C 10 'user)
 (get-value C) ; => 10
 (get-value F) ; => 50.0

 (forget-value! C 'user) ; => done
 (set-value! F 2 'user)  ; => done
 (get-value F)           ; => 2
 (get-value C)           ; => -16.66

 (defun c+ (a b)
   (lexical-let ((c (make-connector)))
     (adder a b c)
     c))

 (defun c* (a b)
   (lexical-let ((c (make-connector)))
     (multiplier a b c)
     c))

 (defun cv (a)
   (lexical-let ((c (make-connector)))
     (constant a c)
     c))

 (defun c/ (a b)
   (c* a
       (cv (/ 1.0 (get-value b)))))
#+END_SRC

*** Exercise 3.38
#+BEGIN_SRC text
   Initial balance: $100
   Peter: (set! balance (+ balance 10))
   Paul:  (set! balance (- balance 20))
   Mary:  (set! balance (- balance (/ balance 2)))

 a. $110, $80, $50

 b.
   Output based on the order the transactions were processed sequentially:
   Peter, Paul, Mary: 110, 90, 45 => balance: $45
   Peter, Mary, Paul: 110, 55, 35 => balance: $35
   Paul, Peter, Mary:  80, 90, 45 => balance: $45
   Paul, Mary, Peter:  80, 40, 50 => balance: $50
   Mary, Peter, Paul:  50, 60, 40 => balance: $40
   Mary, Paul, Peter:  50, 30, 10 => balance: $40

   (Peter, Paul), Mary: $40
   Mary, (Peter, Paul): $30

   (Peter, Mary), Paul: $30
   Paul, (Peter, Mary): $40

   (Paul, Peter), Mary: $55
   Mary, (Paul, Peter): $60

   (Paul, Mary), Peter: $60
   Peter, (Paul, Mary): $55

   (Mary, Peter), Paul: $90
   Paul, (Mary, Peter): $90

   (Mary, Paul), Peter: $90
   Peter, (Mary, Paul): $90

   All possible values: 110, 90, 80, 60, 55 50, 45, 40, 35, 30
#+END_SRC

*** Exercise 3.39
#+BEGIN_SRC scheme
  (define x 10)
  (define s (make-serializer))

  (parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                    (s (lambda () (set! x (+ x 1)))))

;  121: The second serializer executed before the first one
;  101: The first serializer finished first and value was set before second serializer
;   11: The first serializer finished first but the assignment wasn't completed
;       and the second serializer took the value x=10
#+END_SRC

*** Exercise 3.40
#+BEGIN_SRC elisp
  (define x 10)
  (parallel-execute (lambda () (set! x (* x x)))
                    (lambda () (set! x (* x x x))))

;   1000000: P1 ends first then P2
;       100: P1 reads 10 for each x and overrides the value of P2
;      1000: P2 reads 10 for each x and overrides P1
;     10000: P1 reads 10, 10 and P2 reads 10, 10, 100
;    100000: P1 reads 10, 10 and P2 reads 10, 100, 100

; After serialization:
;   1000000: P1 followed by P2
;   1000000: P2 followed by P1

#+END_SRC

*** Exercise 3.41
#+BEGIN_SRC text
  The only 2 problems that may come around is that when inquiring the balance
  it may not be correct sometimes when there's a concurrent deposit or
  withdraw, but this shouldn't be anomalous behavior. The other situation
  is if the user tries to set the balance without using the `withdraw' or the
  `deposit' procedure, but in this case the user is causing the anomalous
  behavior and not our account system.
#+END_SRC

*** Exercise 3.42
#+BEGIN_SRC elisp
  The main difference is that the new version avoids calling too many
  times the serializer procedure. In regarding of concurrency there
  shouldn't be any difference, so it should be safe to do the change.
#+END_SRC

*** Exercise 3.43
#+BEGIN_SRC text
  Accounts: A:10, B:20, C:30
  1. `serialized-exchange' extracts the serializer for each account and
      apply them to the exchange procedure. This will allow that each call
      to the account procedures `withdraw' and `deposit' run for the first
      account and them for the second account. This assures that the sum of
      the three accounts will maintain.

  2. The first version of `exchange' is:

     (define (exchange account1 account2)
       (let ((difference (- (account1 'balance)
                            (account2 'balance))))
         ((account1 'withdraw) difference)
         ((account2 'deposit) difference)))

     Suppose that we run the following processes in parallel `(exchange A B)'
     and `(exchange B C)' it isn't difficult to see that it is possible that
     both processes read the same value for account B, then both processes
     will try to do the exchange using the same amount of B.

  3. However in the former version, we're using serialized procedures for
     `withdraw' and `deposit', so if the concurrent exchange processes set
     the incorrect amount in the accounts, the serialized procedures assures
     that no additional money is added or removed from the sum of all three
     accounts.
#+END_SRC

*** Exercise 3.44
#+BEGIN_SRC text
     (define (transfer from-account to-account amount)
            ((from-account 'withdraw) amount)
            ((to-account 'deposit) amount))

     (define (exchange account1 account2)
       (let ((difference (- (account1 'balance)
                            (account2 'balance))))
         ((account1 'withdraw) difference)
         ((account2 'deposit) difference)))

  Exchange requires that both accounts are locked because the
  requirement is that the amount of both accounts are exchanged,
  so both amounts need to be kept.

  On the other hand for transfer is more simple, the requirement
  says to withdraw from one account and deposit in the other one.
  Hence it is safe keep the suggested procedure.
#+END_SRC

*** Exercise 3.45
#+BEGIN_SRC elisp
     (define (exchange account1 account2)
       (let ((difference (- (account1 'balance)
                            (account2 'balance))))
         ((account1 'withdraw) difference)
         ((account2 'deposit) difference)))

     (define (serialized-exchange account1 account2)
       (let ((serializer1 (account1 'serializer))
             (serializer2 (account2 'serializer)))
         ((serializer1 (serializer2 exchange))
          account1
          account2)))

  In the suggested implementation, the `deposit/withdraw' procedures
  will be added to the serializer twice, this may cause the procedures
  to lock indefinitely waiting in a circular reference for the resource
  to be released.
#+END_SRC

*** Exercise 3.46
#+BEGIN_SRC text
  Just suppose that two processes read that the mutex cell
  is available, they're free to set the cell value to true
  and return false, this will allow the serializer to run
  both procedures when supposedly one of then should be
  locked.

  The diagram is PENDING.
#+END_SRC

*** Exercise 3.47
#+BEGIN_SRC elisp
  ; based on what's described here:
  ; https://en.wikipedia.org/wiki/Semaphore_(programming)

  ; V and P will decrement S by one at a time
  ; a.
  (defun make-semaphore (size)
    (lexical-let ((S size)
                  (mutex (make-mutex)))

      (setq P (lambda ()
                (if (> S 0)
                    (setq S (1- S))
                  funcall V)))

      (setq V (lambda ()
                (if (< S size)
                    (setq S (1+ S)))))

      (setq the-semaphore
            (lambda (m)
              (mutex 'acquire)
              (cond ((eq m 'acquire) (funcall P))
                    ((eq m 'release) (funcall V)))
              (mutex 'release)))

      the-semaphore))

  ; b.
  (defun make-semaphore (size)
    (lexical-let ((S size)
                  (mutex (make-mutex))
                  (cell '(nil)))

      (setq P (lambda ()
                (if (> S 0)
                    (setq S (1- S))
                  funcall V)))

      (setq V (lambda ()
                (if (< S size)
                    (setq S (1+ S)))))

      (setq the-semaphore
            (lambda (m)
              (if (test-and-set! cell)
                  (funcall the-semaphore m)
                (cond ((eq m 'acquire) (funcall P))
                      ((eq m 'release) (funcall V)))
                (clear! cell))))

      the-semaphore))
#+END_SRC

*** Exercise 3.48
#+BEGIN_SRC elisp
  ; The deadlock avoidance technique works because when the two
  ; processes try protect one of the accounts, they both will try
  ; to lock the same one, so only one process will have access to
  ; the account and the other process will have to wait until it's
  ; released.
  (defun make-account-and-serializer (b id)
    (lexical-let ((balance b)
                  (account-id id)
                  (withdraw nil)
                  (deposit nil)
                  (dispatch nil)
                  (balance-serializer (make-serializer)))
      (setq withdraw
            (lambda (amount)
              (if (>= balance amount)
                  (begin (set! balance (- balance amount))
                         balance)
                "Insufficient funds")))

      (setq deposit
           (lambda (amount)
             (set! balance (+ balance amount))
             balance))

      (setq dispatch
            (lambda (m)
              (cond ((eq? m 'withdraw) withdraw)
                    ((eq? m 'deposit) deposit)
                    ((eq? m 'balance) balance)
                    ((eq? m 'serializer) balance-serializer)
                    ((eq? m 'account-id) account-id)
                    (t (error "Unknown request -- MAKE-ACCOUNT")))))
      dispatch))

  (defun exchange (account1 account2)
    (let ((difference (- (account1 'balance)
                         (account2 'balance))))
      (funcall (funcall account1 'withdraw) difference)
      (funcall (funcall account2 'deposit) difference)))

  (defun serialized-exchange (account1 account2)
    (let ((id1 (funcall account1 'account-id))
          (id2 (funcall account2 'account-id))
          (serializer1 (funcall account1 'serializer1))
          (serializer2 (funcall account2 'serializer2))
          (my-exchange nil)

      (setq my-exchange
            (if (> id1 id2)
                (funcall serializer1 (funcall serializer2 exchange)))
            (funcall serializer2 (funcall serializer1 exchange)))

      (funcall my-exchange account1 account2))))
#+END_SRC

*** Exercise 3.49
#+BEGIN_SRC text
   ; An example are 2 concurrent sessions in a data base where
   ; the data base system can't know a-priori what resources
   ; will be requested for protection by each one of the running
   ; sessions.
   ; So session 1 can request resource A and session 2 requests
   ; a resource B, but the process in session 1 can't complete
   ; because it discovered while processing that it requires
   ; resource B in order to complete, the same happens to session 2
   ; and resource A. This is where the deadlock happens.
   ; Even if the sessions had a priority, the resources have already
   ; been taken.
#+END_SRC

*** Exercise 3.50
#+BEGIN_SRC elisp
  (defun stream-map (proc &optional argstreams)
    (lexical-let ((p proc)
                  (a argstreams))
      (if (null (car a))
          the-empty-stream
        (cons-stream
         (apply p (mapcar 'car a))
         (lambda ()
           (stream-map p (mapcar 'stream-cdr a)))))))

  ; test
  (setq p1 (make-stream '(1 2 3 4)))

  (stream-car
   (stream-cdr
    (stream-cdr
     (stream-map (lambda (x) (* x x)) (list p1))))) ; => 9

  ; test
  (stream-car
   (stream-cdr
    (stream-map '+ (list
                     (make-stream '(1 2 3))
                     (make-stream '(4 5 6))

                     (make-stream '(7 8 9)))))) => 15

  ;; Using second implementation of streams
  (defun my/stream-map (proc &optional argstreams)
    (lexical-let ((p proc)
                  (a argstreams))
      (if (null (car a))
          the-empty-stream
        (my/cons-stream (apply p (mapcar 'car a))
                        (my/stream-map p (mapcar 'my/stream-cdr a))))))

  ; test
  (my/stream-cdr
   (my/stream-cdr
    (my/stream-map '+ (list
                      (my/make-stream '(1 2 3))
                      (my/make-stream '(4 5 6))
                      (my/make-stream '(7 8 9)))))) ; => 15
#+END_SRC

*** Exercise 3.51
#+BEGIN_SRC elisp
(defun sicp-show (x)
  (insert (format "%d " x))
  x)

(setq x (stream-map 'sicp-show (stream-enumerate-interval 0 10)))

(stream-ref x 5) ; => 1 2 3 4 5 5
(stream-ref x 7) ; => 6 7

; Using the second implementation
(setq x (my/stream-map 'sicp-show (my/stream-enumerate-interval 0 10)))0
(my/stream-ref x 5) ; 1 2 3 4 5
(my/stream-ref x 7) ; 6 7
#+END_SRC

*** Exercise 3.52
#+BEGIN_SRC elisp
  (setq sicp-sum 0)

  (defun accum (x)
    (setq sicp-sum (+ x sicp-sum))
    sicp-sum)

  (defun even? (n) (= 0 (% n 2)))

  (setq sicp-seq (stream-map 'accum (stream-enumerate-interval 1 20)))
  ; sicp-sum => 1

  (setq y (stream-filter 'even? sicp-seq))
  ; sicp-sum => 6

  (setq z (stream-filter (lambda (x) (= (% x 5) 0))
                         sicp-seq))
  ; sicp-sum => 10

  (stream-ref y 7)   ; => 136
  ; sicp-sum => 136

  (display-stream z)  ; => 10 15 45 55 105 120 190 210
  ; sicp-sum => 210

  ; The result would be different without the memoizing optimization.
  ; the difference consists that when the optimization isn't in place,
  ; the`sicp-accum' will always be modified whenever `stream-cdr' is
  ; called, in contrast using momoizing then the expression will be
  ; evaluated just one.

  ; Using the second implementation
  (setq sicp-sum 0)

  (defun accum (x)
    (setq sicp-sum (+ x sicp-sum))
    sicp-sum)

  (defun even? (n) (= 0 (% n 2)))

  (setq sicp-seq (my/stream-map 'accum (my/stream-enumerate-interval 1 20)))
  ; sicp-sum => 1

  (setq y (my/stream-filter 'even? sicp-seq))
  ; sicp-sum => 6

  (setq z (my/stream-filter (lambda (x) (= (% x 5) 0))
                            sicp-seq))
  ; sicp-sum => 10

  (my/stream-ref y 7)   ; => 136
  ; sicp-sum => 136

  (my/display-stream z) ; => 10 15 45 55 105 120 190 210
  ; sicp-sum => 210
#+END_SRC

*** Exercise 3.53
#+BEGIN_SRC elisp
  (setq my/s (my/cons-stream 1 (my/add-streams my/s my/s)))
  ; 1, 2, 4, 8, 16, 32, ...
#+END_SRC

*** Exercise 3.54
#+BEGIN_SRC elisp
  (defun my/mul-streams (s1 s2)
    (my/stream-map '* (list s1 s2)))

  (my/stream-car
    (my/stream-cdr
      (my/mul-streams (my/make-stream '(1 2 3))
                      (my/make-stream '(4 5 6))))) ; => 10

  (setq my/factorials (my/cons-stream
                       1
                       (my/mul-streams (my/add-streams ones my/integers)
                                       my/factorials)) )
  (my/stream-ref my/factorials 5) ; => 720
#+END_SRC

*** Exercise 3.55
#+BEGIN_SRC elisp
  (defun my/partial-sums (s)
    (lexical-let ((stream s))
      (my/cons-stream (my/stream-car stream)
                      (my/add-streams (my/stream-cdr stream)
                                      (my/partial-sums stream)))))

  (my/stream-ref (my/partial-sums (my/make-stream '(1 2 3 4))) 3) ; => 10
#+END_SRC

*** Exercise 3.56
#+BEGIN_SRC elisp
  (defun merge (stream1 stream2)
    (lexical-let ((s1 stream1)
                  (s2 stream2))
      (cond ((stream-null? s1) s2)
            ((stream-null? s2) s1)
            (t (let ((s1car (my/stream-car s1))
                     (s2car (my/stream-car s2)))
                 (cond ((< s1car s2car)
                        (my/cons-stream s1car (merge (my/stream-cdr s1) s2)))
                       ((> s1car s2car)
                        (my/cons-stream s2car (merge s1 (my/stream-cdr s2))))
                       (t
                        (my/cons-stream s1car
                                        (merge (my/stream-cdr s1)
                                               (my/stream-cdr s2))))))))))

(setq my/S (my/cons-stream 1 (merge (my/scale-stream my/S 2)
                                    (merge (my/scale-stream my/S 3)
                                           (my/scale-stream my/S 5)))))


(defun my/first-n-elements (stream n)
  (defun iter (i)
    (cond ((>= i n) the-empty-stream)
          (t (cons (my/stream-ref stream i)
                   (iter (1+ i))))))
  (iter 0))

(my/first-n-elements my/S 10) ; => (1 2 3 4 5 6 8 9 10 12)
#+END_SRC

*** Exercise 3.57
#+BEGIN_SRC elisp
  (setq fibs
    (my/cons-stream 0
                    (my/cons-stream 1
                                    (my/add-streams (my/stream-cdr fibs)
                                                    fibs))))

  ; Using memoization, the number of additions is n-2
  ; Without the memoization the number of additions is each fib number needs to
  ; be recomputed, hence fib(n) requires fib(n-2) + fib(n-1) + 1 additions
#+END_SRC

*** Exercise 3.58
#+BEGIN_SRC elisp
  ; This procedure expands a fraction in to floating point representation
  ; each element from the streams represents an element of the expanded
  ; fraction.
  (/ 1.0 7)            ; 0.14285714285714285
  (expand 1 7 10)
  (1 (expand 3 7 10))
  (1 4 (expand 2 7 10))
  (1 4 2 (expand 6 7 10))
  (1 4 2 8 (expand 4 7 10))

  ; (/ 3.0 8)       ; 0.375
  (expand 3 8 10)
  (3 (expand 6 8 10))
  (3 7 (expand 4 8 10))
  (3 7 5 (expand 0 8 10))
  (3 7 5 0 (expand 0 8 10)) ...
#+END_SRC

*** Exercise 3.59
#+BEGIN_SRC elisp
a.
  (defun integrate-series (s)
    (my/mul-streams s (my/inverse-stream my/integers)))

  (defun my/mul-streams (s1 s2)
    (my/stream-map '* (list s1 s2)))

  (defun my/inverse-stream (s)
    (my/stream-map (lambda (x) (/ 1.0 x)) (list s)))

  (defun my/integers-starting-from (number)
    (lexical-let ((n number))
      (my/cons-stream n (my/integers-starting-from (1+ n)))))

  (setq my/integers (my/integers-starting-from 1))

  (defun my/stream-map (proc &optional argstreams)
    (lexical-let ((p proc)
                  (a argstreams))
      (if (null (car a))
          the-empty-stream
        (my/cons-stream (apply p (mapcar 'car a))
                        (my/stream-map p (mapcar 'my/stream-cdr a))))))

b.
  (setq my/exp-series
    (my/cons-stream 1 (integrate-series my/exp-series)))

  (setq my/cosine-series
    (my/cons-stream 1 (integrate-series (my/negate-stream my/sine-series))))

  (defun my/negate-stream (s)
    (my/stream-map (lambda (x) (- x)) (list s)))

  (setq my/sine-series
    (my/cons-stream 0 (integrate-series my/cosine-series)))
#+END_SRC

*** Exercise 3.60
#+BEGIN_SRC elisp
  (defun my/mul-series (stream1 stream2)
    (lexical-let ((s1 stream1)
                  (s2 stream2))
      (my/cons-stream (* (my/stream-car s1) (my/stream-car s2))
                      (my/add-streams (my/scale-stream (my/stream-cdr s2)
                                                       (my/stream-car s1))
                                      (my/mul-series (my/stream-cdr s1) s2)))))
  ; test cos^2 x + sin^2 x = 1
  (setq my/S (my/add-streams
              (my/mul-series my/cosine-series my/cosine-series)
              (my/mul-series my/sine-series my/sine-series)))

  (my/stream-ref my/S 0)
#+END_SRC

*** Exercise 3.61
#+BEGIN_SRC elisp
  (defun my/invert-unit-series (s)
    (my/cons-stream
     1 (my/scale-stream (my/mul-series (my/stream-cdr s)
                                       (my/invert-unit-series s)) -1)))
#+END_SRC

*** Exercise 3.62
#+BEGIN_SRC elisp
  (defun my/div-series (numer denom)
    ; normalize the denom series so it begins with 1
    (let* ((norm-factor (/ 1.0 (my/stream-car denom)))
           (norm-denom (my/scale-stream denom norm-factor)))
      (if (= 0 norm-factor)
          (error "Norm Factor is zero"))
      (my/scale-stream (my/mul-series numer
                                      (my/invert-unit-series norm-denom))
                       norm-factor)))

  (setq my/tan-series
        (my/div-series my/sine-series my/cosine-series))
#+END_SRC

*** Exercise 3.63
#+BEGIN_SRC elisp
; Louis' version generates a new stream object every time the `stream-map'
; list argument is evaluated, this forces evaluation of the `stream-cdr' of
; the list every time, so yes both versions still defer with or without
; the use of memoization.
#+END_SRC

*** Exercise 3.64
#+BEGIN_SRC elisp
  (defun my/stream-limit (s tolerance)
    (let ((next-s  (my/stream-cdr s)))
      (if (< (abs (- (my/stream-car s)
                     (my/stream-car next-s)))
             tolerance)
          (my/stream-car next-s)
        (my/stream-limit next-s tolerance))))

  (defun my/sqrt (x tolerance)
    (my/stream-limit (my/sqrt-stream x) tolerance))

  (my/sqrt 2.0 0.001) ; => 1.4142135623746899
#+END_SRC

*** Exercise 3.65
#+BEGIN_SRC elisp
(defun my/ln2-summands (num)
  (lexical-let ((n num))
    (my/cons-stream (/ 1.0 n)
                    (my/stream-map '- (list (my/ln2-summands (1+ n)))))))

(setq my/ln2-stream
  (my/partial-sums (my/ln2-summands 1)))

(log 2) ; => 0.6931471805599453

(setq my/ln2-first my/ln2-stream)
(my/stream-ref my/ln2-first 10) ; => 0.7365440115440116

(setq my/ln2-second
  (my/euler-transform my/ln2-stream))

(my/stream-ref my/ln2-second 10) ; => 0.6932106782106783

(setq my/ln2-third
  (my/accelerated-sequence 'my/euler-transform my/ln2-stream))

(my/stream-ref my/ln2-second 10) ; => 0.6932106782106783
#+END_SRC

*** Exercise 3.66
#+BEGIN_SRC elisp
(my/stream-ref (pairs my/integers my/integers) 0) ; (1 1)
(my/stream-ref (pairs my/integers my/integers) 1) ; (1 2)
(my/stream-ref (pairs my/integers my/integers) 2) ; (2 2)
(my/stream-ref (pairs my/integers my/integers) 3) ; (1 3)
(my/stream-ref (pairs my/integers my/integers) 4) ; (2 3)
(my/stream-ref (pairs my/integers my/integers) 5) ; (1 4)
(my/stream-ref (pairs my/integers my/integers) 6) ; (3 3)
(my/stream-ref (pairs my/integers my/integers) 7) ; (1 5)
(my/stream-ref (pairs my/integers my/integers) 8) ; (2 4)
(my/stream-ref (pairs my/integers my/integers) 9) ; (1 6)

; The (1, x) pairs are being explored intermittently every
; two iterations, so to reach the (1, 100) around 200 iterations
; must happen, (by trial 197 pairs are precede the pair).
; By observation the first element of the nth row (the pair (n, n))
; appears after 2^n - 2 pairs, then every subsequent element of the
; same row appears after 2^(n-1) pairs, so the pair (99, 100)
; will come up after (2^99-2 + 2^98) pairs and (100, 100) will come
; up after 2^100 - 2  pairs.
#+END_SRC

*** Exercise 3.67
#+BEGIN_SRC elisp
    (defun pairs2 (s t)
      (my/cons-stream
       (list (my/stream-car s) (my/stream-car t))
       (my/interleave
        (my/interleave
         (my/stream-map (lambda (x) (list (my/stream-car s) x))
                        (my/stream-cdr t))
         (pairs2 (my/stream-cdr s) (my/stream-cdr t)))
        (my/stream-map (lambda (y) (list y (my/stream-car t)))
                       (my/stream-cdr s)))))


  (my/stream-ref (pairs2 my/integers my/integers) 197) ; => (1 51)
  (my/stream-ref (pairs2 my/integers my/integers) 500) ; => (251 1)
#+END_SRC

*** Exercise 3.68
#+BEGIN_SRC elisp
  (defun pairs (s t)
    (my/interleave
     (stream-map (lambda (x) (list (stream-car s) x))
                 t)
     (pairs (stream-cdr s) (stream-cdr t))))

; This implementation has a problem that the pairs procedure
; will loop indefinitely because of the recursive call to `pairs'
#+END_SRC

*** Exercise 3.69
#+BEGIN_SRC elisp
  ; reference: https://wqzhang.wordpress.com/2009/08/22/sicp-exercise-3-69/
  (defun triples (s1 s2 s3)
    (lexical-let ((S s1)
                  (T s2)
                  (U s3))
      (my/cons-stream
       (list (my/stream-car S) (my/stream-car T) (my/stream-car U))
       (my/interleave
        (my/stream-map (lambda (x) (cons (my/stream-car S) x))
                       (pairs T (my/stream-cdr U)))
        (triples (my/stream-cdr S) (my/stream-cdr T) (my/stream-cdr U))))))

  (my/stream-ref (triples my/integers my/integers my/integers) 100) ; => (2 3 10)

  (setq my/all-triples (triples my/integers my/integers my/integers))

  (defun my/square (x) (* x x))

  (setq pythagorean-triples (my/stream-filter
                             (lambda (x) (= (my/square (caddr x))
                                            (+ (my/square (car x))
                                               (my/square (cadr x)))))
                             my/all-triples))

  ; for some reason it isn't working for indexes greater than 0
  ; maybe the mix of `defun-tco' and `lexical-let' is causing the issue.
  (my/stream-ref pythagorean-triples 0) ; =>  (3 4 5)
#+END_SRC

*** Exercise 3.70
#+BEGIN_SRC elisp
  (defun merge-weighted (stream1 stream2 w)
    (lexical-let ((s1 stream1)
                  (s2 stream2)
                  (W  w))
      (cond ((stream-null? s1) s2)
            ((stream-null? s2) s1)
            (t (let ((s1car (my/stream-car s1))
                     (s2car (my/stream-car s2)))
                 (cond ((<= (funcall W s1car) (funcall W s2car))
                        (my/cons-stream s1car
                                        (merge-weighted (my/stream-cdr s1) s2 W)))
                       ((> (funcall W s1car) (funcall W s2car))
                        (my/cons-stream s2car
                                        (merge-weighted s1 (my/stream-cdr s2) W)))))))))

  (defun weighted-pairs (s1 s2 w)
    (lexical-let ((S s1)
                  (T s2)
                  (W w))
      (my/cons-stream
       (list (my/stream-car S) (my/stream-car T))
       (merge-weighted
        (my/stream-map (lambda (x) (list (my/stream-car S) x))
                       (my/stream-cdr T))
        (weighted-pairs (my/stream-cdr S) (my/stream-cdr T) W)
        W))))

  ; a
  (setq my/S-a (weighted-pairs my/integers
                               my/integers
                               (lambda (x) (+ (car x) (cadr x)))))

  ; b
  (defun divisible-by (x n)
    (= 0 (% x n)))

  (setq not-divisible-by-2-3-5
        (my/stream-filter
         (lambda (x) (not (or (divisible-by x 2)
                              (divisible-by x 3)
                              (divisible-by x 5))))
         my/integers))

  (setq my/S-b
        (weighted-pairs not-divisible-by-2-3-5
                        not-divisible-by-2-3-5
                        (lambda (x) (+ (* 2 (car x))
                                       (* 3 (cadr x))
                                       (* 5 (car x) (cadr x))))))

#+END_SRC

*** Exercise 3.71
#+BEGIN_SRC elisp
  (defun my/cube (n) (* n n n))
  (defun my/ramanujan-weight (x)
    (+ (my/cube (car x)) (my/cube (cadr x))))

  (setq my/cubes-sorted
        (weighted-pairs my/integers
                        my/integers
                        'my/ramanujan-weight))

  (defun my/find-ramanujan (str)
    (let ((w (my/ramanujan-weight (my/stream-car str)))
          (rest (my/stream-cdr str)))
      (cond ((= w (my/ramanujan-weight (my/stream-car rest)))
             (my/cons-stream w
                             (my/find-ramanujan (my/stream-cdr rest))))
            (t
             (my/find-ramanujan rest)))))

  (setq my/ramanujan-nums
        (my/find-ramanujan my/cubes-sorted))

  (my/first-n-elements my/ramanujan-nums 6) ; => (1729 4104 13832 20683 32832 39312)
#+END_SRC

*** Exercise 3.72
#+BEGIN_SRC elisp
  (defun my/square-weight (x)
    (+ (my/square (car x))
       (my/square (cadr x))))

  (setq my/squares-sorted
        (weighted-pairs my/integers
                        my/integers
                        'my/square-weight))
  (defun my/= (x &rest args)
    (let ((l (my-flatten args)))
      (cond ((eq l nil) t)
            ((= x (car l)) (my/= (car l) (cdr l)))
            (t nil))))

  (defun my/find-squares-in-three-ways (str)
    (let* ((rest1 (my/stream-cdr str))
           (rest2 (my/stream-cdr rest1))
           (p1 (my/stream-car str))
           (p2 (my/stream-car rest1))
           (p3 (my/stream-car rest2))
           (w1 (my/square-weight (my/stream-car str)))
           (w2 (my/square-weight (my/stream-car rest1)))
           (w3 (my/square-weight (my/stream-car rest2))))
      (cond ((my/= w1 w2 w3)
             (my/cons-stream (list w1 p1 p2 p3)
                             (my/find-squares-in-three-ways (my/stream-cdr rest2))))
            (t
             (my/find-squares-in-three-ways rest1)))))

  (setq my/squares-in-three-ways-nums
        (my/find-squares-in-three-ways my/squares-sorted))

  (my/first-n-elements my/squares-in-three-ways-nums 6)
    ; ((325 (1 18) (6 17) (10 15))
    ;  (425 (5 20) (8 19) (13 16))
    ;  (650 (5 25) (11 23) (17 19))
    ;  (725 (7 26) (10 25) (14 23))
    ;  (845 (2 29) (13 26) (19 22))
    ;  (850 (3 29) (11 27) (15 25)))

#+END_SRC

*** Exercise 3.73
#+BEGIN_SRC elisp
  (defun my/RC (R C DT)
    (lexical-let ((r R)
                  (c C)
                  (dt DT))
      (lambda (i v0)
        (my/add-streams (my/scale-stream i r)
                        (my/integral (my/scale-stream i (/ 1.0 c)) v0 dt)))))

  (setq my/RC1 (my/RC 5 1 0.5))
  (my/stream-ref (funcall my/RC1 my/ones 0) 2)
#+END_SRC
*** Exercise 3.74
#+BEGIN_SRC elisp
  (defun my/sign-change-detector (val1 val2)
    (defun pos? (a) (> a 0))
    (defun neg? (a) (< a 0))
    (cond ((and (pos? val1) (neg? val2)) -1)
          ((and (neg? val1) (pos? val2)) 1)
          (t 0)))

  (defun my/make-zero-crossings (input-stream last-value)
    (lexical-let ((i-s input-stream)
                  (l-v last-value))
      (my/cons-stream
       (my/sign-change-detector l-v (my/stream-car i-s))
       (my/make-zero-crossings (my/stream-cdr i-s)
                               (my/stream-car i-s)))))

  (setq sense-data
        (my/make-stream '(1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4)))

  (setq my/zero-crossings (my/make-zero-crossings sense-data 0))
  (my/first-n-elements my/zero-crossings 12) ; => (0 0 0 0 0 -1 0 0 0 0 1 0)

  (setq my/zero-crossings2
    (my/stream-map-g 'my/sign-change-detector
                     (list sense-data (my/stream-cdr sense-data))))

  (my/first-n-elements my/zero-crossings2 12) ; (0 0 0 0 -1 0 0 0 0 1 0 0)
#+END_SRC
*** Exercise 3.75
#+BEGIN_SRC elisp
  ; The implementation is averaging the current value against
  ; the previously averaged value and not against the real value
  ; from the signal. A fix for this would be:
  (defun my/make-zero-crossings3 (input-stream last-value last-smooth)
    (lexical-let* ((i-s input-stream)
                   (l-v last-value)
                   (l-s last-smooth)
                   (avpt (/ (+ (my/stream-car i-s) l-v) 2)))
      (my/cons-stream (my/sign-change-detector l-s avpt)
                      (my/make-zero-crossings3 (my/stream-cdr i-s)
                                               (my/stream-car i-s)
                                               avpt))))

  (setq my/zero-crossings3 (my/make-zero-crossings3 sense-data 1 1))
  (my/first-n-elements my/zero-crossings3 12) ; => (0 0 0 0 0 0 -1 0 0 0 0 1)
#+END_SRC

*** Exercise 3.76
#+BEGIN_SRC elisp
  (defun my/avg (a b) (/ (+ (float a) b) 2))
  (defun my/smooth-signal (sig)
    (lexical-let ((s sig))
      (my/stream-map-g 'my/avg (list s (my/stream-cdr s)))))

  (defun my/make-zero-crossings4 (sig)
    (lexical-let ((s sig))
      (my/stream-map-g 'my/sign-change-detector (list s (my/stream-cdr s)))))

  (setq my/zero-crossings4
       (my/make-zero-crossings4 (my/smooth-signal sense-data)))

  (my/first-n-elements my/zero-crossings4 10) ; => (0 0 0 0 -1 0 0 0 0 1)
#+END_SRC

*** Exercise 3.77
#+BEGIN_SRC elisp
  (defun my/integral3 (delayed-integrand initial-value dt)
    (lexical-let ((d-i delayed-integrand)
                  (i-v initial-value)
                  (d-t dt))
      (my/cons-stream i-v
                      (let ((integrand (my/sicp-force d-i)))
                        (if (stream-null? integrand)
                            the-empty-stream
                          (my/integral3 (my/delay (my/stream-cdr integrand))
                                        (+ (* d-t (my/stream-car integrand))
                                           initial-value)
                                        dt))))))

  (defun my/solve2 (F Y0 Dt)
    (lexical-let ((f F)
                  (y0 Y0)
                  (dt Dt)
                  (y nil)
                  (dy nil))
      (setq y (my/integral3 (my/delay dy) y0 dt))
      (setq dy (my/stream-map f y))
      y))

  (my/stream-ref (my/solve2 (lambda (y) y) 1 0.001) 1000) ; 2.716923932235896
#+END_SRC

*** Exercise 3.78
#+BEGIN_SRC elisp
  (defun my/solve-2nd (A B Dt Y0 Dy0)
    (lexical-let ((a A)
                  (b B)
                  (dt Dt)
                  (dy0 Dy0)
                  (ddy nil))
                  (dy nil)
                  (y nil))
    (setq ddy (my/add-streams (my/scale-stream dy a)
                              (my/scale-stream y b)))
    (setq dy (my/integral2 (my/delay ddy) dy0 dt))
    (setq y (my/integral2 (my/delay dy) y0 dt))
    y)
#+END_SRC

*** Exercise 3.79
#+BEGIN_SRC elisp
; Help from https://wqzhang.wordpress.com/2009/09/08/sicp-exercise-3-79/
(defun my/solve-2nd-general (F Y0 Dy0 Dt)
  (lexical-let ((f F)
                (y0 Y0)
                (dy0 Dy0)
                (dt Dt)
                (dy nil)
                (y nil)))
    (setq ddy (my/stream-map-g f (list dy y)))
    (setq dy (my/integral2 (my/delay ddy) dy0 dt))
    (setq y (my/integral2 (my/delay dy) y0 dy))
    y)
#+END_SRC

*** Exercise 3.80
#+BEGIN_SRC elisp
  (defun RLC (R L C Dt)
    (lexical-let ((r R)
                  (l L)
                  (c C)
                  (dt Dt)
                  (rlc nil))
      (setq rlc (lambda (VC0 IL0)
                  (lexical-let ((di_L nil)
                                (dv_C nil)
                                (i_L nil)
                                (v_C nil))
                    (setq i_L (my/integral2 (my/delay di_L) IL0 dt))
                    (setq v_C (my/integral2 (my/delay dv_C) VC0 dt))
                    (setq di_L (my/add-streams (my/scale-stream i_L (/ (* -1.0 r) l))
                                               (my/scale-stream v_C (/ 1.0 L))))
                    (setq dv_C (my/scale-stream i_L (/ -1.0 c)))
                    (cons v_C i_L))))))

  (setq my/rlc-cirquit (funcall (RLC 1.0 1.0 0.2 0.1) 10 0))
  (setq my/rlc_Vc (car my/rlc-cirquit))
  (setq my/rlc_Ic (cdr my/rlc-cirquit))

  (my/first-n-elements my/rlc_Vc 5) ; => (10 10.0 9.5 8.55 7.220000000000001)
  (my/first-n-elements my/rlc_Ic 5) ; => (0 1.0 1.9 2.66 3.249)
#+END_SRC

*** Exercise 3.81
#+BEGIN_SRC elisp
  (setq my/random-init 1000)
  (defun my/rand-update (x) (+ 2 x))

  (setq my/random-numbers
        (my/cons-stream my/random-init
                        (my/stream-map 'my/rand-update my/random-numbers)))

  (setq my/random-numbers
        (my/cons-stream my/random-init
                        (my/stream-map 'my/rand-update my/random-numbers)))

  (defun my/random-func-generator ()
    (lexical-let ((random-stream nil)
                  (random-next
                   (lambda (s)
                     (if (eq s nil)
                         my/random-init
                       (my/stream-car (my/stream-cdr s))))))
      (lambda (arg)
        (let ((next (funcall random-next random-stream)))
          (setq random-stream
                (my/cons-stream (if (eq arg 'reset) my/random-init next)
                                (my/stream-map 'my/rand-update random-stream)))
          random-stream))))

  (setq my/random-numbers (my/random-func-generator))
  (my/stream-car (funcall my/random-numbers 'reset)) ; 1000
  (my/stream-car (funcall my/random-numbers 'gen))   ; 1002
  (my/stream-car (funcall my/random-numbers 'gen))   ; 1004
  (my/stream-car (funcall my/random-numbers 'gen))   ; 1006
  (my/stream-car (funcall my/random-numbers 'reset)) ; 1000
#+END_SRC

*** Exercise 3.82
#+BEGIN_SRC elisp
    (defun monte-carlo (experiment-stream passed failed)
      (defun next (passed failed)
        (my/cons-stream
         (/ (float passed) (+ passed failed))
         (monte-carlo
          (my/stream-cdr experiment-stream) passed failed)))
      (if (my/stream-car experiment-stream)
          (next (1+ passed) failed)
        (next passed (1+ failed))))

  (defun estimate-integral (predicate x1 x2 y1 y2)
    (lexical-let ((enclosing-area (* (- x2 x1) (- y2 y1)))
                  (random-in-range nil)
                  (experiment nil)
                  (experiment-stream nil))
      (setq random-in-range
            (lambda (n1 n2) (+ n1 (random (- n2 n1)))))
      (setq experiment
            (lambda ()
              (funcall predicate
                       (funcall random-in-range x1 x2)
                       (funcall random-in-range y1 y2))))
      (setq experiment-stream
            (lambda ()
              (my/cons-stream (funcall experiment)
                              (funcall experiment-stream))))

      (my/scale-stream (monte-carlo (funcall experiment-stream) 0 0)
                       enclosing-area)))

  (defun lays-in-circle-p (x y)
    (defun square (n) (* n n))
    (<= (+ (square (- x 5)) (square (- y 7))) (square 3)))

  ; expected area (* pi (square 3)) ; => 28.274333882308138
  (my/stream-ref (estimate-integral 'lays-in-circle-p 2 8 4 10) 200) ; => 28.47761194

  ; pi stream approximation
  (setq my/pi-stream
        (my/scale-stream (estimate-integral 'lays-in-circle-p 2 8 4 10) (/ 1.0 9)))

  (my/stream-ref my/pi-stream 200) ; => 3.1442786069651736
#+END_SRC

* Chapter 4
** 4.1
*** 4.1.1 The Core of Evaluator
#+BEGIN_SRC elisp
  ; To test these functions the definitions need to be evaluated in the
  ; correct order. The functions are being displayed more or less in the same
  ; order as in the book.
  (defun ch4/eval (exp env)
    (cond ((ch4/self-evaluating? exp) exp)
          ((ch4/variable? exp) (ch4/lookup-variable-value exp env))
          ((ch4/quoted? exp) (ch4/text-of-quotation exp))
          ((ch4/assignment? exp) (ch4/eval-assignment exp env))
          ((ch4/definition? exp) (ch4/eval-definition exp env))
          ((ch4/if? exp) (ch4/eval-if exp env))
          ((ch4/lambda? exp)
           (ch4/make-procedure (ch4/lambda-parameters exp)
                               (ch4/lambda-body exp)
                               env))
          ((ch4/begin? exp)
           (ch4/eval-sequence (ch4/begin-actions exp) env))
          ((ch4/cond? exp) (ch4/eval (ch4/cond->if exp) env))
          ((ch4/application? exp)
           (ch4/apply (ch4/eval (ch4/operator exp) env)
                      (ch4/list-of-values (ch4/operands exp) env)))
          (t
           (error "Unknown expression type %S -- EVAL" exp))))

  ; Test `ch4/eval'
  ; self-evaluating ?
  (ch4/eval 4 ch4/the-global-environment)  ; => 4

  ; definition?
  (ch4/eval '(define my-var 10) ch4/the-global-environment) ; => ok
  ch4/the-global-environment
   ; => (((my-var false true car cdr cons null\?)
   ; =>   10 false true (primitive car) (primitive cdr) (primitive cons) (primitive null)))

  (ch4/eval '(define (my-proc x) (set! my-var x)) ch4/the-global-environment) ; ok
  ch4/the-global-environment
    ; => (((my-proc false true car cdr cons null\?)
    ;      (procedure (x) ((set! my-var x)) #0) false true (primitive car)
    ;      (primitive cdr) (primitive cons) (primitive null)))

  ; if?
  (ch4/eval '(if 'true (set! my-var 1000) 'false) ch4/the-global-environment) ; => ok
  (ch4/eval 'my-var ch4/the-global-environment) ; => 1000
  (ch4/eval '(if 'false 'true (set! my-var 111)) ch4/the-global-environment) ; => ok
  (ch4/eval 'my-var ch4/the-global-environment) ; => 111

  ; lambda?
  (ch4/eval '(lambda (y) (set! my-var y)) ch4/the-global-environment)
    ; => (procedure (y) ((set! my-var y))
    ;         (((my-var my-proc false true car cdr cons null\?) 111
    ;           (procedure (x) ((set! my-var x)) #1) false true
    ;           (primitive car) (primitive cdr) (primitive cons) (primitive null))))

  ; begin?
  (ch4/eval '(begin (define my-var2 10) (set! my-var2 22)) ch4/the-global-environment) ; => ok
  (ch4/eval 'my-var2 ch4/the-global-environment) ; => 22

  ; cond?
  (ch4/eval '(cond ('false nil)
                   ('false nil)
                   (else (set! my-var2 18)
                         'ok))
            ch4/the-global-environment) ; => ok

  (ch4/eval 'my-var2 ch4/the-global-environment) ; => 18

  ; application?
  (ch4/eval '(my-proc 12) ch4/the-global-environment) ; => ok
  (ch4/eval 'my-var ch4/the-global-environment) ; => 12

  ; variable?
  (ch4/eval 'my-var ch4/the-global-environment) ; => 10

  ; quoted
  (ch4/eval '(quote (< var 10)) ch4/the-global-environment) ; => (< var 10)

  ; assignment
  (ch4/eval '(set! my-var 20) ch4/the-global-environment) ; ok
  ch4/the-global-environment
    ; => (((my-var false true car cdr cons null\?)
    ; =>   20 false true (primitive car) (primitive cdr) (primitive cons) (primitive null)))

  (defun ch4/apply (procedure arguments)
    (cond ((ch4/primitive-procedure? procedure)
           (ch4/apply-primitive-procedure procedure arguments))
          ((ch4/compound-procedure? procedure)
           (ch4/eval-sequence
            (ch4/procedure-body procedure)
            (ch4/extend-environment
             (ch4/procedure-parameters procedure)
             arguments
              (ch4/procedure-environment procedure))))
          (t
           (error "Unknown procedure type %S -- APPLY" procedure))))

  ; Test `apply'
  ; `primitive'
  (ch4/apply '(primitive cons) '(a b)) ; => (a . b)

  ; `compound'
  (ch4/eval '(my-proc 999) ch4/the-global-environment) ; => ok
  (ch4/eval 'my-var ch4/the-global-environment) ; => 999

  (defun ch4/list-of-values (exps env)
    (if (ch4/no-operands? exps)
        '()
      (cons (ch4/eval (ch4/first-operand exps) env)
            (ch4/list-of-values (ch4/rest-operands exps) env))))
  ; ; Test `list-of-values'
  (ch4/list-of-values '(cons 'a 'b) ch4/the-global-environment) ; => ((primitive cons) a b)

  (defun ch4/eval-if (exp env)
    (if (ch4/true? (ch4/eval (ch4/if-predicate exp) env))
        (ch4/eval (ch4/if-consequent exp) env)
      (ch4/eval (ch4/if-alternative exp) env)))
  ; Test `eval-if'
  (ch4/eval-if '(if 'true 'ok 'false) ch4/the-global-environment) ; => ok
  (ch4/eval-if '(if 'false 'ok 'false) ch4/the-global-environment) ; => false

  (defun ch4/eval-sequence (exps env)
    (cond ((ch4/last-exp? exps) (ch4/eval (ch4/first-exp exps) env))
          (t (ch4/eval (ch4/first-exp exps) env)
             (ch4/eval-sequence (ch4/rest-exps exps) env))))
  ; Test `test eval-sequence'
  ch4/myenv ; => (((twelve eleven four five six) 12 22 4 5 66) ((seven eight one) 7 8 11))
  (ch4/eval-sequence '((set! eleven 11) (set! one 1)) ch4/myenv) ; ok
  ch4/myenv ; => (((twelve eleven four five six) 12 11 4 5 66) ((seven eight one) 7 8 1))

  (defun ch4/eval-assignment (exp env)
    (ch4/set-variable-value! (ch4/assignment-variable exp)
                             (ch4/eval (ch4/assignment-value exp) env)
                             env)
    'ok)
  ; Test `ch4/eval-assignment'
  (ch4/eval-assignment '(set! eleven 22) ch4/myenv) ; => ok
  ch4/myenv ; (((eleven four five six) 22 4 5 66) ((seven eight one) 7 8 11))

  (defun ch4/eval-definition (exp env)
    (ch4/define-variable! (ch4/definition-variable exp)
                          (ch4/eval (ch4/definition-value exp) env)
                          env)
    'ok)
  (ch4/eval-definition '(define twelve 12)  ch4/myenv) ; => ok
  ch4/myenv ; => (((twelve eleven four five six) 12 22 4 5 66) ((seven eight one) 7 8 11))

  (defun ch4/self-evaluating? (exp)
    (cond ((numberp exp) t)
          ((stringp exp) t)
          (t nil)))
  ; Test `self-evaluating?'
  (ch4/self-evaluating? "String")           ; => t
  (ch4/self-evaluating? 4)                  ; => t
  (ch4/self-evaluating? '(some-expression)) ; => nil

  (defun ch4/variable? (exp)
    (symbolp exp))
  ; Test `variable?'
  (ch4/variable? 4)        ; =>  nil
  (ch4/variable? "string") ; => nil
  (ch4/variable? '(1 2 3)) ; => nil
  (ch4/variable? 'var)     ; => t

  ; quoted expression
  (defun ch4/quoted? (exp)
    (ch4/tagged-list? exp 'quote))
  ; Test `ch4/quoted?'
  (ch4/quoted? '(quote (expression))) ; => t
  (ch4/quoted? '(other expression)) ; => nil

  (defun ch4/text-of-quotation (exp)
    (cadr exp))
  ; Test `ch4/text-of-quotation'
  (ch4/text-of-quotation '(quote (expression))) ; (expression)

  (defun ch4/tagged-list? (exp tag)
    (if (consp exp)
        (eq (car exp) tag)
      nil))
  ; Test `tagged-list?'
  (ch4/tagged-list? 4 'tag)          ; => nil
  (ch4/tagged-list? '(1 2) 'tag)     ; => nil
  (ch4/tagged-list? '(tag 1 2) 'tag) ; => t

  ;; Assignment expression
  (defun ch4/assignment? (exp)
    (ch4/tagged-list? exp 'set!))
  ; Test `assignment?'
  (ch4/assignment? '(set! variable value)) ; => t
  (ch4/assignment? '(not-set! variable))   ; => nil

  (defun ch4/assignment-variable (exp)
    (cadr exp))
  ; Test `assignment-variable'
  (ch4/assignment-variable '(set! variable value)) ; => variable

  (defun ch4/assignment-value (exp)
    (caddr exp))
  ; Test `assignment-variable'
  (ch4/assignment-value '(set! variable value)) ; => value

  ;; Definition expression
  (defun ch4/definition? (exp)
    (ch4/tagged-list? exp 'define))
  ; Test `definition?'
  (ch4/definition? '(define some-value '())) ; => t
  (ch4/definition? '(defun some-value '()))  ; => nil

  (defun ch4/definition-variable (exp)
    (if (symbolp (cadr exp))
        (cadr exp)
      (caadr exp)))
  ; Test `definition-variable'
  (ch4/definition-variable '(define (some-function params) (definition))) ; => some-function
  (ch4/definition-variable '(define some-variable (definition))) ; => some-variable

  (defun ch4/make-lambda (parameters body)
    (cons 'lambda (cons parameters body)))
  ; Test `make-lambda'
  (ch4/make-lambda '(p1 p2 p3) '(a1 a1 a3)) ; => (lambda (p1 p2 p3) a1 a1 a3)

  (defun ch4/definition-value (exp)
    (if (symbolp (cadr exp))
        (caddr exp)
      (ch4/make-lambda (cdadr exp)     ; parameters
                       (cddr exp))))   ; body
  ; Test `definition-value'
  (ch4/definition-value '(define (some-function p1 p2 p3) d1 d2 d3))
   ; => (lambda (p1 p2 p3) d1 d2 d3)
  (ch4/definition-value '(define some-variable (definition))) ; => (definition)

  ;; Lambda expression
  (defun ch4/lambda? (exp)
    (ch4/tagged-list? exp 'lambda))
  ; Test `lambda?'
  (ch4/lambda? '(lambda (p1 p2 p3) b1 b2 b3))     ; => t
  (ch4/lambda? '(not-lambda (p1 p2 p3) b1 b2 b3)) ; => nil

  (defun ch4/lambda-parameters (exp)
    (cadr exp))
  ; Test `lambda-parameters'
  (ch4/lambda-parameters '(lambda (p1 p2 p3) b1 b2 b3)) ; => (p1 p2 p3)

  (defun ch4/lambda-body (exp)
    (cddr exp))
  ; Test `lambda-body'
  (ch4/lambda-body '(lambda (p1 p2 p3) b1 b2 b3)) ; => (b1 b2 b3)

  ;; if expression
  (defun ch4/if? (exp)
    (ch4/tagged-list? exp 'if))
  ; Test `if?'
  (ch4/if?  '(if predicate something else-something)) ; => t
  (ch4/if?  '(not-if predicate something else-something)) ; => nil

  (defun ch4/if-predicate (exp)
    (cadr exp))
  ; Test `if-predicate'
  (ch4/if-predicate '(if predicate something else-something)) ; => predicate
  (ch4/if-predicate '(if (eq 0 var) something else-something)) ; => (eq 0 var)

  (defun ch4/if-consequent (exp)
    (caddr exp))
  ; Test `if-consequent'
  (ch4/if-consequent '(if predicate something else-something)) ; => something
  (ch4/if-consequent '(if (eq 0 var) (insert "zero") else-something))
    ; => (insert "zero")

  (defun ch4/if-alternative (exp)
    (if (not (null (cadddr exp)))
        (if (ch4/last-exp? (cdddr exp))
            (cadddr exp)
          (cdddr exp))
      'false))
  ; Test `if-alternative'
  (ch4/if-alternative '(if predicate something else-something)) ; => else-something
  (ch4/if-alternative '(if (eq 0 var) (insert 0))) ; => false
  (ch4/if-alternative '(if (eq 0 var)
                           (insert "zero")
                         (insert "value not zero")
                         0)) ; => ((insert "value not zero") 0)

  (defun ch4/make-if (predicate consequent alternative)
    (list 'if predicate consequent alternative))

  ; Test `make-if'
  (ch4/make-if '(eq 0 var) '(insert "zero") 0)    ; => (if (eq 0 var) (insert "zero") 0)
  (ch4/make-if '(eq 0 var) '(insert "zero") nil)  ; => (if (eq 0 var) (insert "zero") nil)
  (ch4/make-if '(eq 0 var) '(insert "zero") '((insert "not zero") 0))
    ; => (if (eq 0 var) (insert "zero") ((insert "not zero") 0))

  ;; Begin form
  (defun ch4/begin? (exp)
    (ch4/tagged-list? exp 'begin))
  ; Test `begin?'
  (ch4/begin? '(begin b1 b2)) ; => t
  (ch4/begin? '(not-begin b1 b2)) ; => nil

  (defun ch4/begin-actions (exp)
    (cdr exp))
  ; Test `begin-actions'
  (ch4/begin-actions '(begin (set! one 1) (set! two 2))) ; => ((set! one 1) (set! two 2))

  (defun ch4/last-exp? (seq)
    (null (cdr seq)))
  ; Test `last-exp?'
  (ch4/last-exp? '(s1 s2 s3)) ; => nil
  (ch4/last-exp? '(s1)) ; => t

  (defun ch4/first-exp (seq)
    (car seq))
  ; Test `first-exp'
  (ch4/first-exp '(s1 s2 s3)) ; => s1

  (defun ch4/rest-exps (seq)
    (cdr seq))
  ; Test `ch4/rest-exps'
  (ch4/rest-exps '(s1 s2 s3)) ; => (s2 s3)

  (defun ch4/sequence->exp (seq)
    (cond ((null seq) seq)
          ((ch4/last-exp? seq) (ch4/first-exp seq))
          (t (ch4/make-begin seq))))
  ; Test `sequence->exp'
  (ch4/sequence->exp '((insert "hello") one true)) ; => (begin (insert "hello") one true)
  (ch4/sequence->exp nil) ; => nil
  (ch4/sequence->exp '((insert "hello"))) ; => (insert "hello")

  (defun ch4/make-begin (seq)
    (cons 'begin seq))
  ; Test `make-begin'
  (ch4/make-begin '(l1))    ; => (begin l1)
  (ch4/make-begin '(l1 l2)) ; => (begin l1 l2)

  ;; application expression
  (defun ch4/application? (exp)
    (consp exp))
  ; Test `application?'
  (ch4/application? '(some-func param)) ; => t
  (ch4/application? '1) ; => nil

  (defun ch4/operator (exp)
    (car exp))
  ; Test `operator'
  (ch4/operator '(some-func parame)) ; => some-func

  (defun ch4/operands (exp)
    (cdr exp))
  ; Test `operands'
  (ch4/operands '(some-func p1 p2 p3)) ; => (p1 p2 p3)
  (ch4/operands '(some-func p1)) ; => (p1)

  (defun ch4/no-operands? (ops)
    (null ops))
  ; Test `no-operands?'
  (ch4/no-operands? ()) ; => t
  (ch4/no-operands? '(op1 op2)) ; => nil

  (defun ch4/first-operand (ops)
    (car ops))
  ; Test `first-operand'
  (ch4/first-operand '(op1 op2)) ; => op1

  (defun ch4/rest-operands (ops)
    (cdr ops))
  ; Test `rest-operands'
  (ch4/rest-operands '(op1 op2)) ; => (op2)

  ;; cond expression
  (defun ch4/cond? (exp)
    (ch4/tagged-list? exp 'cond))
  ; Test `cond?'
  (ch4/cond? '(cond (clause1) (clause2))) ; => t
  (ch4/cond? '(not-cond (clause1) (clause2))) ; => nil

  (defun ch4/cond-clauses (exp)
    (cdr exp))
  ; Test `cond-clauses'
  (ch4/cond-clauses '(cond (clause1) (clause2))) ; => ((clause1) (clause2))

  (defun ch4/cond-else-clause? (clause)
    (eq (ch4/cond-predicate clause) 'else))
  ; Test `cond-else-clause?'
  (ch4/cond-else-clause? '(else actions))   ; => t
  (ch4/cond-else-clause? '(clause actions)) ; => nil

  (defun ch4/cond-predicate (clause)
    (car clause))
  ; Test `cond-predicate'
  (ch4/cond-predicate '((< var 0) (insert "negative"))) ; => (< var 0)

  (defun ch4/cond-actions (clause)
    (cdr clause))
  ; Test `cond-actions'
  (ch4/cond-actions '((< var 0) (insert "negative") (insert "other action")))
    ; => ((insert "negative") (insert "other action"))

  (defun ch4/cond->if (exp)
    (ch4/expand-clauses (ch4/cond-clauses exp)))
  ; Test `ch4/cond->if'
  (ch4/cond->if '(cond ((> var 0) (insert "clause1"))
                       ((< var 0)  (insert "clause 2"))
                       ((eq var 0) (insert "clause 3"))
                       (else (insert "clause else"))))
    ;; => (if (> var 0)
    ;;        (insert "clause1")
    ;;      (if (< var 0)
    ;;          (insert "clause 2")
    ;;        (if (eq var 0)
    ;;            (insert "clause 3")
    ;;          (insert "clause else"))))

  (defun ch4/expand-clauses (clauses)
    (if (null clauses)
        'false                         ; no `else' clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (ch4/cond-else-clause? first)
            (if (null rest)
                (ch4/sequence->exp (ch4/cond-actions first))
              (error "ELSE clause isn't last %S -- COND->IF" clauses))
          (ch4/make-if (ch4/cond-predicate first)
                       (ch4/sequence->exp (ch4/cond-actions first))
                       (ch4/expand-clauses rest))))))
  ; Test `expand-clauses'
  (ch4/expand-clauses '(((> var 0) (insert "clause1"))
                        ((< var 0)  (insert "clause 2"))
                        ((eq var 0) (insert "clause 3"))
                        (else (insert "clause else"))))

  ; => (if (> var 0)
  ;        (insert "clause1")
  ;      (if (< var 0)
  ;          (insert "clause 2")
  ;        (if (eq var 0)
  ;            (insert "clause 3")
  ;          (insert "clause else"))))

  (ch4/expand-clauses '(((> var 0)
                         (insert "clause1")
                         (insert "b1"))
                        ((< var 0)
                         (insert "clause 2")
                         (insert "b2"))
                        (else
                         (insert "clause else")
                         (insert "b3"))))
  ; => (if (> var 0)
  ;        (begin (insert "clause1")
  ;               (insert "b1"))
  ;      (if (< var 0)
  ;          (begin (insert "clause 2")
  ;                 (insert "b2"))
  ;        (begin (insert "clause else")
  ;               (insert "b3"))))

#+END_SRC

*** 4.1.3 Evaluator Data Structures
#+BEGIN_SRC elisp
   ; Testing of predicates
  (defun ch4/true? (x)
    (not (ch4/false? x)))
  ; Test `ch4/true?'
  (ch4/true? 'true)   ; => t
  (ch4/true? 'false)  ; => nil

  (defun ch4/false? (x)
    (eq x 'false))
  ; Test `ch4/false?'
  (ch4/false? 'false)  ; => t
  (ch4/false? 'true)   ; => nil

  ; Representing procedures
  (defun ch4/make-procedure (parameters body env)
    (list 'procedure parameters body env))
  ; Test `ch4/make-procedure'
  (ch4/make-procedure '(p1 p2 p3) '(b1 b2 b3) 'env)
    ; => (procedure (p1 p2 p3) (b1 b2 b3) env)

  (defun ch4/compound-procedure? (p)
    (ch4/tagged-list? p 'procedure))
  ; Test `compound-procedure'
  (ch4/compound-procedure? (ch4/make-procedure '(p1 p2 p3) '(b1 b2 b3) 'env)) ; => t
  (ch4/compound-procedure? '(something-else)) ; => nil

  (defun ch4/procedure-parameters (p) (cadr p))
  ; Test `procedure-parameters'
  (ch4/procedure-parameters (ch4/make-procedure '(p1 p2 p3) '(b1 b2 b3) 'env))
    ; => (p1 p2 p3)

  (defun ch4/procedure-body (p) (caddr p))
  ; Test `procedure-body'
  (ch4/procedure-body (ch4/make-procedure '(p1 p2 p3) '(b1 b2 b3) 'env))
    ; => (b1 b2 b3)

  (defun ch4/procedure-environment (p) (cadddr p))
  ; Test `procedure-environment'
  (ch4/procedure-environment (ch4/make-procedure '(p1 p2 p3) '(b1 b2 b3) 'env))
   ; => env

  ; environment operation
  (setq vars1 '(seven eight one))
  (setq vals1 '(7 8 1))
  (setq vars2 '(four five six))
  (setq vals2 '(4 5 6))
  (setq ch4/myenv (ch4/extend-environment vars1 vals1 ch4/the-empty-environment))
  (setq ch4/myenv (ch4/extend-environment vars2 vals2 ch4/myenv))

  (setq ch4/the-empty-environment '())

  (defun ch4/enclosing-environment (env) (cdr env))
  ; Test `enclosing-environment'
  (ch4/enclosing-environment ch4/myenv)  ; => (((seven eight one) 7 8 1))

  (defun ch4/first-frame (env) (car env))
  ; Test `ch4/first-frame'
  (ch4/first-frame ch4/myenv) ; => ((four five six) 4 5 6)

  (defun ch4/make-frame (variables values)
    (cons variables values))
  ; Test `make-frame'
  (ch4/make-frame '(var1 var2) '(val1 val2)) ; => ((var1 var2) val1 val2)

  (defun ch4/frame-variables (frame) (car frame))
  ; Test `frame-variables'
  (ch4/frame-variables (ch4/make-frame '(var1 var2) '(val1 val2))) ; =>  (var1 var2)

  (defun ch4/frame-values (frame) (cdr frame))
  ; Test `frame-values'
  (ch4/frame-values (ch4/make-frame '(var1 var2) '(val1 val2))) ; => (val1 val2)

  (defun ch4/add-binding-to-frame! (var val frame)
    (setcar frame (cons var (car frame)))
    (setcdr frame (cons val (cdr frame))))
  ; Test `add-binding-to-frame'
  (setq ch4/myframe (ch4/make-frame '(var1 var2) '(val1 val2))) ; => ((var1 var2) val1 val2)
  (ch4/add-binding-to-frame! 'var3 0 ch4/myframe)
  ch4/myframe ; => ((var3 var1 var2) 0 val1 val2)

  (defun ch4/extend-environment (vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (ch4/make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied %S %S" vars vals)
        (error "Too few arguments supplied" vars vals))))
  ; Test `extend-environment'
  (setq vars5 '(one two three))
  (setq vals5 '(10 2 3))
  (ch4/extend-environment vars5 vals5 ch4/myenv)
   ; =>  (((one two three) 10 2 3) ((four five six) 4 5 6) ((seven eight one) 7 8 1))


  (defun ch4/lookup-variable-value (var env)
    (defun ch4/env-loop (env)
      (defun ch4/scan (vars vals)
        (cond ((null vars)
               (ch4/env-loop (ch4/enclosing-environment env)))
              ((eq var (car vars))
               (car vals))
              (t (ch4/scan (cdr vars) (cdr vals)))))
      (if (eq env ch4/the-empty-environment)
          (error "Unbound variable %S" var)
        (let ((frame (ch4/first-frame env)))
          (ch4/scan (ch4/frame-variables frame)
                    (ch4/frame-values frame)))))
    (ch4/env-loop env))
  ; Test `ch4/lookup-variable-value'
  (ch4/lookup-variable-value 'one (ch4/extend-environment vars5 vals5 ch4/myenv))
   ; => 10
  (ch4/lookup-variable-value 'one  ch4/myenv) ; => 1
  (ch4/lookup-variable-value 'five (ch4/extend-environment vars5 vals5 ch4/myenv))
   ; => 5

  (defun ch4/set-variable-value! (var val env)
    (defun ch4/env-loop (env)
      (defun ch4/scan (vars vals)
        (cond ((null vars)
               (ch4/env-loop (ch4/enclosing-environment env)))
              ((eq var (car vars))
               (setcar vals val))
              (t (ch4/scan (cdr vars) (cdr vals)))))
      (if (eq env ch4/the-empty-environment)
          (error "Unbound variable -- %S SET!" var)
        (let ((frame (ch4/first-frame env)))
          (ch4/scan (ch4/frame-variables frame)
                    (ch4/frame-values frame)))))
    (ch4/env-loop env))
  ; Test `set-variable-value!'
  (ch4/set-variable-value! 'one 11 ch4/myenv)
  (ch4/set-variable-value! 'six 66 ch4/myenv)
  ch4/myenv ; (((four five six) 4 5 66) ((seven eight one) 7 8 11))

  (defun ch4/define-variable! (var val env)
    (let ((frame (ch4/first-frame env)))
      (defun ch4/scan-vars (vars vals)
        (cond ((null vars)
               (ch4/add-binding-to-frame! var val frame))
              ((eq var (car vars))
               (setcar vals val))
              (t (ch4/scan-vars (cdr vars) (cdr vals)))))
      (ch4/scan-vars (ch4/frame-variables frame)
                     (ch4/frame-values frame))))
  ; Test `define-variable!'
  (ch4/define-variable! 'eleven 11 ch4/myenv)
  ch4/myenv ; => (((eleven four five six) 11 4 5 66) ((seven eight one) 7 8 11))
#+END_SRC

*** 4.1.4 Running the Evaluator as a Program
#+BEGIN_SRC elisp
   (defun ch4/setup-environment ()
     (let ((initial-env
            (ch4/extend-environment (ch4/primitive-procedure-names)
                                    (ch4/primitive-procedure-objects)
                                    ch4/the-empty-environment)))
       (ch4/define-variable! 'true 'true initial-env)
       (ch4/define-variable! 'false 'false initial-env)
       initial-env))

  (setq ch4/the-global-environment (ch4/setup-environment))

  (defun ch4/primitive-procedure? (proc)
    (ch4/tagged-list? proc 'primitive))
  ; Test `primitive-procedure?'
  (ch4/primitive-procedure? '(primitive car)) ; => t
  (ch4/primitive-procedure? '(not-primitive car)) ; => nil

  (defun ch4/primitive-implementation (proc) (cadr proc))
  ; Test `primitive-implementation'
  (ch4/primitive-implementation '(primitive car)) ; => car

  (setq ch4/primitive-procedures
        (list (list 'car    'car)
              (list 'cdr    'cdr)
              (list 'cons   'cons)
              (list 'null?  'null)
              (list 'minus  '-)
              (list 'plus   '+)
              (list 'times  '*)
              (list 'gt     '>)
              (list 'lt     '<)
              (list 'equals '=)
              ;; More primitives here
              ))

  (defun ch4/primitive-procedure-names ()
    (mapcar 'car ch4/primitive-procedures))

  (defun ch4/primitive-procedure-objects ()
    (mapcar (lambda (proc) (list 'primitive (cadr proc)))
            ch4/primitive-procedures))

  (setq ch4/apply-in-underlying-lisp 'apply)

  (defun ch4/apply-primitive-procedure (proc args)
    (funcall ch4/apply-in-underlying-lisp
      (ch4/primitive-implementation proc)
      args))
  ; Test `apply-primitive-procedure'
  (ch4/apply-primitive-procedure '(primitive cons) '(one two))
    ; => (one . two)

  (setq ch4/input-prompt ";;; M-Eval input: ")
  (setq ch4/output-prompt ";;; M-Eval value: ")

  ; Adjust to work under an elisp buffer, using the minibuffer to read
  ; the user input
  (defun ch4/driver-loop ()
    (let ((input (car (read-from-string (read-string ch4/input-prompt)))))
      (let ((output (ch4/eval input ch4/the-global-environment)))
        (ch4/announce-output ch4/output-prompt)
        (ch4/user-print output)))
    (ch4/driver-loop))

  (defun ch4/prompt-for-input (string)
    (insert string))

  (defun ch4/announce-output (string)
    (insert string))

  (defun ch4/user-print (object)
    (if (ch4/compound-procedure? object)
        (insert (format "%S" (list 'compound-procedure
                                   (ch4/procedure-parameters object)
                                   (ch4/procedure-body object)
                                   '<procedure-env>)))
      (insert (format "%S\n" object))))

  (ch4/eval '(define (map fun lst)
               (if (null? lst)
                   '()
                 (cons (fun (car lst)) (map fun (cdr lst)))))
            ch4/the-global-environment) ; => ok

  (ch4/eval '(plus 1 2) ch4/the-global-environment) ; => 3

  ; Pending to find out what's wrong when evaluating this compound procedure
  (ch4/eval '(map (lambda (x) (plus 1 x)) '(1 2 3 4))
            ch4/the-global-environment) ; => nil
#+END_SRC

*** 4.1.7 Separating Syntactic Analysis from Execution
#+BEGIN_SRC elisp
  (defun ch4/eval (exp env)
    (funcall (analyze exp) env))

  (defun ch4/analyze (exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluationg exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((application? exp) (analyze-application exp))
          (t (error "Unknown expression type -- ANALYZE %S" exp))))

  (defun ch4/analyze-self-evaluating (exp)
    (lambda (env) exp))

  (defun ch4/analyze-quoted (exp)
    (lexical-let ((qval (ch4/text-of-quotation exp)))
      (lambda (env) qval)))

  (defun ch4/analyze-variable (exp)
    (lambda (env) (ch4/lookup-variable-value exp env)))

  (defun ch4/analyze-assignment (exp)
    (lexical-let ((var (ch4/assignment-variable exp))
                  (vproc (ch4/analyze (ch4/assignment-value exp))))
      (lambda (env)
        (ch4/set-variable-value! var (funcall vproc env) env)
        'ok)))

  (defun ch4/analyze-definition (exp)
    (let ((var (ch4/definition-variable exp))
          (vproc (ch4/analyze (ch4/definition-value exp))))
      (lambda (env)
        (ch4/define-variable! var (funcall vproc env) env)
        'ok)))

  (defun ch4/analyze-if (exp)
    (let ((pproc (ch4/analyze (ch4/if-predicate exp)))
          (cproc (ch4/analyze (ch4/if-consequent exp)))
          (aproc (ch4/analyze (ch4/if-alternative exp))))
      (lambda (env)
        (if (true? (funcall pproc env))
            (funcall cproc env)
          (funcall aproc env)))))

  (defun ch4/analyze-sequence (exps)
    (defun sequentially (proc1 proc2)
      (lambda (env) (funcall proc1 env) (funcall proc2 env)))
    (defun loop (first-proc rest-procs)
      (if (null rest-procs)
          first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
    (let ((procs (mapcar 'ch4/analyze exps)))
      (if (null? procs)
          (error "Empty Sequence -- ANALYZE"))
      (loop (car procs) (cdr procs))))

  (defun ch4/analyze-application (exp)
    (let ((fproc (ch4/analyze (ch4/operator exp)))
          (aprocs (mapcar 'ch4/analyze (ch4/operands exp ))))
      (lambda (env)
        (ch4/execute-application (funcall fproc env)
                                 (mapcar (lambda (aproc) (funcall aproc env))
                                         (aprocs))))))

  (defun ch4/execute-application (proc args)
    (cond ((ch4/primitive-procedure? proc)
           (ch4/apply-primitive-procedure proc args))
          ((ch4/compound-procedure? proc)
           (funcall (ch4/procedure-body proc)
                    (ch4/extend-environment (ch4/procedure-parameters proc)
                                            args
                                            (ch4/procedure-environment proc))))
          (t (error "Unknown procedure type -- EXECUTE-APPLICATION %S" proc))))

    ;; in ch4/analyze add the following line
    ((let-exp? exp) (analyze (ex4.6/let->combination exp) env))
#+END_SRC

** 4.2 Variations on a Scheme - Lazy Evaluation
*** 4.2.2 An interpreter with Lazy Evaluation
#+BEGIN_SRC elisp
    ; This section in `eval'
    ((ch4/application? exp)
     (ch4/apply (ch4/eval (ch4/operator exp) env)
                (ch4/list-of-values (ch4/operands exp) env)))

    ; Is changed into:
    ((ch4/applicaton? exp)
     (ch4/apply (ch4/actual-value (ch4/operator exp) env)
                (ch4/operands exp) env))

  (defun ch4/eval (exp env)
    (cond ((ch4/self-evaluating? exp) exp)
          ((ch4/variable? exp) (ch4/lookup-variable-value exp env))
          ((ch4/quoted? exp) (ch4/text-of-quotation exp))
          ((ch4/assignment? exp) (ch4/eval-assignment exp env))
          ((ch4/definition? exp) (ch4/eval-definition exp env))
          ((ch4/if? exp) (ch4/eval-if exp env))
          ((ch4/lambda? exp)
           (ch4/make-procedure (ch4/lambda-parameters exp)
                               (ch4/lambda-body exp)
                               env))
          ((ch4/begin? exp)
           (ch4/eval-sequence (ch4/begin-actions exp) env))
          ((ch4/cond? exp) (ch4/eval (ch4/cond->if exp) env))
          ((ch4/application? exp)
           (ch4/apply (ch4/actual-value (ch4/operator exp) env)
                      (ch4/operands exp) env))
          (t
           (error "Unknown expression type %S -- EVAL" exp))))

    (defun ch4/actual-value (exp env)
      (ch4/force-it (ch4/eval exp env)))

    (defun ch4/apply (procedure arguments env)
      (cond ((ch4/primitive-procedure? procedure)
             (ch4/apply-primitive-procedure
              procedure
              (ch4/list-of-arg-values arguments env)))
            ((ch4/compound-procedure? procedure)
             (ch4/eval-sequence
              (ch4/procedure-body procedure)
              (ch4/extend-environment
               (ch4/procedure-parameters procedure)
               (ch4/list-of-delayed-args arguments env)
               (ch4/procedure-environment procedure))))
            (t
             (error "Unknown procedure type %S -- APPLY" procedure))))

    (defun ch4/list-of-arg-values (exps env)
      (if (ch4/no-operands? exps)
          '()
        (cons (ch4/actual-value (ch4/first-operand exps) env)
              (ch4/list-of-arg-values (ch4/rest-operands exps)
                                      env))))

    (defun ch4/list-of-delayed-args (exps env)
      (if (ch4/no-operands? exps)
          '()
        (cons (ch4/delay-it (ch4/first-operand exps) env)
              (ch4/list-of-delayed-args (ch4/rest-operands exps)
                                        env))))

    (defun ch4/eval-if (exp env)
      (if (ch4/actual-value (ch4/if-predicate exp) env)
          (ch4/eval (ch4/if-consequent exp) env)
        (ch4/eval (ch4/if-alternative exp) env)))

    (defun ch4/input-prompt ";;; L-Eval input:")
    (defun ch4/output-prompt ";;; L-Eval value:")

    ; Adjust to work under an elisp buffer, using the minibuffer to
    ; read the user input
    (defun ch4/driver-loop ()
      (let ((input (car (read-from-string (read-string ch4/input-prompt)))))
        (let ((output (ch4/actual-value input ch4/the-global-environment)))
          (ch4/announce-output ch4/output-prompt)
          (ch4/user-print output)))
      (ch4/driver-loop))

  ;; ------------------- ;;
  ;; Representing Thunks ;;
  ;; ------------------- ;;
  (defun ch4/force-it (obj)
    (if (ch4/thunk? obj)
        (ch4/actual-value (ch4/thunk-exp obj) (ch4/thunk-env obj))
      obj))

  (defun ch4/delay-it (exp env)
    (list 'thunk exp env))

  (defun ch4/thunk? (obj)
    (ch4/tagged-list? obj 'thunk))

  (defun ch4/thunk-exp (thunk)
    (cadr thunk))

  (defun ch4/thunk-env (thunk)
    (caddr thunk))

  (defun ch4/evaluated-thunk? (obj)
    (ch4/tagged-list? obj 'evaluated-thunk))

  (defun ch4/thunk-value (evaluated-thunk)
    (cadr evaluated-thunk))

  (defun ch4/force-it (obj)
    (cond ((ch4/thunk? obj)
           (let ((result (ch4/actual-value
                          (ch4/thunk-exp obj)
                          (ch4/thunk-env obj))))
             (setcar obj 'evaluated-thunk)
             (setcar (cdr obj) result)
             (setcdr (cdr obj) '())
             result))
          ((ch4/evaluated-thunk? obj)
           (ch4/thunk-value obj))
          (t obj)))
#+END_SRC

*** 4.2.3 Streams as Lazy lists
#+BEGIN_SRC elisp
  (defun ch4/cons (x y)
    (lexical-let ((p x) (q y))
      (lambda (m) (funcall m p q))))

  (defun ch4/car (z) (funcall z (lambda (x y) x)))
  (defun ch4/cdr (z) (funcall z (lambda (x y) y)))

  ; A few tests
  (ch4/car (ch4/cons 'a 'b)) ; => a
  (ch4/cdr (ch4/cons 'a nil)) ; => nil

  (ch4/car (ch4/cons 'a '(b c d))) ; => a
  (ch4/cdr (ch4/cons 'a '(b c d))) ; => (b c d)

  ; Build a list
  (setq my/list (ch4/cons 10 (ch4/cons 20 (ch4/cons 30 (ch4/cons 40 nil)))))

  (defun ch4/list-ref (items n)
    (if (= n 0)
        (ch4/car items)
      (ch4/list-ref (ch4/cdr items) (1- n))))

  (ch4/list-ref my/list 2) ; => 30

  (defun ch4/map (proc items)
    (if (null items)
        '()
      (ch4/cons (funcall proc (ch4/car items))
               (ch4/map proc (ch4/cdr items)))))

  (ch4/list-ref (ch4/map '1+ my/list) 3) ; => 41

  (defun ch4/scale-list (items factor)
    (ch4/map (lambda (x) (* x factor)) items))

  (ch4/list-ref (ch4/scale-list my/list 3) 2) ; => 90

  (defun ch4/add-lists (list1 list2)
    (cond ((null list1) list2)
          ((null list2) list1)
          (t (ch4/cons (+ (ch4/car list1) (ch4/car list2))
                       (ch4/add-lists (ch4/cdr list1) (ch4/cdr list2))))))

  (setq my/list2 (ch4/cons 1 (ch4/cons 2 (ch4/cons 3 (ch4/cons 4 nil)))))

  (ch4/list-ref (ch4/add-lists my/list my/list2) 1) ; => 22
#+END_SRC

** 4.3 Variations on a Scheme - Nondeterministic Computing
#+BEGIN_SRC elisp
(defun ch4/prime-sum-pair (list1 list2)
  (let ((a (ch4/an-element-of list1))
        (b (ch4/an-element-of list2)))
    (ch4/require (ch4/prime? (+ a b)))
    (list a b)))

(defun ch4/require (p)
  (if (not p) (amb)))

(defun ch4/an-element-of (items)
  (require (not (null? items)))
  (ch4/amb (car items) (ch4/an-element-of (cdr items))))
#+END_SRC
*** 4.3.2 Examples of Nondeterministic Programs
#+BEGIN_SRC elisp
  (defun ch4/distinct? (items)
    (cond ((null items) t)
          ((null (cdr items)) t)
          ((member (car items) (cdr items)) 'nil)
          (t (distinct (cdr items)))))

  (defun ch4/multiple-dwelling ()
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (ch4/require
       (ch4/distinct? (list baker cooper fletcher miller smith)))
      (ch4/require (not (= baker 5)))
      (ch4/require (not (= cooper 1)))
      (ch4/require (not (= fletcher 5)))
      (ch4/require (not (= fletcher 1)))
      (ch4/require (> miller cooper))
      (ch4/require (not (= (abs (- smith fletcher)) 1)))
      (ch4/require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smit))))
#+END_SRC

**** Parsing natural language
#+BEGIN_SRC elisp
(setq ch4/nouns '(noun student professor cat class))
(setq ch4/verbs '(verb studies lectures eats sleeps))
(setq ch4/articles '(article the a))
(setq ch4/prepositions '(prep for to in by with))

(defun ch4/parse-sentence ()
  (list 'sentence
        (ch4/parse-noun-phrase)
        (ch4/parse-verb-phrase)))

(defun ch4/parse-simple-noun-phrase ()
  (list 'simple-noun-phrase
        (ch4/parse-word articles)
        (ch4/parse-word nouns)))

(defun ch4/parse-noun-phrase ()
  (defun ch4/maybe-extend-2 (noun-phrase)
    (ch4/amb noun-phrase
             (ch4/maybe-extend-2 (list 'noun-phrase
                                      noun-phrase
                                      (ch4/parse-prepositional-phrase)))))
  (ch4/maybe-extend-2 (parse-simple-noun-phrase)))

(defun ch4/parse-prepositional-phrase ()
  (list 'prep-phrase
        (ch4/parse-word prepositions)
        (ch4/parse-noun-phrase)))

(defun ch4/parse-verb-phrase ()
  (defun ch4/maybe-extend (verb-phrase)
    (ch4/amb verb-phrase
             (ch4/maybe-extend (list 'verb-phrase
                                     verb-phrase
                                     (parse-prepositional-phrase)))))
  (ch4/maybe-extend (parse-word verbs)))

(defun ch4/parse-word (word-list)
  (ch4/require (not (null *unparsed*)))
  (ch4/require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (setq *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))


(setq *unparsed* '())

(defun parse (input)
  (setq *unparsed* input)
  (let ((sent (ch4/parse-sentence)))
    (ch4/require (null *unparsed*))
    sent))
#+END_SRC

*** 4.3.3 Implementing the `Amb' Evaluator
#+BEGIN_SRC elisp
  (defun ch4/amb? (exp)
    (ch4/tagged-list? exp 'amb))

  (defun ch4/amb-choices (exp)
    (cdr exp))

  ; add this in the analyze procedure
  ((ch4/amb? exp) (ch4/analyze-amb exp))

  (defun ch4/ambeval (exp env succeed fail)
    (funcall (ch4/analyze exp) env succeed fail))

  (defun analyze-self-evaluating (exp)
    (lambda (env succeed fail)
      (funcall succeed exp fail)))

  (defun analyze-quoted (exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env succeed fail)
        (funcall succeed qval fail))))

  (defun analyze-variable (exp)
    (lambda (env succeed fail)
      (funcall succeed (lookup-variable-value exp env)
               fail)))

  (defun analyze-lambda (exp)
    (let ((vars (lambda-parameters exp))
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env succeed fail)
        (funcall succeed (make-procedure vars bproc env)
                 fail))))

  (defun analyze-if (exp)
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      (lambda (env succeed fail)
        (pproc env
               ;; success continuation for evaluating the predicate
               ;; to obtain `pred-value'
               (lambda (pred-value fail2)
                 (if (true? pred-value)
                     (funcall cproc env succeed fail2)
                   (funcall aproc env succeed fail2)))
               ;; failure continuation for evaluating the predicate
               fail))))

  (defun analyze-sequence (exps)
    (defun sequentially (a b)
      (lambda (env succeed fail)
        (a env
           ;; success continuation for calling `a'
           (lambda (a-value fail2)
             (funcall b env succeed fail2))
           ;; failure continuation for calling `a'
           fail)))
    (defun loop (first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Empty sequence -- Analyze"))
      (loop (car procs) (cdr procs))))

  ; PEND to finish this section
#+END_SRC

** 4.4 Logic Programming
#+BEGIN_SRC elisp
; patter matching in elisp
(pcase '((a b) c (a b))
  (`((,x ,y) c (,x ,y)) (format "x = %S y = %S" x y))
  (_                    "No"))
#+END_SRC
*** 4.4.4 Implementing the Query System
#+BEGIN_SRC elisp
  ; There are bugs that need to be fixed in this
  ; implementation of the query system.

  ; Implementation of make-table in ch3
  (defun table/make-table ()
    (lexical-let ((local-table (list '*table*)))
      (defun my-table/lookup (key table)
        (let ((record (my-table/assoc key (cdr table))))
          (if record
              (cdr record)
            nil)))

      (defun my-table/assoc (key records)
        (cond ((null records) nil)
              ((equal key (caar records)) (car records))
              (t (my-table/assoc key (cdr records)))))

      (defun my-table/insert! (key value table)
        (let ((record (my-table/assoc key (cdr table))))
          (if record
              (setcdr record value)
            (setcdr table (cons (cons key value) (cdr table)))))
        'ok)

      (defun my-table2D/lookup (key-1 key-2)
        (let ((subtable (my-table/assoc key-1 (cdr local-table))))
          (if subtable
              (my-table/lookup key-2 subtable)
            nil)))

      (defun my-table2D/insert! (key-1 key-2 value)
        (let ((subtable (my-table/assoc key-1 (cdr local-table))))
          (if subtable
              (my-table/insert! key-2 value subtable)
            (setcdr local-table (cons (list key-1 (cons key-2 value))
                                      (cdr local-table)))))
        'ok)
      (lambda (m)
        (cond ((eq m 'lookup-proc)
               (lambda (key-1 key-2)
                 (my-table2D/lookup key-1 key-2)))
              ((eq m 'insert-proc)
               (lambda (key-1 key-2 val)
                 (my-table2D/insert! key-1 key-2 val)))))))

  ; Implementation of streams in ch3
  (setq the-empty-stream nil)
  (defun stream-null? (s) (eq s the-empty-stream))
  (defmacro delay (exp) (list 'memo-proc `(lambda () ,exp)))
  (defun force (exp) (funcall exp))
  (defmacro cons-stream (a b) (list 'cons a `(delay ,b)))
  (defun stream-car (stream) (car stream))
  (defun stream-cdr (stream) (force (cdr stream)))

  (defun memo-proc (proc)
    (lexical-let ((already-run? nil)
                  (result nil)
                  (p proc))
      (lambda ()
        (if (not already-run?)
            (progn (setq result (funcall p))
                   (setq already-run? t)))
        result)))

  ; create a stream based on an existing list
  (defun make-stream (list)
    "Create a stream from list"
    (lexical-let ((l list))
      (if (stream-null? l)
          the-empty-stream
        (cons-stream
         (car l)
         (make-stream (cdr l))))))

  (defun stream-enumerate-interval (low high)
    (lexical-let ((l low)
                  (h high))
      (if (> l h)
          the-empty-stream
        (cons-stream low
                     (stream-enumerate-interval (1+ l) h)))))

  (defun stream-ref (s n)
    "Return the Nth element of Stream being 0 the
  first element"
    (if (= n 0)
        (stream-car s)
      (stream-ref (stream-cdr s) (1- n))))

  (defun stream-map (proc stream)
    (lexical-let ((p proc)
                  (s stream))
      (if (stream-null? stream)
          the-empty-stream
        (cons-stream (funcall p (stream-car s))
                     (stream-map p (stream-cdr s))))))

  ;; Using second (generalized) implementation of streams
  (defun stream-map-g (proc &optional argstreams)
    (lexical-let ((p proc)
                  (a argstreams))
      (if (null (car a))
          the-empty-stream
        (cons-stream (apply p (mapcar 'car a))
                     (stream-map-g p (mapcar 'stream-cdr a))))))

  (defun stream-for-each (proc s)
    "Evaluate PROC for every element in stream S"
    (if (stream-null? s)
        'done
      (funcall proc (stream-car s))
      (stream-for-each proc (stream-cdr s))))

  (defun stream-filter (predicate s)
    (lexical-let ((pred predicate)
                  (stream s))
      (cond ((stream-null? stream) the-empty-stream)
            ((funcall pred (stream-car stream))
             (cons-stream (stream-car stream)
                          (stream-filter pred (stream-cdr stream))))
            (t
             (stream-filter pred (stream-cdr stream))))))

  (defun stream-append (s1 s2)
    (if (stream-null? s1)
        s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
  (display-stream (stream-append (make-stream '(1 2 3 4))
                                 (make-stream '(5 6 7 8))))
  ; => 1 2 3 4 5 6 7 8

  (defun display-stream (stream)
    (stream-for-each (lambda (x) (insert (format "%S\n" x)))
                     stream))

  (defun first-n-elements (stream n)
    (defun iter (i)
      (cond ((>= i n) the-empty-stream)
            (t (cons (stream-ref stream i)
                     (iter (1+ i))))))
    (iter 0))

  (setq p1 (table/make-table))
  (defun sicp/get (key-1 key-2)
    (funcall (funcall p1 'lookup-proc) key-1 key-2))
  (defun sicp/put (key-1 key-2 val)
    (funcall (funcall p1 'insert-proc) key-1 key-2 val))

  (defun tagged-list? (exp tag)
    (if (consp exp)
        (eq (car exp) tag)
      nil))

  ;; 4.4.4.6 Stream Operations
  (defun singleton-stream (x)
    (cons-stream x the-empty-stream))

  (defun interleave-delayed (s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))

  ; This process isn't generic since it's coded
  ; considering the data structure for the frame stream
  (defun flatten-stream (stream)
    (if (stream-null? stream)
        the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))

  (defun stream-flatmap (proc s)
    (flatten-stream (stream-map proc s)))

  (defun simple-stream-flatmap (proc s)
    (simple-flatten (stream-map proc s)))

  (defun simple-flatten (stream)
    (stream-map 'stream-car
                (stream-filter (lambda (x) (not (stream-null? x)))
                               stream)))

  (display-stream (stream-map 'list (make-stream '((a b) (c d) (e f)))))
  ; => ((a b)) ((c d)) ((e f)) done
  (display-stream (simple-stream-flatmap 'list
                                         (make-stream '((a b) (c d) (e f)))))
  ; => (a b) (c d) (e f) done
  (stream-ref (stream-flatmap '(lambda (l) (cons 'z l))
                              (make-stream '((a b) (c d) (e f) (g h)))) 2)

  (defun stream-append-delayed (s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed (stream-cdr s1) delayed-s2))))
  (display-stream (stream-append-delayed (make-stream (list '(1 2) '(3 4)))
                                         (delay (make-stream (list '(5 6) '(7 8))))))
  ; => (1 2) (3 4) (5 6) (7 8) done

  ;; 4.4.4.6 End

  ;;; 4.4.4.7 Query Syntax Procedures
  (defun type (exp)
    (if (consp exp)
        (car exp)
      (error "Unknown expression %S TYPE" exp)))
  (type '(and (job \?person (computer programmer))
              (address \?person \?where))) ; => and

  (defun contents (exp)
    (if (consp exp)
        (cdr exp)
      (error "Unknown expression %S CONTENTS" exp)))
  (contents '(and (job \?person (computer programmer))
                  (address \?person \?where)))
  ; ((job \?person (computer programmer)) (address \?person \?where))

  (defun empty-conjunction? (exps) (null exps))
  (empty-conjunction? ())       ; => t
  (empty-conjunction? '(a b c)) ; => nil

  (defun empty-disjunction? (exps) (null exps))
  (empty-disjunction? ())       ; => t
  (empty-disjunction? '(a b c)) ; => nil

  (defun negated-query (exps) (car exps))
  (defun predicate (exps) (car exps))
  (defun args (exps) (cdr exps))

  (defun rule? (statement)
    (tagged-list? statement 'rule))
  (rule? '(rule exp))     ; => t
  (rule? '(not-rule exp)) ; => nil)

  (defun conclusion (rule) (cadr rule))
  (conclusion '(rule (wheel \?person)
                     (supervisor \?x \?middle-manager))) ; => (wheel \?person)

  (defun rule-body (rule)
    (if (null (cddr rule))
        '(always-true)
      (caddr rule)))
  (rule-body '(rule (wheel \?person)
                    (supervisor \?x \?middle-manager)))
  ; => (supervisor \?x \?middle-manager)

  (defun query-syntax-process (exp)
    (map-over-symbols 'expand-question-mark exp))
  (query-syntax-process '(rule (wheel \?person)
                               (sypervisor \?x \?middle-manager)))
  ; => (rule (wheel (\? person)) (sypervisor (\? x) (\? middle-manager)))

  (defun map-over-symbols (proc exp)
    (cond ((consp exp)
           (cons (map-over-symbols proc (car exp))
                 (map-over-symbols proc (cdr exp))))
          ((symbolp exp) (funcall proc exp))
          (t exp)))
  (map-over-symbols (lambda (x) (insert (format "%s "(symbol-name x))))
                    '(syma symb symc))
  ; => syma symb symc nil

  (defun expand-question-mark (symbol)
    (let ((chars (symbol-name symbol)))
      (if (string-equal (substring chars 0 1) "?")
          (list '\?
                (intern
                 (substring chars 1 (length chars))))
        symbol)))
  (expand-question-mark '\?name) ; => (\? name)
  (expand-question-mark 'name)   ; => name

  (defun var? (exp)
    (tagged-list? exp '\?))
  (var? '(\? name)) ; => t
  (var? '(name))    ; => nil

  (defun constant-symbol? (exp) (symbolp exp))
  (constant-symbol? 'some-symbol) ; => t

  (setq rule-counter 0)

  (defun new-rule-application-id ()
    (setq rule-counter (1+ rule-counter))
    rule-counter)
  (new-rule-application-id) ; => 1

  (defun make-new-variable (var rule-application-id)
    (cons '\? (cons rule-application-id (cdr var))))
  (make-new-variable '(\? name) rule-counter) ; => (\? 2 name)

  (defun contract-question-mark (variable)
    (intern
     (concat "?"
             (if (numberp (cadr variable))
                 (concat (symbol-name (caddr variable))
                         "-"
                         (number-to-string (cadr variable)))
               (symbol-name (cadr variable))))))

  (contract-question-mark '(\? 2 my-var)) ; => \?my-var-2
  (contract-question-mark '(\? my-var))   ; => \?my-var
  ;;; 4.4.4.7 End

  ;;; 4.4.4.8 Frames and Bindings
  (defun make-binding (variable value)
    (cons variable value))
  (make-binding '\?var 'val) ; => (\?var . val)

  (defun binding-variable (binding)
    (car binding))
  (binding-variable (make-binding '\?var 'val)) ; => \?var

  (defun binding-value (binding)
    (cdr binding))
  (binding-value (make-binding '\?var 'val)) ; => val

  (defun binding-in-frame (variable frame)
    (assoc variable frame))
  (binding-in-frame '\?manager '((\?employee emp) (\?boss bo))) ; => nil
  (binding-in-frame '\?manager '((\?employee emp) (\?manager man))) ; => (\?manager man)

  (defun extend (variable value frame)
    (cons (make-binding variable value) frame))
  (extend '\?employee 'emp '()) ; => ((\?employee . emp))
  (extend '\?boss 'bo '((\?employee . emp))) ; =>  ((\?boss . bo) (\?employee . emp))
  ;;; 4.4.4.8 End

  ;; 4.4.4.5 Maintaining the DB
  (setq a-test (query-syntax-process '(assert! (salary (Bitdiddle Ben) 60000))))
  (setq q-test (query-syntax-process '(salary \?x 60000)))
  (setq r-test (query-syntax-process '(assert! (rule (append-to-form () \?y \?y)))))

  (defun use-index? (pat)
    (constant-symbol? (car pat)))

  (defun indexable? (pat)
    (or (constant-symbol? (car pat))
        (var? (car pat))))
  (indexable? (add-assertion-body a-test)) ; => t
  (indexable? (add-assertion-body r-test)) ; => t

  (defun index-key-of (pat)
    (let ((key (car pat)))
      (if (var? key) '\? key)))
  (index-key-of (add-assertion-body a-test)) ; => salary
  (index-key-of (add-assertion-body r-test)) ; => rule

  (defun get-stream (key1 key2)
    (let ((s (sicp/get key1 key2)))
      (if s s the-empty-stream)))
  (get-stream 'salary 'assertion-stream) ; => nil

  ;; Rules
  (setq THE-RULES the-empty-stream)

  (defun get-all-rules () THE-RULES)
  (get-all-rules) ; => nil

  (defun get-indexed-rules (pattern)
    (stream-append
     (get-stream (index-key-of pattern) 'rule-stream)
     (get-stream '\? 'rule-stream)))

  (defun fetch-rules (pattern frame)
    (if (use-index? pattern)
        (get-indexed-rules pattern)
      (get-all-rules)))

  (defun store-rule-in-index (rule)
    (let ((pattern (conclusion rule)))
      (if (indexable? pattern)
          (let ((key (index-key-of pattern)))
            (let ((current-rule-stream
                   (get-stream key 'rule-stream)))
              (sicp/put key
                        'rule-stream
                        (cons-stream rule
                                     current-rule-stream)))))))
  (sicp/get (index-key-of (conclusion (add-assertion-body r-test))) 'rule-stream) ; => nil
  (store-rule-in-index (add-assertion-body r-test)) ; => ok
  (sicp/get (index-key-of (conclusion (add-assertion-body r-test))) 'rule-stream) ; => ...

  (defun add-rule! (rule)
    (store-rule-in-index rule)
    (let ((old-rules THE-RULES))
      (setq THE-RULES (cons-stream rule old-rules))
      'ok))
  (get-all-rules) ; => nil
  (add-rule! (add-assertion-body r-test)) ; => ok
  (get-all-rules) ; ...

  (defun rename-variables-in (rule)
    (let ((rule-application-id (new-rule-application-id)))
      (defun tree-walk (exp)
        (cond ((var? exp)
               (make-new-variable exp rule-application-id))
              ((consp exp)
               (cons (tree-walk (car exp))
                     (tree-walk (cdr exp))))
              (t exp)))
      (tree-walk rule)))
  (rename-variables-in (add-assertion-body r-test))
  ; => (rule (append-to-form nil (\? 5 y) (\? 5 y)))

  (defun depends-on? (exp var frame)
    (defun tree-walk (e)
      (cond ((var? e)
             (if (equal var e)
                 t
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                   nil))))
            ((consp e)
             (or (tree-walk (car e))
                 (tree-walk (cdr e))))
            (t nil)))
    (tree-walk exp))

  (defun extend-if-possible (var val frame)
    (let ((binding (binding-in-frame var frame)))
      (cond (binding
             (unify-match
              (binding-value binding) val frame))
            ((var? val)
             (let ((binding (binding-in-frame val frame)))
               (if binding
                   (unify-match
                    var (binding-value binding) frame)
                 (extend var val frame))))
             ((depends-on? val var frame) 'failed)
             (t (extend var val frame)))))

  (defun unify-match (p1 p2 frame)
    (cond ((eq frame 'failed) 'failed)
          ((equal p1 p2) frame)
          ((var? p1) (extend-if-possible p1 p2 frame))
          ((var? p2) (extend-if-possible p2 p1 frame))
          ((and (consp p1) (consp p2))
           (unify-match (cdr p1)
                        (cdr p2)
                        (unify-match (car p1)
                                     (car p2)
                                     frame)))
          (t 'failed)))

  (defun apply-a-rule (rule query-pattern query-frame)
    (let ((clean-rule (rename-variables-in rule)))
      (let ((unify-result
             (unify-match query-pattern
                          (conclusion clean-rule)
                          query-frame)))
        (if (eq unify-result 'failed)
            the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))

  (defun apply-rules (pattern frame)
    (stream-flatmap (lambda (rule)
                      (apply-a-rule rule pattern frame))
                    (fetch-rules pattern frame)))

  ;; Assertions
  (setq THE-ASSERTIONS the-empty-stream)

  (defun assertion-to-be-added? (exp)
    (eq (type exp) 'assert!))
  (assertion-to-be-added? a-test) ; => t
  (assertion-to-be-added? q-test) ; => nil

  (defun add-assertion-body (exp)
    (car (contents exp)))
  (add-assertion-body a-test) ; => (salary (Bitdiddle Ben) 60000)

  (defun store-assertion-in-index (assertion)
    (if (indexable? assertion)
        (let ((key (index-key-of assertion)))
          (let ((current-assertion-stream
                 (get-stream key 'assertion-stream)))
            (sicp/put key
                      'assertion-stream
                      (cons-stream assertion
                                   current-assertion-stream))))))
  (get-stream (index-key-of (add-assertion-body a-test)) 'assertion-stream) ; => nil
  (store-assertion-in-index (add-assertion-body a-test)) ; => ok
  (get-stream (index-key-of (add-assertion-body a-test)) 'assertion-stream)

  (defun get-all-assertions () THE-ASSERTIONS)
  (get-all-assertions) ; ...

  (defun add-assertion! (assertion)
    (store-assertion-in-index assertion)
    (let ((old-assertions THE-ASSERTIONS))
      (setq THE-ASSERTIONS
            (cons-stream assertion old-assertions))
      'ok))
  (get-all-assertions) ; => nil
  (add-assertion! (add-assertion-body a-test)) ; => ok
  (get-all-assertions) ; ...

  (defun get-indexed-assertions (pattern)
    (get-stream (index-key-of pattern) 'assertion-stream))
  (get-indexed-assertions (add-assertion-body a-test)) ; ...

  (defun fetch-assertions (pattern frame)
    (if (use-index? pattern)
        (get-indexed-assertions pattern)
      (get-all-assertions)))
  (fetch-assertions '(salary (Bitdiddle Ben) 60000) '()) ; ...

  (defun add-rule-or-assertion! (assertion)
    (if (rule? assertion)
        (add-rule! assertion)
      (add-assertion! assertion)))
  (add-rule-or-assertion! (add-assertion-body a-test)) ; => ok
  ;; 4.4.4.5 END

  (defun extend-if-consistent (var dat frame)
    (let ((binding (binding-in-frame var frame)))
      (if binding
          (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))

  (defun pattern-match (pat dat frame)
    (cond ((eq frame 'failed) 'failed)
          ((equal pat dat) frame)
          ((var? pat) (extend-if-consistent pat dat frame))
          ((and (consp pat) (consp dat))
           (pattern-match (cdr pat)
                          (cdr dat)
                          (pattern-match (car pat)
                                         (car dat)
                                         frame)))
          (t 'failed)))
  (pattern-match '(salary (Bitdiddle Ben) 60000)
                 '(salary (Bitdiddle Ben) 60000)
                 'frame) ; => frame

  (defun check-an-assertion (assertion query-pat query-frame)
    (let ((match-result
           (pattern-match query-pat assertion query-frame)))
      (if (eq match-result 'failed)
          the-empty-stream
        (singleton-stream match-result))))
  (check-an-assertion (stream-car (fetch-assertions '(salary (Bitdiddle Ben) 60000) frame-test))
                      '(salary (Bitdiddle Ben) 60000)
                      'framee)

  (defun find-assertions (pattern frame)
    (stream-flatmap (lambda (datum)
                      (check-an-assertion datum pattern frame))
                    (fetch-assertions pattern frame)))
  (find-assertions '(salary (Bitdiddle Ben) 60000) '()) ; ...
  (find-assertions '(salary (Bitdiddle Ben) 90000) 'frame) ; => nil
  (find-assertions '(salary (\? who) (\? amount)) '())

  (setq frame-test (find-assertions '(salary (\? who) (\? amount)) '()))
  ; the frame stream contains the following values for the 2 entries in the DB
  ; => (((\? amount) . 60000) ((\? who) Bitdiddle Ben))
  ; => (((\? amount) . 40000) ((\? who) Hacker Alyssa P))

  (stream-car (find-assertions '(salary . (\? rest)) '()))
  ; => (((\? rest) (Hacker Alyssa P) 40000))

  (defun simple-query (query-pattern frame-stream)
    (stream-flatmap
     (lambda (frame)
       (stream-append-delayed
        (find-assertions query-pattern frame)
        (delay (apply-rules query-pattern frame))))
     frame-stream))

  (defun conjoin (conjuncts frame-stream)
    (if (empty-conjunction? conjuncts)
        frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
  (conjoin '() '()) ; => nil

  (sicp/put 'and 'qeval 'conjoin)
  (sicp/get 'and 'qeval) ; => conjoin

  (defun disjoin (disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
        the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))
  (disjoin '() '()) ; => nil

  (sicp/put 'or 'qeval 'disjoin)
  (sicp/get 'or 'qeval) ; => disjoin

  (defun negate (operands frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (stream-null? (queval (negated-query operands)
                                 (singleton-stream frame)))
           (singleton-stream frame)
         the-empty-stream))
     frame-stream))

  (sicp/put 'not 'qeval 'negate)
  (sicp/get 'not 'qeval) ; => negate

  (defun lisp-value (call frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (execute
            (instantiate
             call
             frame
             (lambda (v f)
               (error "Unknown pat var -- LISP-VALUE" v))))
           (singleton-stream frame)
         the-empty-stream))
     frame-stream))

  (sicp/put 'lisp-value 'qeval 'lisp-value)
  (sicp/get 'lisp-value 'qeval) ; => lisp-value

  (defun execute (exp)
    (apply (eval (predicate exp))
           (args exp)))

  (defun always-true (ignore frame-stream) frame-stream)

  (sicp/put 'always-true 'qeval 'always-true)
  (sicp/get 'always-true 'qeval) ; => always-true

  (defvar ch4.4/input-prompt ";;; Query input:")
  (defvar ch4.4/output-prompt ";;; Query results:")

  (defun instantiate (exp frame unbound-var-handler)
    (defun ch4.4/copy (exp)
      (cond ((var? exp)
             (let ((binding (binding-in-frame exp frame)))
               (if binding
                   (ch4.4/copy (binding-value binding))
                 (funcall unbound-var-handler exp frame))))
            ((consp exp)
             (cons (ch4.4/copy (car exp)) (ch4.4/copy (cdr exp))))
            (t exp)))
    (ch4.4/copy exp))

  (defun qeval (query frame-stream)
    (let ((qproc (sicp/get (type query) 'qeval)))
      (if qproc
          (funcall qproc (contents query) frame-stream)
        (simple-query query frame-stream))))

  (defun query-driver-loop ()
    (let ((q (query-syntax-process (read (read-string ch4.4/input-prompt)))))
      (cond ((assertion-to-be-added? q)
              (add-rule-or-assertion! (add-assertion-body q))
             (print "Assertion added to data base.")
             (query-driver-loop))
            (t
             (print ch4.4/output-prompt)
             (display-stream
              (stream-map
               (lambda (frame)
                 (instantiate q
                              frame
                              (lambda (v f)
                                (contract-question-mark v))))
               (qeval q (singleton-stream '()))))
             (query-driver-loop)))))

  ;; In case we want to process a line without using the loop
  (defun query-process-line (line)
    (let ((q (query-syntax-process line)))
      (cond ((assertion-to-be-added? q)
             (add-rule-or-assertion! (add-assertion-body q))
             "Assertion added to data base.")
            (t
             (insert ch4.4/output-prompt)
             (display-stream
              (stream-map
               (lambda (frame)
                 (instantiate q
                              frame
                              (lambda (v f)
                                (contract-question-mark v))))
               (qeval q (singleton-stream '()))))))))

  (query-process-line '(assert! (salary (Bitdiddle Ben) 60000)))
   ; => "Assertion added to data base."

  (setq THE-ASSERTIONS the-empty-stream)
  (setq THE-RULES the-empty-stream)

  ; Data
  (query-process-line '(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))))
  (query-process-line '(assert! (job (Bitdiddle Ben) (computer wizard))))
  (query-process-line '(assert! (salary (Bitdiddle Ben) 60000)))
  (query-process-line '(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver))))

  (query-process-line '(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))))
  (query-process-line '(assert! (job (Hacker Alyssa P) (computer programmer))))
  (query-process-line '(assert! (salary (Hacker Alyssa P) 40000)))
  (query-process-line '(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben))))

  (query-process-line '(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3))))
  (query-process-line '(assert! (job (Fect Cy D) (computer programmer))))
  (query-process-line '(assert! (salary (Fect Cy D) 35000)))
  (query-process-line '(assert! (supervisor (Fect Cy D) (Bitdiddle Ben))))

  (query-process-line '(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22))))
  (query-process-line '(assert! (job (Tweakit Lem E) (computer technician))))
  (query-process-line '(assert! (salary (Tweakit Lem E) 25000)))
  (query-process-line '(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben))))

  (query-process-line '(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))))
  (query-process-line '(assert! (job (Reasoner Louis) (computer programmer trainee))))
  (query-process-line '(assert! (salary (Reasoner Louis) 30000)))
  (query-process-line '(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P))))

  (query-process-line '(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road)))))
  (query-process-line '(assert! (job (Warbucks Oliver) (administration big wheel))))
  (query-process-line '(assert! (salary (Warbucks Oliver) 150000)))

  (query-process-line '(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10))))
  (query-process-line '(assert! (job (Scrooge Eben) (accounting chief accountant))))
  (query-process-line '(assert! (salary (Scrooge Eben) 75000)))
  (query-process-line '(assert! (supervisor (Scrooge Eben) (Warbucks Oliver))))

  (query-process-line '(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16))))
  (query-process-line '(assert! (job (Cratchet Robert) (accounting scrivener))))
  (query-process-line '(assert! (salary (Cratchet Robert) 18000)))
  (query-process-line '(assert! (supervisor (Cratchet Robert) (Scrooge Eben))))

  (query-process-line '(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5))))
  (query-process-line '(assert! (job (Aull DeWitt) (administration secretary))))
  (query-process-line '(assert! (salary (Aull DeWitt) 25000)))
  (query-process-line '(assert! (supervisor (Aull DeWitt) (Warbucks Oliver))))

  ;;; Query input:
  (query-process-line '(job \?x (computer programmer)))
  ;;; Query results:
  ;; (job (Fect Cy D) (computer programmer))
  ;; (job (Hacker Alyssa P) (computer programmer))
  ;; (job (Fect Cy D) (computer programmer))
  ;; (job (Hacker Alyssa P) (computer programmer))
  ;; (job 120 (computer programmer))
  ;; (job (Fect Cy D) (computer programmer))
  ;; (job (Hacker Alyssa P) (computer programmer))
  ;; (job (Hacker Alyssa P) (computer programmer))

  (query-process-line '(salary \?x 18000))
  ;;; Query results:
  ;; (salary (Cratchet Robert) 18000)
  ;; (salary (Cratchet Robert) 18000)
  ;; (salary (Cratchet Robert) 18000)

  ;; input
  (query-process-line '(and (job \?person (computer programmer))
                            (address \?person \?where)))

  ;; output
  (and (job (Hacker Alyssa P) (computer programmer))
       (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))

  (and (job (Fect Cy D) (computer programmer))
       (address (Fect Cy D) (Cambridge (Ames Street) 3)))


  ; input
  (query-process-line '(assert! (rule (wheel \?person)
                                      (and (supervisor \?middle-manager \?person)
                                           (supervisor \?x \?middle-manager)))))
  (query-process-line '(wheel \?who))


  (query-process-line '(assert! (rule (lives-near \?person-1 \?person-2)
                                      (and (address \?person-1 (\?town . \?rest-1))
                                           (address \?person-2 (\?town . \?rest-2))
                                           (not (same \?person-1 \?person-2))))))


  (query-process-line '(lives-near \?x (Bitdiddle Ben)))


  (query-process-line '(assert! (rule (append-to-form () ?y ?y))))

  (query-process-line '(assert! (rule (append-to-form (?u . ?v) ?y (?u . ?z))
                                      (append-to-form ?v ?y ?z))))

  ;;; Query input:
  (append-to-form (a b) (c d) ?z)
  ;;; Query results:
  (append-to-form (a b) (c d) (a b c d))

  ;;; Query input:
  (append-to-form (a b) ?y (a b c d))
  ;;; Query results:
  (append-to-form (a b) (c d) (a b c d))

#+END_SRC

** Exercises
*** Exercise 4.1
#+BEGIN_SRC elisp
    (defun ch4/list-of-values-left-right (exps env)
      (if (ch4/no-operands? exps)
          '()
        (lexical-let ((first (ch4/eval (ch4/first-operand exps) env)))
          (cons first
                (ch4/list-of-values-left-right (ch4/rest-operands exps) env)))))


    (defun ch4/list-of-values-right-left (exps env)
      (if (ch4/no-operands? exps)
          '()
        (lexical-let
            ((rest (ch4/list-of-values-right-left (ch4/rest-operands exps) env)))
          (cons (ch4/eval (ch4/first-operand exps) env)
                rest))))
#+END_SRC
*** Exercise 4.2
#+BEGIN_SRC elisp
  ; a. If the `eval' procedure is changed that way, it'll first try to evaluate
       the definition in the first apply, and in the second call to `eval' using
       the definition symbol as an argument, it'll be processed as a variable.
       i.e. for (define x 3) `eval' will try to

       1. Call `(ch4/apply (ch4/eval define env)'
       2. After calling `eval' the `define' expression will be evaluated as a
          variable.

  ; b. Modify the definition of `application?' to:
  (defun ch4/application? (exp)
    (ch4/tagged-list? exp 'call))

  (defun ch4/operator (exp)
    (cadr exp))

  (defun ch4/operands (exp)
    (cddr exp))
#+END_SRC

*** Exercise 4.3
#+BEGIN_SRC elisp
  ;; Rewriting eval
  (defun ex4.3/operator (exp) (car exp))
  (defun ex4.3/operands (exp) (cdr exp))

  (defun ex4.3/eval (exp env)
    (cond ((ch4/self-evaluating? exp) exp)
          ((ch4/variable? exp) (ch4/lookup-variable-value exp env))
          ((consp (sicp-get 'eval (operator exp)))
           (funcall (sicp-get 'eval (operator exp)) exp env))
          ((ch4/application? exp)
           (ch4/apply (ex4.3/eval (ex4.3 operator exp) env)
                      (ch4/list-of-values (ex4.3/operands exp) env)))
          (t
           (error "Unknown expression type %S -- EVAL" exp))))

  (defun ex4.3/install-eval-quoted-package ()
    (lexical-let ((text-of-quotation
                   (lambda (exp) (cadr exp))))

      (sicp-put 'eval 'quote text-of-quotation)
      'done))

  (defun ex4.3/install-eval-assignment-package ()
    (lexical-let ((assignment-variable (lambda (exp) (cadr exp)))
                  (assignment-value (lambda (exp) (caddr exp)))
                  (eval-assignment nil))
      (setq eval-assignment
            (lambda (exp env)
              (ch4/set-variable-value! (funcall assignment-variable exp)
                                       (ex4.3/eval (funcall assignment-variable exp)
                                                   env)
                                       env)
              'ok))
      (sicp-put 'eval' 'set! eval-assignment)
      'done))

  (defun ex4.3/install-eval-definition-package ()
    (lexical-let ((definition-variable nil)
                  (definition-value nil)
                  (eval-definition nil))

      (setq definition-value
            (lambda (exp)
              (if (symbolp (cadr exp))
                  (cadr exp)
                (caddr exp))))

      (setq definition-value
            (lambda (exp)
              (if (symbolp (cadr exp))
                  (caddr exp)
                (ch4/make-lambda (cadr exp)      ; parameters
                                 (caddr exp))))) ; body
      (setq eval-definition
            (lambda (exp env)
              (ch4/define-variable! (funcall definition-variable exp)
                                    (ex4.3/eval (funcall definition-value exp)
                                                env)
                                    env)
              'ok))
      (sicp-put 'eval 'define eval-definition)
      'done))

  (defun ex4.3/install-eval-if-package ()
    (lexical-let ((if-predicate (lambda (exp) (cadr exp)))
                  (if-consequent (lambda (exp) (caddr exp)))
                  (if-alternative (lambda (exp)
                                    (if (not (null (cadddr exp)))
                                        (cadddr exp)
                                      'false)))
                  (eval-if nil))

      (setq eval-if
            (lambda (env exp)
              (if (ch4/true? (ch4/eval (funcall if-predicate exp) env))
                  (ch4/eval (funcall if-consequent exp) env)
                (ch4/eval (funcall if-alternative exp) env))))

      (sicp-put 'eval 'if eval-if)
      'done))


  (defun ex4.3/install-eval-lambda-package ()
    (lexical-let ((lambda-parameters nil)
                  (lambda-body nil)
                  (make-procedure nil))
      (setq lambda-parameters (lambda (exp) (cadr exp)))
      (setq lambda-body (lambda (exp) (cddr exp)))
      (setq make-procedure (lambda (exp env)
                             (ch4/make-procedure (funcall lambda-parameters exp)
                                                 (funcall lambda-body exp)
                                                 env)))
      (sicp-put 'eval 'lambda make-procedure)
      'done))

  (defun ex4.3/install-eval-begin-package ()
    (lexical-let ((begin-actions nil)
                  (eval-sequence nil))
      (setq begin-actions (lambda () cdr exp))
      (setq eval-sequence (lambda (exp env)
                            (ch4/eval-sequence exp env)))
      (sicp-put 'eval eval-sequence)
      'done))

  (defun ex4.3/install-eval-cond-package ()
    (lexical-let ((eval-cond-if
                   (lambda (exp env)
                     (ex4.3/eval (ch4/cond->if exp) env))))
      (sicp-put 'eval eval-cond-if)
      'done))
#+END_SRC

*** Exercise 4.4
#+BEGIN_SRC elisp
    (defun ex4.4/install-eval-and-package ()
      (defun ex4.4/eval-and (exps env)
        (if (not (eq nil (ch4/first-exp exps)))
            (let ((value (ex4.3/eval (ch4/first-exp exps) env)))
              (if (or (eq nil (ch4/rest-exp exps))
                      (not (true? value)))
                  value
                (ex4.4/eval-and (ch4/rest-exps exps) env)))
          'true))
      (lexical-let ((eval-end (lambda (exp env)
                                (ex4.4/eval-and exp env))))
        (sicp-put 'eval 'and eval-and)
        'done))

    (defun ex4.4/install-eval-or-package ()
      (defun ex4.4/eval-or (exps env)
        (if (not (eq nil (ch4/first-exp exps)))
            (let ((value (ex4.3/eval (ch4/first-exp exps) env)))
              (if (or (true? value)
                      (eq nil (ch4/rest-exp exps)))
                  value
                (ex4.4/eval-or (ch4/rest-exps))))
          'false))
      (lexical-let ((eval-or (lambda exp env)
                             (ex4.4/eval-or exp env)))
        (sicp-put 'eval 'or eval-or)
        'done))

  ; As derived expressions
  ; The and expression `(and exp1 exp2 exp3 ...)' can be re-written as:

  ;; (if (not (nil exp1))
  ;;     (if (exp1)
  ;;         (if (exp2)
  ;;             exp3
  ;;           exp2)
  ;;       exp1)
  ;;   'true)

  (defun ex4.4/and->if (exp)
    (ch4/expand-and-clauses (ch4/operands exp)))

  (defun ex4.4/expand-and-exps (exps)
    (cond ((null exps) 'true)
          ((null (cdr exps)) (car exps))
          (t (let ((first (car exps))
                   (rest (cdr exps)))
               (ch4/make-if first
                            (ex4.4/expand-and-exps rest)
                            first)))))

  ; The or expression `(or exp1 exp2 exp3 ...)' can be re-written as:
  ;; (if (not (nil exp1))
  ;;     (if (exp1)
  ;;         exp1
  ;;       (if (exp2)
  ;;           exp2
  ;;         exp3))
  ;;   'false)

  (defun ex4.4/or->if (exp)
    (ch4/expand-or-clauses (ch4/operands exp)))

  (defun ex4.4/expand-or-exps (exps)
    (cond ((null exps) 'false)
          ((null (cdr exps)) (car exps))
          (t (let ((first (car exps))
                   (rest (cdr exps)))
               (ch4/make-if first
                            first
                            (ex4.4/expand-or-exps rest))))))
#+END_SRC

*** Exercise 4.5
#+BEGIN_SRC elisp
  (defun ch4/cond-test-recipient? (clause)
    (eq '=> (cadr clause)))

  (defun ch4/cond-actions (clause)
    (if (ch4/cond-test-recipient? clause)
        (cond ((ch4/lambda? (cddr clause)) (cddr clause))
              ((symbolp (cddr clause)) (caddr clause))
              (t (error "Invalid clause format %S -- COND-ACTIONS" clause)))
      (cdr clause)))

  (defun ch4/expand-clauses (clauses)
    (if (null? clauses)
        'false                         ; no `else' clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (ch4/cond-else-clause? first)
            (if (null? rest)
                (ch4/sequence->exp (ch4/cond-actions first))
              (error "ELSE clause isn't last %S -- COND->IF" clauses))
          (ch4/make-if (ch4/cond-predicate first)
                       (if (ch4/cond-test-recipient? first)
                           (funcall ch4/cond-actions
                                    first
                                    (ch4/cond-predicate first))
                         (ch4/sequence->exp (ch4/cond-actions first)))
                       (ch4/expand-clauses rest))))))
#+END_SRC

*** Exercise 4.6
#+BEGIN_SRC elisp
  ;; in ch4/eval
     ((let-exp? exp) (eval (ex4.6/let->combination exp) env))

  (defun ex4.6/let->combination (exp)
    (let ((assignments (ex4.6/let-assignments exp)))
      (ex4.6/let-transform (ex4.6/let-assign-names assignments)
                           (ex4.6/let-body exp)
                           (ex4.6/let-assign-values assignments))))

  (ex4.6/let->combination '(let ((x 1) (y 2)) (+ x 2) (+ y 3)))
  ;  => ((lambda (x y) (begin (+ x 2) (+ y 3))) 1 2)

  (defun ex4.6/let-transform (vars body values)
    (cons (ex4.6/make-lambda vars body) values))

  (defun ex4.6/let? (exp)
    (ch4/tagged-list? exp 'let))

  (defun ex4.6/let-assignments (exp)
    (cadr exp))

  (defun ex4.6/let-body (exp)
    (cddr exp))

  (defun ex4.6/make-lambda (vars body)
    (list 'lambda vars (cons 'begin body)))

  (defun ex4.6/let-assign-names (assignments)
    (reduce (lambda (acc name) (append acc (list (car name))))
            assignments
            :initial-value '()))

  (defun ex4.6/let-assign-values (assignments)
    (reduce (lambda (acc name) (append acc (list (cadr name))))
            assignments
            :initial-value '()))

#+END_SRC

*** Exercise 4.7
#+BEGIN_SRC elisp
  ; The expression:
  (let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))

  ; Can be re-written as:
  (let ((x 3))
    (let ((y (+ x 2)))
      (let ((z (+ x y 5)))
        (* x z))))

  ; Which expanded to:
  ((lambda (x)
     ((lambda (y)
        ((lambda (z)
           (* x z)) (+ x y z)))
      (+ x 2)))
   3)

  (defun ex4.7/let*->nested-lets (exp)
    (ex4.7/let*-transform (ex4.6/let-assignments exp)
                          (ex4.6/let-body exp)))

  (defun ex4.7/let*-transform (assignments body)
    (if (null (cdr assignments))
        (list 'let assignments (cons 'begin body))
      (list 'let
            (list (car assignments))
            (ex4.7/let*-transform (cdr assignments) body))))

  (ex4.7/let*->nested-lets '(let* ((x 3) (y (+ x 2)) (z (+ x y 5))) (* x y)))
   ;   => (let ((x 3))
   ;        (let ((y (+ x 2)))
   ;          (let ((z (+ x y 5)))
   ;            (begin (* x y)))))

  ; Yes it would be sufficient to write `(eval (let*->nested-lets exp) env)'
  ; to support `let*', as long as the evaluation of `lambda' creates a new
  ; evaluation environment for each call.
#+END_SRC

*** Exercise 4.8
#+BEGIN_SRC elisp
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
         (if (= count 0)
             b
           (fib-iter (+ a b) a (- count 1)))))

  (define (fib n)
    (let))

  ; The inner let expression:
  (let fib-iter ((a 1)
                 (b 0)
                 (count 5))
       (if (= count 0)
           b
         (fib-iter (+ a b) a (- count 1))))

  ; Can be re-written as:
  (let ((a 1)
        (b 0)
        (count n))
    (define (fib-iter a b count)
      (begin
       (if (= count 0)
           b
         (fib-iter (+ a b) a (- count 1)))))
    (fib-iter a b count))

  (defun ex4.8/named-let? (let-exp)
    (symbolp (cadr let-exp)))

  (defun ex4.8/let-name (let-exp)
    (if (ex4.8/named-let? let-exp)
        (cadr let-exp)
      nil))

  (defun ex4.8/let-assignments (exp)
    (if (ex4.8/named-let? exp)
        (caddr exp)
      (cadr exp)))

  (defun ex4.8/let-body (exp)
    (if (ex4.8/named-let? exp)
        (cdddr exp)
      (cddr exp)))

  (defun ex4.8/make-define (name params body)
    (list 'define (cons name params) body))

  (defun ex4.8/named-let-transform (exp)
    (let ((name (ex4.8/let-name exp))
          (body (ex4.8/let-body exp))
          (assignments (ex4.8/let-assignments exp)))
      (list 'let
            assignments
            (ex4.8/make-define name
                               (ex4.6/let-assign-names assignments)
                               (cons 'begin body))
            (cons name (ex4.6/let-assign-names assignments)))))

  (defun ex4.8/let->combination (exp)
    (if (ex4.8/named-let? exp)
        (ex4.8/let->combination (ex4.8/named-let-transform exp))
      (let ((assignments (ex4.6/let-assignments exp)))
        (ex4.6/let-transform (ex4.6/let-assign-names assignments)
                             (ex4.6/let-body exp)
                             (ex4.6/let-assign-values assignments)))))

  ; Test
  (ex4.8/named-let-transform '(let fib-iter ((a 1) (b 0) (count 5))
                                   (if (= count 0)
                                       b
                                     (fib-iter (+ a b) a (- count 1)))))

  ;     => (let ((a 1) (b 0) (count 5))
  ;          (define (fib-iter a b count)
  ;            (begin
  ;             (if (= count 0)
  ;                 b
  ;               (fib-iter (+ a b) a (- count 1)))))
  ;          (fib-iter a b count))

#+END_SRC

*** Exercise 4.9
#+BEGIN_SRC elisp
  ; This procedure:
  (ex4.9/while <TEST> <BODY>)

  ; Can be rewritten as:
  (let ex4.9/while ()
       (if (true? <TEST>)
           't
         (begin
          <BODY>
          (ex4.9/while test body))))

  (defun ex4.9/while? (exp)
    (ch4/tagged-list? exp 'while))

  (defun ex4.9/while-test (exp) (cadr (cadr exp)))
  (defun ex4.9/while-body (exp) (cadr (caddr exp)))
  (defun ex4.9/while->combination (exp)
    (ex4.9/while-transform (ex4.9/while-test exp)
                           (ex4.9/while-body exp)))

  (defun ex4.9/while-transform (test body)
    (list 'let 'ex4.9/while '()
          (ch4/make-if test 't
                       (ch4/sequence->exp (append body
                                                  `((ex4.9/while ',test ',body)))))))

  ; integration with eval:
  ((ex4.9/while? exp) (ch4/eval (ex4.9/while->combination exp) env))

  ; Test of the expansion:
  (ex4.9/while->combination '(ex4.9/while '(< count 10) '((insert "Hello")
                                                          (insert " World!")
                                                          (setq count (1+ count)))))
  (let ex4\.9/while nil
       (if (< count 10)
           t
         (begin
          (insert "Hello")
          (insert " World!")
          (setq count (1+ count))
          (ex4\.9/while (quote (< count 10))
                        (quote ((insert "Hello")
                                (insert " World!")
                                (setq count (1+ count))))))))
#+END_SRC

*** Exercise 4.10
#+BEGIN_SRC elisp
; Define a different name for the assignment,
; so instead of `set!' it will be `<=>'

  (defun ex4.10/assignment? (exp)
    (ch4/tagged-list? exp '<=>))

; Define a different name for the if operator,
; instead of `if' it'll be called `when'

  (defvar ex4.10/if-name 'when)

  (defun ex4.10/if? (exp)
    (ch4/tagged-list? exp ex4.10/if-name))

  (defun ex4.10/make-if (predicate consequent alternative)
    (list ex4.10/if-name predicate consequent alternative))

; Different name for definitions
; instead of `define' it will be called `def'

  (defvar ex4.10/define-name 'def)

  (defun ex4.10/def? (exp)
    (ch4/tagged-list? exp ex4.10/define-name))

  (defun ex4.10/make-define (name params body)
    (list ex4.10/define-name (cons name params) body))
#+END_SRC

*** Exercise 4.11
#+BEGIN_SRC elisp
  ; environment operations
  (defun ex4.11/enclosing-environment (env) (cdr env))
  (defun ex4.11/first-frame (env) (car env))
  (setq ex4.11/the-empty-environment '())

  (defun ex4.11/make-binding (cons var value))

  ; when creating a new frame, is just a list of bindings
  (defun ex4.11/make-frame (bindings)
    bindings)

  (defun ex4.11/var (binding) (car binding))
  (defun ex4.11/val (binding) (cdr binding))
  (defun ex4.11/frame-bindings (frame) frame)

  (defun ex4.11/add-binding-to-frame! (var val frame)
    (cons (ex4.11/make-binding var val) frame))

  (defun ch4/extend-environment (bindings base-env)
    (cons (ex4.11/make-frame bindings) base-env))

  (defun ex4.11/lookup-variable-value (var env)
    (defun ex4.11/env-loop (env)
      (defun ex4.11/scan (bindings)
        (cond ((null? bindings)
               (ch4/env-loop (ex4.11/enclosing-environment env)))
              ((eq? var (ex4.11/var (car bindings)))
               (ex4.11/val (car bindings)))
              (t (ex4.11/scan (cdr bindings)))))
      (if (eq? env ex4.11/the-empty-environment)
          (error "Unbound variable %S" var)
        (let ((frame (ex4.11/first-frame env)))
          (ex4.11/scan (ex4.11/frame-bindings frame)))))
    (ch4/env-loop env))

  (defun ex4.11/set-variable-value! (var val env)
    (defun ex4.11/env-loop (env)
      (defun ex4.11/scan (bindings)
        (cond ((null bindings)
               (ex4.11/env-loop (ex4.11/enclosing-environment env)))
              ((eq var (ex4.11/var (car bindings)))
               (setcar bindings (ex4.11/make-bindings var val)))
              (t (ex4.11/scan (cdr bindings)))))
      (if (eq env ex4.11/the-empty-environment)
          (error "Unbound variable -- %S SET!" var)
        (let ((frame (ex4.11/first-frame env)))
          (ex4.11/scan (ex.411/frame-bindings frame)))))
    (ex4.11/env-loop env))

  (defun ex4.11/define-variable! (var val env)
    (let ((frame (ex4.11/first-frame env)))
      (defun ex4.11/scan-vars (bindings)
        (cond ((null? bindings)
               (ex4.11/add-binding-to-frame! var val frame))
              ((eq? var (ex4.11/var (car bindings)))
               (setcar bindings (ex4.11/make-binding var val))
              (t (ex4.11/scan-vars (cdr bindings))))))
      (ex4.11/scan-vars (ex4.11/frame-bindings frame))))


#+END_SRC
*** Exercise 4.12
#+BEGIN_SRC elisp
;; 4.12
(defun ex4.12/find-first (predicate list)
  (cond ((null list) nil)
        ((funcall predicate (car list)) (car list))
        (t (ex4.12/find-first predicate (cdr list)))))

(defun ex4.12/lookup-binding (var bindings)
  (ex4.12/find-first (lambda (binding)
                       (eq var (ex4.11/var binding)))
                     bindings)

(defun ex4.12/lookup-binding-in-frame (var frame)
  (ex4.12/lookup-binding var (ex4.11/frame-bindings frame)))

(defun ex4.12/lookup-binding-in-env (var env)
  (if (null env)
      nil
    (let ((binding (ex4.12/lookup-binding-in-frame (ch4/first-frame env))))
      (if (not (null binding))
          binding
        (ex4.12/lookup-binding-in-env var
                                      (ch4/enclosing-environment env))))))

(defun ex4.12/lookup-variable-value (var val env)
  (let ((binding (ex4.12/lookup-binding-in-env var env)))
    (if (null binding)
        (error "Variable not bound %S -- LOOKUP!" var)
      (ex4.11/val (ex4.12/lookup-binding-in-env var env)))))

(defun ex4.12/set-variable-value! (var val env)
  (let ((binding (ex4.12/lookup-binding-in-env var env)))
    (if (null binding)
        (error "Variable not bound %S -- SET!" var)
    (setcdr binding val))))

(defun ex4.12/define-variable (var val env)
  (let ((binding (ex4.12/lookup-binding-in-env var env)))
    (if (null binding)
        (ex4.11/add-binding-to-fame! var val (ex4.11/first-frame env))
      (setcdr binding val))))
#+END_SRC

*** Exercise 4.13
#+BEGIN_SRC elisp
    ; The procedure should remove the binding from the top frame and not from
    ; enclosing environments, only the owner of the current environment should be
    ; able to remove bindings from their corresponding environments, otherwise
    ; parent/enclosing environments can't be notified when a binding from a parent env
    ; was removed. This might be cause of bugs and very hard to debug.
  (defun ex4.13/make-unbound! (var env)
    (let ((first-frame (ex4.11/first-frame env))
          (new-frame (ex4.11/make-frame
                      (ex4.13/filter (lambda (binding)
                                       (not (eq var (ex4.11/var binding))))
                                     (frame-bindings first-frame)))))
      (setcar env new-frame)))
#+END_SRC

*** Exercise 4.14
#+BEGIN_SRC elisp
  ; Using `map' as a primitive won't work because the underlying `map' won't
  ; understand the way things are organized for evaluation at the moment of
  ; `apply', so we need to implement our `map' under our eval/apply rules.
#+END_SRC

*** Exercise 4.15
#+BEGIN_SRC elisp
(defun run-forever () (run-forever))
(defun try (p)
  (if (halts? p p) (run-forever) 'halted))

(try try)

; Case 1: Assuming that `(halts? try try)' returns `true' then try will run forever,
;         this violates the intended behavior of `halts?'
; Case 2: If `(halts? try try)' returns false, then try will halt, this
;         action violates the intended behavior of `halts?'
;
; The 2 previous cases show that there can't be a general `halts?' procedure that
; works for every input p.
; Reference: http://www.comp.nus.edu.sg/~cs5234/FAQ/halt.html
#+END_SRC
*** Exercise 4.16
#+BEGIN_SRC elisp
  ; a.
  (defun ex4.16/lookup-variable-value (var env)
    (defun ch4/env-loop (env)
      (defun ch4/scan (vars vals)
        (cond ((null vars)
               (ch4/env-loop (ch4/enclosing-environment env)))
              ((eq var (car vars))
               (if (eq '*unassigned* (car vals))
                   (error "Variable is *undefined %S" var)
                 (car vals)))
              (t (ch4/scan (cdr vars) (cdr vals)))))
      (if (eq env ch4/the-empty-environment)
          (error "Unbound variable %S" var)
        (let ((frame (ch4/first-frame env)))
          (ch4/scan (ch4/frame-variables frame)
                    (ch4/frame-values frame)))))
    (ch4/env-loop env))

  ; b.
  ;; (define (f x)
  ;;   (define (even? n)
  ;;     (if (= n 0)
  ;;         true
  ;;         (odd? (- n 1))))
  ;;   (define (odd? n)
  ;;     (if (= n 0)
  ;;         false
  ;;         (even? (- n 1))))
  ;;   <REST OF BODY OF `F'>)

  ;; (lambda (f x)
  ;;   (define even (lambda (n)
  ;;                  (if (= 0)
  ;;                      true
  ;;                    (odd? (- n 1)))))
  ;;   (define odd? (lambda (n)
  ;;                  (if (= 0)
  ;;                      false
  ;;                    (even? (- n 1)))))
  ;;   <REST OF BODY>)

  ;; (lambda (f x)
  ;;   (let ((even? '*unassigned*)
  ;;         (odd?  '*unassigned*))
  ;;     (set! even? (lambda (n)
  ;;                   (if (= n 0)
  ;;                       true
  ;;                     (odd? (- n 1)))))
  ;;     (set! odd? (lambda (n)
  ;;                  (if (= n 0)
  ;;                      false
  ;;                    (even? (- n 1)))))
  ;;     <REST OF BODY>))

  (setq ch4/some-definition
        '(define (f x)
           (define (even? n)
             (if (= n 0)
                 true
               (odd? (- n 1))))
           (define (odd? n)
             (if (= n 0)
                 false
               (even? (- n 1))))))

  (ch4/definition? ch4/some-definition)

  (ch4/definition-variable ch4/some-definition)
  (ch4/lambda-body (ch4/definition-value ch4/some-definition))

  ; Note this procedure only scans for defines an first level,
  ; for more deeper levels, another procedure needs to be created
  ; to handle the root name of the procedure, in the test example
  ; the root name is `f'. I'm not handling it here because the
  ; the exercise says that the procedure takes the `body' of the
  ; procedure.
  (defun ex4.16/scan-out-defines (body)
    (defun ex4.16/scan (body let-names let-values)
      (if (null body)
          (cons 'let (cons let-names let-values))
        (let ((exp (car body)))
          (if (ch4/definition? exp)
              (let ((name (ch4/definition-variable exp))
                    (value (ch4/definition-value exp)))
                (ex4.16/scan (cdr body)
                             (cons (list name (quote '*unassigned*)) let-names)
                             (cons (list 'set! name value) let-values)))
            (ex4.16/scan (cdr body) let-names let-values)))))
      (ex4.16/scan body nil nil))

  ; Test `scan-out-defines'
  (ex4.16/scan-out-defines (ch4/lambda-body (ch4/definition-value ch4/some-definition)))
  ; => (let ((odd\? (quote *unassigned*))
  ;           (even\? (quote *unassigned*)))
  ;       (set! odd\? (lambda (n)
  ;                     (if (= n 0)
  ;                         false
  ;                       (even\? (- n 1)))))
  ;       (set! even\? (lambda (n)
  ;                      (if (= n 0)
  ;                          true
  ;                        (odd\? (- n 1))))))


  ; c.
  ;; Installing `scan-out-defines'
  (defun ex4.16/make-procedure (parameters body env)
    (list 'procedure parameters (ex4.16/scan-out-defines body) env))

  ;; Installing `scan-out-defines'
  (defun ch4/procedure-body (p) (ex4.16/make-procedure (caddr p)))

  ; It can be seen that installing the procedure under `make-procedure'
  ; then `scan-out-defines' will be called only once. On the other
  ; hand installing in under `procedure-body', then `scan-out-defines'
  ; will be called every time when `procedure-body' is called under
  ; an already created procedure object.
  ; So the best option is to go for the `make-procedure' install.
#+END_SRC

*** Exercise 4.17
#+BEGIN_SRC elisp
; The environment diagram for the following code:
(lambda <VARS>
  (define u <E1>)
  (define v <E2>)
  <E3>)

;;            +--------------+
;;  global -->|              |
;;  env       +--------------+
;;                  ^
;;                  |
;;               +-----+
;;               | u:  |<-- Env1
;;               | v:  |    Where definitions
;;               +-----+    for u and v reside
;;                  ^
;;                  |
;;               +-----+
;;               | <E3>|<-- Env2
;;               +-----+    Environment created for
;;                          the execution of <E3>

; This is the transformed code to make the
; simultaneous scope;
(lambda <VARS>
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u <E1>)
    (set! v <E2>)
    <E3>))

; Then the previous transformed code expands to:
(lambda <VARS>
  ((lambda (u v)
    (set! u <E1>)
    (set! v <E2>)
    <E3>)
  '*unassigned*
  '*unassigned*))

; The environment diagram for the previous code is:

;;            +--------------+
;;  global -->|              |
;;  env       +--------------+
;;                  ^
;;                  |
;;               +-----+
;;               |     |<-- Env1
;;               |     |    Environment created for the execution
;;               +-----+    of the ((lambda (u v)) '*unassigned* '*unassigned*)
;;                  ^
;;                  |
;;               +-----+
;;               | u:  |<-- Env2
;;               | v:  |    Environment created for
;;               +-----+    the execution of ((set! u <E1>) (set! v <E2>) <E3>)
;;                  ^
;;                  |
;;               +-----+
;;               | <E3>|<- Env3: Created for the execution of <E3>
;;               +-----+

; According to the previous diagrams the extra environment frame is created
; because of the nested execution of lambda expressions. Where the first
; code doesn't have any.
; There can't be difference in the behavior between the 2 versions of the code
; because definitions of u and v are visible to the environment created by
; <E3>, at this point both u and v have already been assigned with <E1> and <E2>.

; Another way to implement simultaneous scope for internal definitions without
; creating an extra frame, is using the following transform:
(lambda <VARS>
  (define simultaneous-scope (u v)
    <E3>)
  (simultaneous-scope <E1> <E2>))
#+END_SRC

*** Exercise 4.18
#+BEGIN_SRC elisp
(lambda <VARS>
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (let ((a <E1>)
          (b <E2>))
      (set! u a)
      (set! v b))
    <E3>))

(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)

; If we expand the translation, we get:
(lambda (solve f y0 dt)
  (let ((y '*unassigned*)
        (dy '*unassigned*))
    (let ((a (integral (delay dy) y0 dt))
          (b (stream-map f y)))
      (set! y a)
      (set! dy b))
    y))

; Then expand the inner `let' expressions:
(lambda (solve f y0 dt)
  (let ((y '*unassigned*)
        (dy '*unassigned*))
    ((lambda (a b)
       (set! y a)
       (set! dy b)) (integral (delay dy) y0 dt)
                    (stream-map f y))
    y))

; Expand the outer `let' expression
(lambda (solve f y0 dt)
  ((lambda (y dy)
     ((lambda (a b)
       (set! y a)
       (set! dy b)) (integral (delay dy) y0 dt)
                    (stream-map f y))
    y) '*unassigned
       '*unassigned))

; When trying to evaluate the inner `lambda' expression,
; y is assigned to `(integral (delay dy) y0 dt)', which
; at this point `dy' has the value '*unassigned* in it, so
; the remaining of the evaluations will fail.
; The same problem exists with the first example of
; transformation for simultaneous scope.
#+END_SRC

*** Exercise 4.19
#+BEGIN_SRC elisp
; I support Eva, her view is more consistent. Definitions should be
; truly simultaneous.
; One idea to implement this would be to have available the `apply'
; `eval' at user level as mentioned in previous sections, so the
; internal definitions are stored as data and evaluated as required,
; so the code in this exercise would be translated to:
(let ((a 1))
  (define (f x)
    (define b '(+ (eval a) x))
    (define a '5)
    (+ (eval a) (eval b))
  (f 10)))
#+END_SRC
*** Exercise 4.20
#+BEGIN_SRC elisp
    ; Using elisp syntax to try `letrec'
    (letrec ((even?  (lambda (x)
                       (if (= x 0)
                           t
                         (funcall odd? (- x 1)))))
             (odd? (lambda (x)
                     (if (= x 0)
                         nil
                       (funcall even? (- x 1))))))
      (funcall even? 56)) ; => t


    ; `letrec' code
    (letrec ((fact
              (lambda (n)
                (if (= n 1)
                    1
                  (* n (fact (- n 1)))))))
      (fact 10))

    ; a. transformed code `let' based
    (let ((fact '*undefined*))
      (set! fact (lambda (n)
                   (if (= n 1)
                       1
                     (* n (fact (- n 1))))))
      (fact 10))

    (setq myletrec
    '(letrec ((even?  (lambda (x)
                        (if (= x 0)
                            t
                          (odd? (- x 1)))))
              (odd? (lambda (x)
                      (if (= x 0)
                          nil
                        (even? (- x 1))))))
       (even? 56)))

    (defun ex4.20/letrec? (exp)
      (ch4/tagged-list? exp 'letrec))
    ; Test `letrec?'
    (ex4.20/letrec? myletrec) ; => t

    (defun ex4.20/letrec-bind-list (exp)
      (cadr exp))
    (ex4.20/letrec-bind-list myletrec)
    ; => ((fact (lambda (n) (if (= n 1) 1 (* n (fact (- n 1)))))))

    (defun ex4.20/letrec-bind-vars (exp)
      (mapcar (lambda (x) (list (car x) '*unassigned*)) exp))
    (ex4.20/letrec-bind-vars (ex4.20/letrec-bind-list myletrec))

    (defun ex4.20/letrec-sets (exp)
      (mapcar (lambda (x) (list 'set! (car x) (cadr x))) exp))
    (ex4.20/letrec-sets (ex4.20/letrec-bind-list myletrec))
    ;; => ((set! even\? (lambda (x)
    ;;                   (if (= x 0) t (odd\? (- x 1)))))
    ;;    (set! odd\? (lambda (x)
    ;;                  (if (= x 0) nil (even\? (- x 1))))))

    (defun ex4.20/letrec-body (exp)
      (cddr exp))
    (ex4.20/letrec-body myletrec)
    ; ((funcall even\? 56))

    (defun ex4.20/letrec->let (exp)
      (let ((bind-list (ex4.20/letrec-bind-list exp)))
        (cons 'let
              (cons (ex4.20/letrec-bind-vars bind-list)
                    (append (ex4.20/letrec-sets bind-list)
                            (ex4.20/letrec-body exp))))))

    (ex4.20/letrec->let myletrec)
    ; => (let ((even\? *unassigned*)
    ;        (odd\? *unassigned*))
    ;    (set! even\? (lambda (x) (if (= x 0) t (odd\? (- x 1)))))
    ;    (set! odd\? (lambda (x) (if (= x 0) nil (even\? (- x 1)))))
    ;    (even\? 56))

  ;  b. Replacing the definition of `f' with let:
  (define (f x)
    (let ((even?
           (lambda (n)
             (if (= n 0)
                 true
               (odd? (- n 1)))))
          (odd?
           (lambda (n)
             (if (= n 0)
                 false
               (even? (- n 1))))))
      <REST OF BODY OF `F'>))

  ; if we expand this let with `lambda'
  (define (f x)
    ((lambda (even? odd?)
       <REST OF BODY OF `F'>)
     (lambda (n)
       (if (= n 0)
           true
         (odd? (- n 1))))
     (lambda (n)
       (if (= n 0)
           false
         (even? (- n 1))))))

  ; The environment diagram might look like
  ;;          +---------+
  ;; global ->| f: --+  |
  ;; env      +------|--+
  ;;                 |
  ;;                 V
  ;;          +----------------------------------------------+
  ;;          | This environemnt is created when executing   |
  ;;     E1 ->| the first code reference and passing         |
  ;;          | the other two lambdas as arguments, but      |
  ;;          | `odd?' and `even?' are unbound at this frame |
  ;;          +------|-------------------------|-------------+
  ;;                 |      ^           ^      |      ^
  ;;            +----v---+  |           | +----v---+  |
  ;;            | o  | o +---           | | o  | o +---
  ;;            +-|--^---+              | +-|--^---+
  ;;              |                     |   |
  ;;              V                     |   V
  ;;            param: n                | param: n
  ;;            code: (if (= n 0)       | code: (if (= n 0)
  ;;                      true          |           false
  ;;                    (odd? (- n 1))) |           (even? (- n 1))
  ;;                                    |
  ;;                                    |
  ;;          +-------------------------|---------------------------+
  ;;          | even?:   Environment created when executing the     |
  ;;     E3 ->| odd?:    lambda containing the <REST OF BODY `F'>   |
  ;;          |          `even?' and `odd?' are bound in this env.  |
  ;;          +-----------------------------------------------------+
  ;;
  ;; In the case of `letrec', `even?' and `odd?' are bound before they're
  ;; used.
#+END_SRC

*** Exercise 4.21
#+BEGIN_SRC elisp
  a. factorial
  ((lambda (n)
     ((lambda (fact)
        (funcall fact fact n))
      (lambda (ft k)
        (if (= k 1)
            1
          (* k (funcall ft ft (- k 1)))))))
    10) ; => 3628800

  ((lambda (n)
    ((lambda (fib)
      (funcall fib fib n))
     (lambda (ft k)
       (if (or (= k 1) (= k 0))
           1
         (+ (funcall ft ft (- k 1))
            (funcall ft ft (- k 2)))))))
   6) ; => 13

  b.
  (defun ex4.21/f (x)
     (funcall (lambda (even? odd?)
        (funcall even? even? odd? x))
      (lambda (ev? od? n)
        (if (= n 0) t (funcall od? ev? od? (- n 1))))
      (lambda (ev? od? n)
        (if (= n 0) nil (funcall ev? ev? od? (- n 1))))))

  (ex4.21/f 115) ; => nil
  (ex4.21/f 118) ; => t
#+END_SRC

*** Exercise 4.22
#+BEGIN_SRC elisp
    ;; in ch4/analyze add the following line
    ((let-exp? exp) (analyze (ex4.6/let->combination exp) env))
#+END_SRC
*** Exercise 4.23
#+BEGIN_SRC elisp
    ; Text version
    (defun ch4/analyze-sequence (exps)
      (defun sequentially (proc1 proc2)
        (lambda (env) (funcall proc1 env) (funcall proc2 env)))
      (defun loop (first-proc rest-procs)
        (if (null rest-procs)
            first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
      (let ((procs (mapcar 'ch4/analyze exps)))
        (if (null? procs)
            (error "Empty Sequence -- ANALYZE"))
        (loop (car procs) (cdr procs))))

    ; Alyssa's version
    (defun analyze-sequence (exps)
      (defun execute-sequence (procs env)
        (cond ((null (cdr procs)) (funcall (car procs) env))
              (t (funcall (car procs) env)
                 (execute-sequence (cdr procs) env))))
      (let ((procs (mapcar 'ch4/analyze exps)))
        (if (null procs)
            (error "Empty sequence -- ANALYZE"))
        (lambda (env) (execute-sequence procs env))))

  ; for a sequence `(proc1 proc2 proc3)' the expansion in the text would
  ; look like:
  ; first transforming the input list with analyze results:
  ;  `(aproc1, aproc2, aproc3)'
  ; then the expansion (removing the funcalls for clarity)
  (lambda (env)
    ((lambda (env)
       (aproc1 env)
       (aproc2 env))
     env)
    (aproc3 env))

  ; in the other hand, Alyssa's version is sequentially executed
  ; as (removing funcalls):
  (aproc1 env)
  (aproc2 env)
  (aproc3 env)

  ; and the returned lambda is:
  (lambda (env) (aproc3 env))

  ; As can be seen, this approach is incorrect since the returned `lambda'
  ; only takes into account the last analyzed procedure in the sequence.
#+END_SRC

*** Exercise 4.24
#+BEGIN_SRC elisp
; The idea for the experiment would be to create a loop executing
; some of the code reviewed here and measure the executing time.
; Will leave this as PEND for now.
#+END_SRC

*** Exercise 4.25
#+BEGIN_SRC elisp
; Since in applicative-order languages, parameters are evaluated before their bodies,
; in this example of `factorial' the parameters of `unless' will be evaluated before
; entering the body of `unless'. Hence the program will loop forever trying to evaluate
; the line `(* n (factorial (- n 1)))'.
; In the case of normal-order evaluation the program will work since the body of `unless'
; which is an `if' construction will be expanded before all the arguments are evaluated.
#+END_SRC
*** Exercise 4.26
#+BEGIN_SRC elisp
  ; To implement `unless' as a derived expression

  ;; in ch4/analyze add the following line
  ((ex4.26/unless? exp) (analyze (ex4.26/unless->if exp) env))

  ;; unless expression (based on the `if' code at the
  ;; beginning of this chapter.
  (defun ex4.26/unless? (exp)
    (ch4/tagged-list? exp 'unless))

  (defun ex4.26/unless-condition (exp)
    (cadr exp))

  (defun ex4.26/unless-usual-value (exp)
    (caddr exp))

  (defun ex4.26/unless-exceptional-value (exp)
    (if (not (null (cadddr exp)))
        (if (ch4/last-exp? (cdddr exp))
            (cadddr exp)
          (cdddr exp))
      'false))

  (defun ex4.26/unless->if (exp)
    (ch4/make-if (ex4.26/unless-condition exp)
                 (ex4.26/unless-exceptional-value exp)
                 (ex4.26/unless-usual-value)))

  ; It's not very clear how a `unless' procedure would be useful
  ; in a applicative-order language, the problem here is that all
  ; the 3 arguments would be evaluated which is undesirable for
  ; this process in particular, where only the condition and one
  ; of the two values need to be evaluated.
#+END_SRC

*** Exercise 4.27
#+BEGIN_SRC elisp
  (ch4/eval '(define count 0) ch4/the-global-environment)

  (ch4/eval '(define (id x)
               (set! count (plus count 1))
               x) ch4/the-global-environment)

  (ch4/eval '(define w (id (id 10))) ch4/the-global-environment)

  ;;; L-Eval input
  count             ; (ch4/eval 'count ch4/the-global-environment)
  ;;; L-Eval value
  1

  ;;; L-Eval input
  w                  ; (ch4/force-it (ch4/eval 'w ch4/the-global-environment))
  ;;; L-Eval value
  10                 ; it should be 10 here, need to check why is not
                     ; forcing the value

  ;;; L-eval input
  count              ; (ch4/eval 'count ch4/the-global-environment)
  ;;; L-Eval value
  2
#+END_SRC

*** Exercise 4.28
#+BEGIN_SRC elisp
  ; `force-it' is required so the information in the thunk can be extracted and passed
  ; to the `apply' procedure, otherwise `apply' wouldn't know how to proceed to.
  ; From the previous exercise if we use `apply' on a thunk this is what we get:

(ch4/apply (ch4/delay-it '(define w 10) ch4/the-global-environment)
           (ch4/operands ' (define w 10))
           ch4/the-global-environment) ; => throws an error
#+END_SRC

*** Exercise 4.29
#+BEGIN_SRC elisp
(ch4/eval '(define count 0) ch4/the-global-environment)

(ch4/eval '(define (id x)
             (set! count (plus count 1))
             x) ch4/the-global-environment)

(ch4/eval '(define (square x) (times x x)) ch4/the-global-environment)

;;; L-Eval input:
(square (id 10)) ;(ch4/eval '(square (id 10)) ch4/the-global-environment)
;;; L-Eval value:
100

;;; L-Eval input:
count             ;(ch4/eval 'count ch4/the-global-environment)
;;; L-Eval value:
1

;; Memoization is used once the expression has been evaluated, if we
;; wouldn't have used memoization here, then the `(id 10)' would've been
;; executed twice and count value would be 2.
;;This is a good example of a program that will run without memoization,
;; suppose a nested call of the form `(square (square (id 10)))'
#+END_SRC

*** Exercise 4.30
#+BEGIN_SRC elisp
(defun ch4/eval-sequence (exps env)
  (cond ((ch4/last-exp? exps) (ch4/eval (ch4/first-exp exps) env))
        (t (ch4/actual-value (ch4/first-exp exps) env)
              (ch4/eval-sequence (ch4/rest-exps exps) env))))
;; PEND
#+END_SRC

*** Exercise 4.31
#+BEGIN_SRC elisp
; PEND
#+END_SRC

*** Exercise 4.32
#+BEGIN_SRC elisp
; As mentioned in the text, the new advantage with using
; the "lazier" lazy lists is the ability to write generic
; procedures that work with both, streams and regular "lazy"
; lists. Here is the different versions of `map' the first
; one for streams and the second one the generic version

  (defun my/stream-map (proc stream)
    (lexical-let ((p proc)
                  (s stream))
      (if (stream-null? stream)
          the-empty-stream
        (my/cons-stream (funcall p (my/stream-car s))
                        (my/stream-map p (my/stream-cdr s))))))


  (defun ch4/map (proc items)
    (if (null items)
        '()
      (ch4/cons (funcall proc (ch4/car items))
               (ch4/map proc (ch4/cdr items)))))

#+END_SRC

*** Exercise 4.33
#+BEGIN_SRC elisp
  ; The list needs to be represented in the new internal format,
  ; what needs to be done, is to make the evaluator to treat
  ; quoted lists as lazy lists.

  ; we need to modify the `text-of-quotation' to look like:

  ; From this form
    (defun ch4/text-of-quotation (exp)
      (cadr exp))
    ; Test `ch4/text-of-quotation'
    (ch4/text-of-quotation '(quote (expression))) ; (expression)

    (defun ex4.33/text-of-quotation (exp)
      (defun ex4.33/build-lazy-list (lst)
        (if (null lst)
            '()
          (ch4/cons (car lst)
                    (ex4.33/build-lazy-list (cdr lst)))))
      (if (symbolp (cadr exp))
          (cadr exp)
        (ex4.33/build-lazy-list (cadr exp))))

  (ex4.33/text-of-quotation '(quote expression)) ; expression
  (ch4/list-ref (ex4.33/text-of-quotation '(quote (one two three))) 2) ; => three
#+END_SRC

*** Exercise 4.34
#+BEGIN_SRC elisp
  ; Adjust to work under an elisp buffer, using the minibuffer to
  ; read the user input
  (defun ch4/driver-loop ()
    (let ((input (car (read-from-string (read-string ch4/input-prompt)))))
      (let ((output (ch4/actual-value input ch4/the-global-environment)))
        (ch4/announce-output ch4/output-prompt)
        (ch4/user-print output)))
    (ch4/driver-loop))

  (defun ex4.34/user-print (object)
    (if (ch4/compound-procedure? object)
        (insert (format "%S" (list 'compound-procedure
                                   (ch4/procedure-parameters object)
                                   (ch4/procedure-body object)
                                   '<procedure-env>)))
      (insert ex4.34/print-list object)))

  ; We set a variable that controls the max number of items to
  ; print in a list.
  (setq ex4.34/max-print-size 100);

  (defun ex4.34/print-list (lst)
    ; return a string representation of lst, in case the
    ; string is longer that ex4.34/max-print-size, then truncate
    ; the printable string and append "..." to let the user know
    ; that it's not the complete list.
    (defun ex4.34/print-list-count (lst str cnt)
      (cond ((null lst) str)
            ((> cnt ex4.34/max-print-size) (concat str "..."))
            (t (ex4.34/print-list-count
                (ch4/cdr lst)
                (concat str (format "%S" (ch4/car lst)))
                (1+ cnt)))))
    (ex4.34/print-list lst "" 0))
#+END_SRC

*** Exercise 4.35
#+BEGIN_SRC elisp
  ; two implementations:
  (defun ex4.35/an-integer-between (m n)
    (let ((x (ch4/an-integer-starting-from m)))
      (ch4/require (<= x n))
       x))

  (defun ex4.35/an-integer-between (m n)
    (require (<= m n))
    (amb m (ex4.35/an-integer-between (1+ m) n)))

  (defun ex4.35/a-pythagorean-triple-between (low high)
    (let ((i (ex4.35/an-integer-between low high)))
      (let ((j (ex4.35/an-integer-between i high)))
        (let ((k (ex4.35/an-integer-between j high)))
          (ch4/require (= (+ (* i i) (* j j)) (* k k)))
          (list i j k)))))
#+END_SRC

*** Exercise 4.36
#+BEGIN_SRC elisp
  ; if we do a simple replace of `an-integer-between' with
  ; `an-integer-starting-from' the procedure would look like
  ; this
  (defun ex4.35/a-pythagorean-triple ()
    (let ((i (ex4.35/an-integer-starting-from 1)))
      (let ((j (ex4.35/an-integer-starting-from i)))
        (let ((k (ex4.35/an-integer-starting-from j)))
          (ch4/require (= (+ (* i i) (* j j)) (* k k)))
          (list i j k)))))

  ; PEND I'm still not sure why it wouldn't work this way.
#+END_SRC

*** Exercise 4.37
#+BEGIN_SRC elisp
; It isn't simple to see if he's right. It might look right since
;  most of the exploration would be done on finding `k', because
; the requirement for `(>= hsq ksq)' is easy to  meet.
#+END_SRC

*** Exercise 4.38
#+BEGIN_SRC elisp
  ; PEND until `amb' and `require' are implemented
#+END_SRC
*** Exercise 4.39
#+BEGIN_SRC elisp
; It should matter, I think we can reduce the search space
; by ordering the restrictions correctly, for example we
; can delimit the search space by putting the floor number
; restrictions set to baker, cooper and fletcher:

  (defun ch4/multiple-dwelling ()
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (ch4/require (not (= fletcher 5)))
      (ch4/require (not (= fletcher 1)))
      (ch4/require (not (= baker 5)))
      (ch4/require (not (= cooper 1)))
      (ch4/require
       (ch4/distinct? (list baker cooper fletcher miller smith)))
      (ch4/require (> miller cooper))
      (ch4/require (not (= (abs (- smith fletcher)) 1)))
      (ch4/require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smit))))
#+END_SRC

*** Exercise 4.40
#+BEGIN_SRC elisp
  ; Before
  ; After ('name number-of-assignments)
  (('fletcher 3) ('baker 4) ('cooper '4) ('smith 5) ('miller 5)))

  (defun ch4/multiple-dwelling ()
    (let ((miller (ch4/amb 3 4 5))
          (cooper (ch4/amb 2 3 4))
          (fletcher (ch4/amb 2 3 4)))
      (ch4/require (> miller cooper))
      (ch4/require (ch4/distinct? fletcher cooper miller))
      (ch4/require (not (= (abs (- fletcher cooper)) 1)))
      (let ((smith (ch4/amb 1 2 3 4 5)))
        (ch4/require (ch4/distinct? fletcher cooper miller smith))
        (ch4/require (not (= (abs (- smith fletcher)) 1)))
        (let ((baker (ch4/amb 1 2 3 4)))
          (ch4/require
           (ch4/distinct? (list baker cooper fletcher miller smith)))
          (list (list 'baker baker)
                (list 'cooper cooper)
                (list 'fletcher fletcher)
                (list 'miller miller)
                (list 'smith smit))))))

  ; PEND TO TEST PERFORMANCE until `amb' implementation
#+END_SRC

*** Exercise 4.41
#+BEGIN_SRC elisp
  (defun ch4/multiple-dwelling ()
      (if (ex4.41/meet-restrictions baker cooper fletcher smith)
          (list (list 'baker baker)
                (list 'cooper cooper)
                (list 'fletcher fletcher)
                (list 'miller miller)
                (list 'smith smit)))
      nil))

  (defun a-substract-b (a-set b-set)
    (cond ((null a-set) nil)
          ((member (car a-set) b-set)
           (a-substract-b (cdr a-set) b-set))
          (t
           (cons (car a-set)
                 (a-substract-b (cdr a-set) b-set)))))

  (defun flatten (list)
    (cond ((null list) nil)
          ((consp list)
           (append  (car list) (flatten (cdr list))))
          (t (list list))))

  (flatten '(((1 2) (1 3)) ((2 1) (2 3))))

  ; This is very baby-step code, it can be done better.
  (defun search-space (b-set c-set f-set m-set s-set)
    (flatten
     (mapcar
      (lambda (b)
        (flatten
         (mapcar
          (lambda (c)
            (flatten
             (mapcar
              (lambda (f)
                (flatten
                 (mapcar
                  (lambda (m)
                    (mapcar
                     (lambda (s)
                       (list b c f m s))
                     (a-substract-b s-set (list b c f m))))
                  (a-substract-b m-set (list b c f)))))
              (a-substract-b f-set (list b c)))))
          (a-substract-b c-set (list b)))))
      b-set)))

  (defun ex4.41/filter-apply (f l)
    (cond ((null l) nil)
          ((apply f (car l))
           (cons (car l) (ex4.41/filter-apply f (cdr l))))
          (t (ex4.41/filter-apply f (cdr l)))))

  (defun ex4.41/meet-restrictions? (baker cooper fletcher miller smith)
    (and (> miller cooper)
         (not (= (abs (- smith fletcher)) 1))
         (not (= (abs (- fletcher cooper)) 1))))

  (defun ex4.41/tag-results (result)
    (defun ex4.41/tag (floors names)
      (cond ((null names) nil)
            (t (cons (list (car names) (car floors))
                     (ex4.41/tag (cdr floors) (cdr names))))))
    (ex4.41/tag result '(baker cooper fletcher miller smith)))

  (mapcar 'ex4.41/tag-results
          (let ((baker '(1 2 3 4))
                (cooper '(2 3 4))
                (fletcher '(2 3 4))
                (miller '(3 4 5))
                (smith '(1 2 3 4 5)))
            (ex4.41/filter-apply
             'ex4.41/meet-restrictions?
             (search-space '(1 2 3 4) '(2 3 4) '(2 3 4) '(3 4 5) '(1 2
             3 4 5)))))

  ; => (((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1)))
#+END_SRC

*** Exercise 4.42
#+BEGIN_SRC elisp
  ; We require that just one statement is true and one statement
  ; is false. Two true statements or two false statements is false.
  ; this is basically an xor operation.
  (defun ex4.42/xor (a b)
    (and (or a b)
         (not (and a b))))

  (defun ex4.42/liars ()
    (let ((betty (ch4/amb 1 2 3 4 5))
          (ethel (ch4/amb 1 2 3 4 5))
          (joan  (ch4/amb 1 2 3 4 5))
          (kitty (ch4/amb 1 2 3 4 5))
          (mary  (ch4/amb1 2 3 4 5)))
      (ch4/require (ex4.42/xor (= kitty 2)
                               (= betty 3)))
      (ch4/require (ex4.42/xor (= ethel 1)
                               (= joan 2)))
      (ch4/require (ex4.42/xor (= joan 3)
                               (= ethel 5)))
      (ch4/require (ex4.42/xor (= mary 4)
                               (= betty 1)))
      (ch4/require (ch4/distinct? betty ethel joan kitty mary))))

   ; PEND to verify once `amb' is implemented.
#+END_SRC

*** Exercise 4.43
#+BEGIN_SRC elisp
  ; The idea is to verify that the following statement is true:
  ; Gabrielle's father owns the yacht that is named after
  ; Dr Parker's daughter.
  ; so in the father-daughter pairs we have (x gabrielle) (parker y)
  ; so we just need to verify that the pair `(x y)' belongs to
  ; the list containing the yacht names.

  ; yacht pairs
  ; (barnacle gabrielle) (moore lorna) (hall rosalind) (downing melissa) (parker mary)

  ; father-daughter pairs
  ; (moore mary) (barncle melissa) (x gabrielle) (parker y) (!x !y)

  ; Possible options for x (hall downing)
  ; Possible options for y (lorna rosalind)

  ; test 4 options for x and y
  (hall gabrielle) (parker lorna) (downing rosalind) <- no
  (hall gabrielle) (parker rosalind) (downing lorna) <- yes

  (downing gabrielle) (parker rosalind) (hall lorna) <- no
  (downing gabrielle) (parker lorna) (hall rosalind) <- no

  (defun ex4.43/yachts ()
    (let ((owner-yacht-names
           (list (list 'barncle 'gabrielle)
                 (list 'moore 'lorna)
                 (list 'hall 'rosalind)
                 (list 'downing 'melissa)
                 (list 'parker 'mary)))
          (x (amb 'hall 'downing))
          (y (amb 'lorna 'rosalind))
      (ch4/require (member (list x y) owner-yacht-names))
      (list (list 'moore 'mary)
            (list 'barncle 'melissa)
            (list x 'gabrielle)
            (list parker y)
            (list (a-substract-b '(hall downing) (list x))
                  (a-substract-b '(lorna rosalind) (list y)))))))

  ; yacht pairs
  ; (barnacle gabrielle) (moore lorna) (hall rosalind) (downing melissa) (parker mary)

  ; father-daughter pairs
  ; (moore z) (barncle melissa) (x gabrielle) (parker y) (!x (and !y !z))

  ; Possible options for x (hall downing)
  ; Possible options for y (lorna rosalind mary)
  ; possible options for z (lorna rosalind mary)
  (defun ex4.43/yachts2 ()
    (let ((owner-yacht-names
           (list (list 'barncle 'gabrielle)
                 (list 'moore 'lorna)
                 (list 'hall 'rosalind)
                 (list 'downing 'melissa)
                 (list 'parker 'mary)))
          (x (amb 'hall 'downing))
          (y (amb 'lorna 'rosalind 'mary))
          (z (amb 'lorna 'rosalind 'mary)))
      (ch4/require (not (eq y z)))
      (ch4/require (and
                    (member (list x y) owner-yacht-names)
                    (member (list 'moore y)) owner-yacht-names))
      (list (list 'moore z)
            (list 'barncle 'melissa)
            (list x 'gabrielle)
            (list parker y)
            (list (a-substract-b '(hall downing) (list x))
                  (a-substract-b '(lorna rosalind) (list y z))))))

 ; PEND test with the `amb' implementation
#+END_SRC

*** Exercise 4.44
#+BEGIN_SRC elisp
   ; PEND
#+END_SRC
*** Exercise 4.45
#+BEGIN_SRC elisp
   ; PEND for implementation of `amb'
#+END_SRC
*** Exercise 4.46
#+BEGIN_SRC elisp
  ; PEND
#+END_SRC
*** Exercise 4.47
#+BEGIN_SRC elisp
  ; PEND
#+END_SRC
*** Exercise 4.48
#+BEGIN_SRC elisp
  ; PEND
#+END_SRC
*** Exercise 4.49
#+BEGIN_SRC elisp

#+END_SRC

*** Exercise 4.50
#+BEGIN_SRC elisp
; PEND
#+END_SRC
*** Exercise 4.51
#+BEGIN_SRC elisp
; PEND
#+END_SRC
*** Exercise 4.52
#+BEGIN_SRC elisp
; PEND
#+END_SRC
*** Exercise 4.53
#+BEGIN_SRC elisp
; PEND
#+END_SRC
*** Exercise 4.54
#+BEGIN_SRC elisp
; PEND
#+END_SRC

*** Exercise 4.55
#+BEGIN_SRC elisp
; 1. all people supervised by Ben Bitdiddle;
  (supervisor ?x (Bitdiddle Ben))

; 2. the names and jobs of all people in the accounting division;
  (job ?name (accounting . ?position))

; 3. the names and addresses of all the people who live in Slumerville.
  (address ?name (Slumerville  ?address ?number))
#+END_SRC

*** Exercise 4.56
#+BEGIN_SRC elisp
  ; a. the names of all people who are supervised by Ben Bitdiddle,
       together with their addresses;
    (and (supervisor ?name (Ben Bitdiddle))
         (address ?name ?where))

  ; b. All people whose salary is less Ben Bitddile's together with
  ;    their salary and Ben Bitdiddle's salary.
    (and (salary (Ben Bitdiddle) ?ben-salary)
         (salary ?person ?salary)
         (lisp-value < ?salary ?ben-salary))

       (address (Scrooge Eben) (Weston (Shady Lane) 10))
       (job (Scrooge Eben) (accounting chief accountant))
       (salary (Scrooge Eben) 75000)
       (supervisor (Scrooge Eben) (Warbucks Oliver))

  ; c. all people who are supervised by someone who is not in the
  ;    computer division, together with the supervisor's name and
  ;    job
    (and (supervisor ?name ?super)
         (not (job ?super (computer . ?type)))
         (job ?name ?job))
#+END_SRC

*** Exercise 4.57
#+BEGIN_SRC elisp
  (rule (can-be-replaced-by ?person-1 ?person-2)
    (and (job ?person-1 ?job-1)
         (job ?person-2 ?job-2)
         (not (same ?person-1 ?person-2))
         (or (same ?job-1 ?job-2)
             (can-do-job ?job-1 ?job-2))))
  ;  a.
  (can-be-replaced-by ?x (Cy D. Fect))

  ;  b.
  (and (salary ?person-1 ?amount-1)
       (salary ?person-2 ?amount-2)
       (lisp-value < ?amount-1 ?amount2)
       (can-be-replaced-by ?person-1 ?person-2))
#+END_SRC

*** Exercise 4.58
#+BEGIN_SRC elisp
(rule (big-shot ?person)
      (and (job ?name (?division . ?type))
           (supervisor ?name ?boss)
           (not (job ?boss (?division)))))
#+END_SRC

*** Exercise 4.59
#+BEGIN_SRC elisp
; a.
(meeting ?division (Friday ?time))

; b.
(rule (meeting-time ?person ?day-and-time)
  (and (job ?person (?division ?job))
       (or (meeting ?division ?day-and-time)
           (meeting whole-company ?day-and-time))))

; c.
(meeting-time (Alyssa P Hacker) (Wednesday ?time))
#+END_SRC

*** Exercise 4.60
#+BEGIN_SRC elisp
; This happens because ?person-1 and ?person-2 will match every person,
; and the rule doesn't have any type of restriction that forbids putting
; the same person in both variables ?person1 and ?person-2.
#+END_SRC

*** Exercise 4.61
#+BEGIN_SRC elisp
(rule (?x next-to ?y in (?x ?y . ?u)))

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))

; a.
(?x next-to ?y in (1 (2 3) 4))
(1 next-to (2 3) in (1 (2 3) 4))

; b.
(?x next-to 1 in (2 1 3 1))
(2 next-to 1 in (2 1 3 1))
(3 next-to 1 in (3 1))
#+END_SRC

*** Exercise 4.62
#+BEGIN_SRC elisp
(rule (last-pair (?x) (?x)))
(rule (last-pair (?u . ?v) (?x))
      (last-pair ?v (?x)))
#+END_SRC

*** Exercise 4.63
#+BEGIN_SRC elisp
; Pend
#+END_SRC

*** Exercise 4.64
#+BEGIN_SRC elisp
  ; what Louis typed
  (rule (outranked-by ?staff-person ?boss)
        (or (supervisor ?staff-person ?boss)
            (and (outranked-by ?middle-manager ?boss)
                 (supervisor ?staff-person ?middle-manager))))

  (outranked-by (Bitdiddle Ben) ?who)

  ; the problem resides in the (outranked-by (?middle-manager ?boss...
  ; at this point ?middle-manager isn't bound so it's like matching
  ; the rule conclusion (outranked-by ?staff-person ?boss) so it gets
  ; stuck in an infinite loop

  ; the rule should have been written like this:
  (rule (outranked-by ?staff-person ?boss)
        (or (supervisor ?staff-person ?boss)
            (and (supervisor ?staff-person ?middle-manager)
                 (outranked-by ?middle-manager ?boss))))
#+END_SRC

*** Exercise 4.65
#+BEGIN_SRC elisp
; Rule definition
  (rule (wheel ?person)
        (and (supervisor ?middle-manager ?person)
             (supervisor ?x ?middle-manager)))

; Because there are 4 mid-managers under
; (Warbucks Oliver) who meet the rule:

; rule:
     (supervisor ?x ?middle-manager)

; mid-managers:
     (supervisor (Cratchet Robert) (Scrooge Eben))
     (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
     (supervisor (Fect Cy D) (Bitdiddle Ben))
     (supervisor (Tweakit Lem E) (Bitdiddle Ben))
#+END_SRC

*** Exercise 4.66
#+BEGIN_SRC elisp
; He noticed that as in the previous exercise, some queries
; will return more results that the expected, so for example
; if he tries to calculate the sum of salaries of all wheels
; the result will be incorrect:
(sum ?amount
     (and (wheel ?who)
          (salary ?who ?amount)))

; what he can do is to filter duplicated entries.
#+END_SRC

*** Exercise 4.67
#+BEGIN_SRC elisp
; Pend
#+END_SRC

*** Exercise 4.68
#+BEGIN_SRC elisp
     (rule (append-to-form () ?y ?y))

     (rule (append-to-form (?u . ?v) ?y (?u . ?z))
           (append-to-form ?v ?y ?z))


(rule (reverse () ()))                 ; base case
(rule (reverse ?x ?y)
      (and (append-to-form ?u ?v ?x)   ; ?u + ?v => ?x
           (append-to-form ?w ?u ?y)   ; ?w + ?u => ?y
           (reverse ?v ?w)))           ; ?v => reverse ?w
#+END_SRC

*** Exercise 4.69
#+BEGIN_SRC elisp
; Pend
#+END_SRC

*** Exercise 4.70
#+BEGIN_SRC elisp
; As mentioned in the exercise, the idea is to create a lexical scoped variable
; that holds the string and then `set!' our variable as wished. This will prevent
; from generating an infinite loop while doing the assignment.
#+END_SRC

*** Exercise 4.71
#+BEGIN_SRC elisp
; PEND
#+END_SRC

*** Exercise 4.72
#+BEGIN_SRC elisp
; Recalling the exercise in chapter 3, since we're working
; with arbitrarily sized (sometimes infinite) streams, we use
; interleave so we can explore/extract data from the multiple
; streams and not just one in the hope it finishes to begin
; processing the next stream.
#+END_SRC

*** Exercise 4.73
#+BEGIN_SRC elisp
; we must delay `flatten-stream' evaluation so the `interleave-delayed'
; procedure can interleave the streams, in the line
;      (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))
#+END_SRC

*** Exercise 4.74
#+BEGIN_SRC elisp
(defun simple-stream-flatmap (proc s)
  (simple-flatten (stream-map proc s)))

(defun simple-flatten (stream)
  (stream-map 'stream-car
              (stream-filter (lambda (x) (not (stream-null? x)))
                             stream)))

b. She's right, since we're only appending singleton streams, there's
   no need to interleave the streams.
#+END_SRC

*** Exercise 4.75
#+BEGIN_SRC elisp
; PEND
#+END_SRC

*** Exercise 4.76
#+BEGIN_SRC elisp
; PEND
#+END_SRC

*** Exercise 4.77
#+BEGIN_SRC elisp
; Pend
#+END_SRC

*** Exercise 4.78
#+BEGIN_SRC elisp
; Pend
#+END_SRC

*** Exercise 4.79
#+BEGIN_SRC elisp
; Pend
#+END_SRC

* Chapter 5
** 5.1 Computing with Register Machines
#+BEGIN_SRC elisp
  (data-paths
   (registers
    ((name a)
     (buttons ((name a<-b) (source (register b)))))
    ((name b)
     (buttons ((name b<-t) (source (register t)))))
    ((name t)
     (buttons ((name t<-r) (source (operation rem)))))))

  (operations
   ((name rem)
    (inputs (register a) (register b)))
   ((name =)
    (inputs (register b) (constant 0))))

  (controller
   test-b                        ; label
     (test =)                    ; test
     (branch (label gcd-done))   ; conditional branch
     (t<-r)                      ; push button
     (a<-b)                      ; push button
     (b<-t)                      ; push button
     (goto (label test-b))       ; unconditional branch
   gcd-done)                     ; label

  ;; another way to write it
  (controller
   test-b
     (test (op =) (reg b) (const 0))
     (branch (label gcd-done))
     (assign t (op rem) (reg a) (reg b))
     (assign a (reg b))
     (assign b (reg t))
     (goto (label test-b))
   gcd-done)
#+END_SRC

*** 5.1.5 Instruction Summary
#+BEGIN_SRC elisp
  (assign <REGISTER-NAME> (reg <REGISTER-NAME>>))
  (assign <REGISTER-NAME> (const <CONSTANT-VALUE>))
  (assign <REGISTER-NAME> (op <OPERATION-NAME>) <INPUT_1> ... <INPUT_N>)
  (perform (op <REGISTER-NAME>) <INPUT_1> ... <INPUT_N>)
  (test (op <OPERATION-NAME>) <INPUT_1> ... <INPUT_N>)
  (branch (label <LABEL-NAME>))
  (goto (label <LABEL-NAME>))

  ; Use register to hold labels
  (assign <REGISTER-NAME> (label <LABEL-NAME>))
  (goto (reg <REGISTER-NAME>))

  ; stack operations
  (save <REGISTER-NAME>)
  (restore <REGISTER-NAME>)
#+END_SRC
** 5.2 A Register-Machine Simulator
   The interface procedures for the register machine are:
#+BEGIN_SRC elisp
   ; 1. Construct a model of the machine
   (make-machine <REGISTER-NAMES> <OPERATIONS> <CONTROLLER>)

   ; 2. Stores a value in a simulated machine
   (set-register-contents! <MACHINE-MODEL> <REGISTER-NAME> <VALUE>)

   ; 3. Returns the contents of a simulated register in the given machine
   (get-register-contents <MACHINE-MODEL> <REGISTER-NAME>)

   ; 4. Simulates the execution of the given machine
   (start <MACHINE-MODEL>)
#+END_SRC
*** 5.2.1 The Machine Model
#+BEGIN_SRC elisp
   ;; Instruction summary
    <INPUT_I> can be either (reg <REGISTER-NAME>) or (const <CONSTANT-VALUE>)

    (assign <REGISTER-NAME> (reg <REGISTER-NAME>))
    (assign <REGISTER-NAME> (const <CONSTANT-VALUE>))
    (assign <REGISTER-NAME> (op <OPERATION-NAME>) <INPUT_1> ... <INPUT_N>)
    (assign <REGISTER-NAME> (label <LABEL-NAME>))

    (perform (op <OPERATION-NAME>) <INPUT_1> ... <INPUT_N>)

    (test (op <OPERATION-NAME>) <INPUT_1> ... <INPUT_N>)
    (branch (label <LABEL-NAME>))

    (goto (label <LABEL-NAME>))
    (goto (reg <REGISTER-NAME>))

    (save <REGISTER-NAME>)
    (restore <REGISTER-NAME>)
   ;; End summary

   ;; Example defining the gcd-machine
     (setq gcd-machine
           (make-machine
            '(a b t)
            '(('rem '%) ('= '=))
            '(test-b
                (test (op =) (reg b) (const 0))
                (branch (label gcd-done))
                (assign t (op rem) (reg a) (reg b))
                (assign a (reg b))
                (assign b (reg t))
                (goto (label test-b))
              gcd-done)))
   ;; End example

   (defun for-each (fun lst)
     (if (null lst)
         nil
       (funcall fun (car lst))
       (for-each fun (cdr lst))))

  (for-each (lambda (x) (insert (format "%S " x)))
            '(1 2 3 4 5))
   ; => 1 2 3 4 5

   (defun make-machine (register-names ops controller-text)
     (lexical-let ((machine (make-new-machine)))
       (for-each (lambda (register-name)
                   (funcall (funcall machine 'allocate-register) register-name))
                 register-names)
       (funcall (funcall machine 'install-operations) ops)
       (funcall (funcall machine 'install-instruction-sequence)
                (assemble controller-text machine))
       machine))

   ;; Registers
   (defun make-register (nam)
     (lexical-let ((contents '*unassigned)
                   (name nam)
                   (dispatch nil))
       (setq dispatch
             (lambda (message)
               (cond ((eq message 'get) contents)
                     ((eq message 'set)
                      (lambda (value) (setq contents value)))
                     ((eq message 'name) name)
                     (t
                      (error "Unknown request -- %S REGISTER" message)))))
       dispatch))

   (setq t-register (make-register 't-register))
   (funcall t-register 'name) ; => t-register
   (funcall t-register 'get)  ; => *unassigned
   (funcall (funcall t-register 'set) 25) ; => 25
   (funcall t-register 'get)  ; => 25

   (defun set-contents! (register value)
     (funcall (funcall register 'set) value))
   (set-contents! t-register 100) ; => 100

   (defun get-contents (register)
     (funcall register 'get))
   (get-contents t-register) ; => 100

   ;; Stack
   (defun make-stack ()
     (lexical-let ((s '())
                   (push nil)
                   (pop nil)
                   (init nil)
                   (dispatch nil))
       (setq push (lambda (x)
                    (setq s (cons x s))))
       (setq pop (lambda ()
                   (if (null s)
                       (error "Empty stack -- POP")
                     (let ((top (car s)))
                       (setq s (cdr s))
                       top))))
       (setq init (lambda ()
                    (setq s '())
                    'done))
       (setq dispatch (lambda (message)
                        (cond ((eq message 'push) push)
                              ((eq message 'pop) (funcall pop))
                              ((eq message 'initialize) (funcall init))
                              (t (error "Unknown request -- %S STACK"
                                        message)))))
       dispatch))

   (setq t-stack (make-stack))
   (funcall (funcall t-stack 'push) 100) ; (100)
   (funcall t-stack 'pop) ; => 100
   (funcall t-stack 'pop) ; => Error...
   (funcall t-stack 'initialize) ; =>  done

   (defun stack-push (stack val)
     (funcall (funcall stack 'push) val))
   (stack-push t-stack 'val1) ; => (val1)
   (stack-push t-stack 'val2) ; => (val2 val1)

   (defun stack-pop (stack)
     (funcall stack 'pop))
   (stack-pop t-stack) ; => val2
   (stack-pop t-stack) ; => val1
   (stack-pop t-stack) ; => Error ...

   ;; The basic machine
   (defun instruction-execution-proc (inst)
     (cdr inst))

   (defun make-new-machine ()
     (lexical-let* ((pc (make-register 'pc))
                    (flag (make-register 'flag))
                    (stack (make-stack))
                    (the-instruction-sequence '())
                    (the-ops
                     (list (list 'initialize-stack
                                 (lambda () (funcall stack 'initialize)))))
                    (register-table
                     (list (list 'pc pc) (list 'flag flag)))

                     ; the local procedures
                    (allocate-register nil)
                    (lookup-register nil)
                    (execute nil)
                    (dispatch nil))
       (setq allocate-register
             (lambda (name)
               (if (assoc name register-table)
                   (error "Multiply defined register: %S" name)
                 (setq register-table
                       (cons (list name (make-register name))
                             register-table)))
               'register-allocated))
       (setq lookup-register
             (lambda (name)
               (let ((val (assoc name register-table)))
                 (if val
                     (cadr val)
                   (error "Unknown register: %S" name)))))
       (setq execute
             (lambda ()
               (let ((insts (get-contents pc)))
                 (if (null insts)
                     'done
                   (progn
                     (funcall (instruction-execution-proc (car insts)))
                     (funcall execute))))))
       (setq dispatch
             (lambda (message)
               (cond ((eq message 'start)
                      (set-contents! pc the-instruction-sequence)
                      (funcall execute))
                     ((eq message 'install-instruction-sequence)
                      (lambda (seq) (setq the-instruction-sequence seq)))
                     ((eq message 'allocate-register) allocate-register)
                     ((eq message 'get-register) lookup-register)
                     ((eq message 'install-operations)
                      (lambda (ops) (setq the-ops (append the-ops ops))))
                     ((eq message 'get-operations) the-ops)
                     ((eq message 'stack) stack)
                     ((eq message 'operations) the-ops)
                     (t (error "Unknown request -- MACHINE" message)))))
       dispatch))
   (setq t-new-machine (make-new-machine))

   (defun start-machine (machine)
     (funcall machine 'start))

   (defun get-machine-register (machine reg-name)
     (funcall (funcall machine 'get-register) reg-name))
   (get-machine-register t-new-machine 'pc) ; ...

   (defun get-register-contents (machine register-name)
     (get-contents (get-machine-register machine register-name)))
   (get-register-contents t-new-machine 'pc)    ; => *unassigned
   (get-register-contents t-new-machine 'flag)   ; => *unassigned
   (get-register-contents t-new-machine 'other)  ; error ...

   (defun set-register-contents! (machine register-name value)
     (set-contents! (get-machine-register machine register-name) value)
     'done)
   (set-register-contents! t-new-machine 'pc 'pc-test) ; => done
   (get-register-contents t-new-machine 'pc) ; => pc-test

   ;; 5.2.2 The Assembler
   (defun make-label-entry (label-name insts)
     (cons label-name insts))
   (make-label-entry 'test-b
                     '((test (op =) (reg b) (const 0))
                       (branch (label gcd-done))
                       (assign t (op rem) (reg a) (reg b))
                       (assign a (reg b))
                       (assign b (reg t))
                       (goto (label test-b)))) ;  (test-b ...

   (defun lookup-label (labels label-name)
     (let ((val (assoc label-name labels)))
       (if val
           (cdr val)
         (error "Undefined label %S -- ASSEMBLE" label-name))))
   (lookup-label '((label-1 code) (label-2 code) (label-3 code)) 'label-1) ; => (code)
   (lookup-label '((label-1 code) (label-2 code) (label-3 code)) 'label-4) ; => error ...

   (defun tagged-list? (exp tag)
     (if (consp exp)
         (eq (car exp) tag)
       nil))

   (defun register-exp? (exp) (tagged-list? exp 'reg))
   (register-exp? '(reg a)) ; => t
   (register-exp? '(op =))  ; => nil

   (defun register-exp-reg (exp) (cadr exp))
   (register-exp-reg '(reg a)) ; => a

   (defun constant-exp? (exp) (tagged-list? exp 'const))
   (constant-exp? '(const 10)) ; => t

   (defun constant-exp-value (exp) (cadr exp))
   (constant-exp-value '(const 10)) ; => 10

   (defun label-exp? (exp) (tagged-list? exp 'label))
   (label-exp? '(label some-label)) ; => t

   (defun label-exp-label (exp) (cadr exp))
   (label-exp-label '(label some-label)) ; => some-label

   (defun operation-exp? (exp)
     (and (consp exp) (tagged-list? (car exp) 'op)))
   (operation-exp? '((op =) (reg a) (const 1))) ; => t

   (defun operation-exp-op (operation-exp)
     (cadr (car operation-exp)))
   (operation-exp-op '((op =) (reg a) (const 1))) ; => =

   (defun operation-exp-operands (operation-exp)
     (cdr operation-exp))
   (operation-exp-operands '((op =) (reg a) (const 1)))
   ;; => ((reg a) (const 1))

   (defun lookup-prim (symbol operations)
     (let ((val (assoc symbol operations)))
       (if val
           (cadr val)
         (error "Unknown operation -- ASSEMBLE" symbol))))

   (defun make-operation-exp (exp machine labels operations)
     (lexical-let ((op (lookup-prim (operation-exp-op exp) operations))
                   (aprocs
                    (mapcar (lambda (e)
                              (make-primitive-exp e machine labels))
                            (operation-exp-operands exp))))
       (lambda ()
         (apply op (mapcar (lambda (p) (funcall p)) aprocs)))))

   (defun make-primitive-exp (exp machine labels)
     (cond ((constant-exp? exp)
            (lexical-let ((c (constant-exp-value exp)))
              (lambda () c)))
           ((label-exp? exp)
            (lexical-let ((insts
                           (lookup-label labels
                                         (label-exp-label exp))))
              (lambda () insts)))
           ((register-exp? exp)
            (lexical-let ((r (get-machine-register machine
                                                   (register-exp-reg exp))))
              (lambda () (get-contents r))))
           (t (error "Unknown expression type -- ASSEMBLE" exp))))

   (defun assign-reg-name (assign-instruction)
     (cadr assign-instruction))
   (assign-reg-name '(assign b (reg t))) ; => b

   (defun assign-value-exp (assign-instruction)
     (cddr assign-instruction))
   (assign-value-exp '(assign b (reg t))) ; => ((reg t))

  (defun make-assign (inst machine labels operations pc)
    (lexical-let* ((target (get-machine-register machine (assign-reg-name inst)))
                   (value-exp (assign-value-exp inst))
                   (value-proc
                    (if (operation-exp? value-exp)
                        (make-operation-exp
                         value-exp machine labels operations)
                      (make-primitive-exp
                       (car value-exp) machine labels))))
      (lambda ()
        (set-contents! target (funcall value-proc))
        (advance-pc pc))))

   (defun advance-pc (pc)
     (set-contents! pc (cdr (get-contents pc))))

   (defun test-condition (test-instruction)
     (cdr test-instruction))
   (test-condition '(test (op =) (reg b) (const 0)))
   ;; => ((op =) (reg b) (const 0))

   (defun make-test (inst machine labels operations flag pc)
     (let ((condition (test-condition inst)))
       (if (operation-exp? condition)
           (lexical-let ((fl flag)
                         (p  pc)
                         (condition-proc
                          (make-operation-exp
                           condition machine labels operations)))
             (lambda ()
               (set-contents! fl (funcall condition-proc))
               (advance-pc p)))
         (error "Bad Test instruction %S -- ASSEMBLE" inst))))

   (defun branch-dest (branch-instruction)
     (cadr branch-instruction))
   (branch-dest '(branch (label gcd-done))) ; => (label gcd-done)

   (defun make-branch (inst machine labels flag pc)
     (let ((dest (branch-dest inst)))
       (if (label-exp? dest)
           (lexical-let ((fl flag)
                         (p pc )
                         (insts
                          (lookup-label labels (label-exp-label dest))))
             (lambda ()
               (if (get-contents fl)
                   (set-contents! p insts)
                 (advance-pc p))))
         (error "Bad BRANCH instruction %S -- ASSEMBLE" inst))))

   (defun goto-dest (goto-instruction)
     (cadr goto-instruction))

   (defun make-goto (inst machine labels pc)
     (lexical-let ((dest (goto-dest inst))
                   (p pc))
       (cond ((label-exp? dest)
              (lexical-let ((insts
                             (lookup-label labels
                                           (label-exp-label dest))))
                (lambda () (set-contents! p insts))))
             ((register-exp? dest)
              (lexical-let ((reg
                             (get-machine-register machine
                                                   (register-exp-reg dest))))
                (lambda ()
                  (set-contents! p (get-contents reg)))))
             (t (error "Bad GOTO %S instruction -- ASSEMBLE" inst)))))

   (defun stack-inst-reg-name (stack-instruction)
     (cadr stack-instruction))
   (stack-inst-reg-name '(save reg)) ; => reg

   (defun make-save (inst machine stack pc)
     (lexical-let ((s stack)
                   (p pc)
                   (reg (get-machine-register machine
                                              (stack-inst-reg-name inst))))
       (lambda ()
         (stack-push s (get-contents reg))
         (advance-pc p))))

   (defun make-restore (inst machine stack pc)
     (lexical-let ((s stack)
                   (p pc)
                   (reg (get-machine-register machine
                                              (stack-inst-reg-name inst))))
       (lambda ()
         (set-contents! reg (stack-pop s))
         (advance-pc p))))

   (defun perform-action (inst) (cdr inst))
   (perform-action '(perform (op rem) (reg a) (reg b)))
   ; => ((op rem) (reg a) (reg b))

   (defun make-perform (inst machine labels operations pc)
     (let ((action (perform-action inst)))
       (if (operation-exp? action)
           (lexical-let ((p pc)
                         (action-proc
                          (make-operation-exp
                           action machine labels operations)))
             (lambda ()
               (funcall action-proc)
               (advance-pc p)))
         (error "Bad PERFORM instruction --ASSEMBLE" inst))))

   (defun make-execution-procedure (inst labels machine pc flag stack ops)
     (let ((name (car inst)))
       (cond ((eq name 'assign)
              (make-assign inst machine labels ops pc))
             ((eq name 'test)
              (make-test inst machine labels ops flag pc))
             ((eq name 'branch)
              (make-branch inst machine labels flag pc))
             ((eq name 'goto)
              (make-goto inst machine labels pc))
             ((eq name 'save)
              (make-save inst machine stack pc))
             ((eq name 'restore)
              (make-restore inst machine stack pc))
             ((eq name 'perform)
              (make-perform inst machine labels ops pc))
             (t (error "Unknown instruction type -- %S ASSEMBLE" inst)))))

   (defun make-instruction (text)
     (cons text '()))
   (setq t-instruction (make-instruction '(assign (reg b) (reg a))))
   ; => ((assign (reg b) (reg a)))

   ;; The format of an instruction is a list of the following form (<INST> <EXEC-PROC>)
   ;; where INST is the instruction text and EXEC-PROC is the machine code
   ;; to be executed by the register machine
   (defun instruction-text (inst)
     (car inst))
   (instruction-text t-instruction) ; => (assign (reg b) (reg a))

   (defun set-instruction-execution-proc! (inst proc)
     (setcdr inst proc))
   (set-instruction-execution-proc! t-instruction 'some-proc) ; => some-proc

   (defun get-instruction-execution-proc (inst)
     (cdr inst))
   (get-instruction-execution-proc t-instruction) ; => some-proc

  (defun update-insts! (insts labels machine)
    (let ((pc (get-machine-register machine 'pc))
          (flag (get-machine-register machine 'flag))
          (stack (funcall machine 'stack))
          (ops (funcall machine 'operations)))
      (for-each
       (lambda (inst)
         (set-instruction-execution-proc!
          inst
          (make-execution-procedure
           (instruction-text inst) labels machine pc flag stack ops)))
       insts)))

  (defun extract-labels (txt rcv)
     (lexical-let ((text txt)
                   (receive rcv))
       (if (null text)
           (funcall receive '() '())
         (extract-labels (cdr text)
                         (lambda (insts labels)
                           (let ((next-inst (car text)))
                             (if (symbolp next-inst)
                                 (funcall receive insts
                                          (cons (make-label-entry next-inst
                                                                  insts)
                                                labels))
                               (funcall receive (cons (make-instruction next-inst)
                                                    insts)
                                      labels))))))))

  (defun assemble (controller-text machine)
    (lexical-let ((mach machine))
      (extract-labels controller-text
                      (lambda (insts labels)
                        (update-insts! insts labels mach)
                        insts))))

   ; Another version for extract labels
   (defun extract-labels (text)
     (if (null text)
         (cons '() '())
       (let ((result (extract-labels (cdr text))))
         (let ((insts (car result)) (labels (cdr result)))
           (let ((next-inst (car text)))
             (if (symbolp next-inst)
                 (cons insts
                       (cons (make-label-entry next-inst insts) labels))
               (cons (cons (make-instruction next-inst) insts)
                     labels)))))))

   ;; Uses second version of `extract-labels'
   (defun assemble (controller-text machine)
     (let* ((result (extract-labels controller-text))
            (insts (car result))
            (labels (cdr result)))
       (update-insts! insts labels machine)
       insts))
#+END_SRC

** Exercises
*** Exercise 5.1
#+BEGIN_SRC elisp

(defun factorial (n)
  (defun iter (product counter)
    (if (> counter n)
        product
      (iter (* counter product)
            (+ counter 1))))
  (iter 1 1))

;; Factorial Machine


               / \            /  \
              / 1 \          /  1 \
             +--+--+         +--+--+
                |               |
               (x) p<-1        (x)  c<-1
                |               |                                     ___
           +----+----+     +----+----+                               /   \
      +--->| product |     | counter +<------------------+--------->|  >  |
      |    +----+----+     +----+----+       /  \        |           \___/
      |         |               |           /  1 \       |             ^
     (x) p<-r1  |     +---------+--------+  +--+--+     (x) c<-r2      |
      |         |     |                  |     |         |          +-----+
      |      .--+-----+--.            .--+-----+--.      |          |  n  |
      |      \     *    /             \    +     /       |          +-----+
      |       \________/               \________/        |
      |            |                        |            |
      +------------+                        +------------+

;; Controller for factorial machine

               start
                 |
                 V
             +-------+
             |  p<-1 |
             +---+---+
                 |
                 V
             +-------+
             |  c<-1 |
             +---+---+
                 |
                 V
                / \ yes
          +--->< = >-----> done
          |     \ /
          |      | no
          |      V
          |  +-------+
          |  | p<-r1 |
          |  +---+---+
          |      |
          |      V
          |  +-------+
          +--+ p<-r2 |
             +-------+

#+END_SRC

*** Exercise 5.2
#+BEGIN_SRC elisp
(controller
   (assign (reg p) (const 1))
   (assign (reg c) (const 1))
 test-c
   (test (op >) (reg c) (reg n))
   (branch (label factorial-done))
   (assign (reg p) (op *) (reg p) (reg c))
   (assign (reg c) (op +) (reg c) (const 1))
 factorial-done)
#+END_SRC

*** Exercise 5.3
#+BEGIN_SRC elisp
  (defun sqrt (x)
    (defun good-enough? (guess )
      (< (abs (- (square guess) x)) 0.001))
    (defun improve (guess)
      (average guess (/ x guess)))
    (defun sqrt-iter (guess)
      (if (good-enough? guess)
          guess
        (sqrt-iter (improve guess))))
    (sqrt-iter 1.0))

  ; Data Path
                                                 .--------.
                                                  \ read /
                                   / \             \____/
                                  / 1 \               |
                                 /_____\             (X)
                                    |                 |
                                +---+---+         +---+---+
             +-----------+----->| guess |         |   x   +------------------+
             |           |      +---+---+         +---+---+                  |
             V           |          |                 |                      |
        .---------.      |          *----------*------|-------------+        |
  --(X)->\ print /      (X)         |          |      |             |        |
          \_____/        |          |          V      V          ---+---     |
                         |          |        .----------.        |     |     |
                         |          |         \    /   /         V     V     |
                         |          |          \______/         .-------.    |
                         |          |              |             \  *  /     |
                         |          +--------+  +-----+           \___/      |
                         |                   |  | div |             |        |
                         |                   |  +--+--+             V        |
                         |                   |     |             +------+    |
                         |                   V     V             |square|    |
                         |                 .----------.          +--+---+    |
                         |                  \    +   /              |        |
                         |                   \______/               V        V
                         |                       |                .------------.
                         |            / \      +---+               \     -    /
                         |           / 2 \     |sum|                \________/
                         |          /_____\    +-+-+                     |
                         |             |         |                    +--+--+
                         |             V         V                    |good?|
                         |            .-----------.                   +--+--+
                         |            \     /     /                      |
                         |             \_________/                      ---
                         |                  |                          /   \
                         +------------------+                         |  <  |
                                                                       \___/
                                                                         ^
                                                                         |
                                                                        / \
                                                                       /   \
                                                                      /0.001\
                                                                      -------
  ; controller code
  (controller
   sqrt-loop
     (assign x (op read))
     (assign guess (const 1))
   test-good?
     (assign square (op *) (reg guess) (reg guess))
     (assign good? (op -) (reg square) (reg x))
     (test (op <) (reg good?) (const 0.001))
     (branch (label sqrt-done))
     (assign div (op /) (reg guess) (reg x))
     (assign sum (op +) (reg guess) (reg div))
     (assign guess (op /) (reg sum) (const 2))
     (goto (label test-good?))
   sqrt-done
     (perform (op print) (reg guess))
     (goto (label sqrt-loop)))
#+END_SRC

*** Exercise 5.4
#+BEGIN_SRC elisp
; a. Recursive exponentiation
(defun expt (b n)
  (if (= n 0)
      1
    (* b (expt b (- n 1)))))

; Data path
     _
    / \
   /_0_\
     |
     V
    ---
   /   \          +-----+               +---------+
  |  =  |<--------|  n  +<----+         |  stack  |
   \___/          +-----+     |         +-------+-+
           _         |        |            ^    |
          / \        |        |            |    |
         /_1_\       |        |            |    |
           |         |        |            |    |
           +-----+   |       (X)          (X)  (X)
           |     |   |        |            |    |
          (X)   .-------.     |            |    V
           |     \  -  /      |          +-+--------+
           V      \___/       |          | continue |
       +-------+    |         |          +-+----+---+
       |  val  |    +---------+            |    |
       +-------+                          (X)  (X)
                                           |    |
                                          /_\  /_\
                                        expt-  after-
                                        done   loop
; Controller code
(controller
    (assign continue (label expt-done))
  expt-loop
    (test (op =) (reg n) (const 0))
    (branch (label base-case))
    (save continue)
    (assign continue (label after-loop))
    (assign n (op -) (reg n) (const 1))
    (goto (label expt-loop))
  after-loop
    (restore continue)
    (assign val (op *) (reg b) (reg val))
    (goto (reg continue))
  base-case
    (assign val (const 1))
    (goto (reg continue))
  expt-done)

; b. Iterative exponentiation
(defun expt (b n)
  (defun expt-iter (counter product)
    (if (= counter 0)
        product
      (expt-iter (- counter 1) (* b product))))
  (expt-iter n 1))


; Data Path
            +---+
            | n |          / \	               / \
            +-+-+         / 0 \		      / 1 \
              |          /_____\	     /_____\
             (X)            |                   |
              |             |       +-----------*
              V             V       |           |
         +---------+       / \      |          (X)
    ---->+ counter +----->| = |     |           |
    |    +-+-------+       \_/      |           V
    |      |                        |      +-+--+-----+   +---+
    |      |     +------------------+   +->+ product  |   | b |
    |      V     V                      |  +----+-----+   +---+
    |   .-----------.                   |       |           |
    |    \    -    /                    |    .--+-----------+--.
    |     \_______/                    (X)    \       *       /
    |         |                         |      \_____________/
    +---------+                         |             |
                                        +-------------+
; Controller code
(controller
    (assign counter (reg n))
    (assign product (const 1))

  expt-iter
    (test (op =) (reg counter) (const 0))
    (goto (label expt-iter-done))
    (assign counter (op -) (reg counter) (const 1))
    (assign product (op *) (reg b) (reg product))
    (goto (label expt-iter))
  expt-iter-done)
#+END_SRC

*** Exercise 5.5
#+BEGIN_SRC elisp
;; Factorial with input n=2

first iter:
stack: 'fact-done '2
registers: n=1, continue=after-fact

second iter:
(call to 'base-case)
  stack: 'fact-done '2
  registers: val=1

(call to 'after-fact)
stack: <empty>
registers: n=2, continue=fact-done, val=2

(call to ' fact-done)

;; Fibonacci input n=2

first iter:
stack: 'fib-done, 2
registers: continue=afterfib-n-1, n=1

second iter:

(call to immediate-answer)
registers: val=2

(call to afterfib-n-1)
stack: 'fib-done '2
registers: n=0, continue=afterfib-n-2

(call to fib-loop) (call to immediate-answer)
registers: val=0

(call to afterfib-n-2)
stack:
registers: n=0, val=2, continue=fib-done

(call to fib-done)
#+END_SRC

*** Exercise 5.6
#+BEGIN_SRC elisp
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   ;; set up to compute _Fib_(n - 1)
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                           ; save old value of `n'
   (assign n (op -) (reg n) (const 1)); clobber `n' to n - 1
   (goto (label fib-loop))            ; perform recursive call
 afterfib-n-1                         ; upon return, `val' contains _Fib_(n - 1)
   (restore n)
   (restore continue)                     ;; *** EXTRA ***
   ;; set up to compute _Fib_(n - 2)
   (assign n (op -) (reg n) (const 2))
   (save continue)                        ;; *** EXTRA ***
   (assign continue (label afterfib-n-2))
   (save val)                         ; save _Fib_(n - 1)
   (goto (label fib-loop))
 afterfib-n-2                         ; upon return, `val' contains _Fib_(n - 2)
   (assign n (reg val))               ; `n' now contains _Fib_(n - 2)
   (restore val)                      ; `val' now contains _Fib_(n - 1)
   (restore continue)
   (assign val                        ;  _Fib_(n - 1) +  _Fib_(n - 2)
           (op +) (reg val) (reg n))
   (goto (reg continue))              ; return to caller, answer is in `val'
 immediate-answer
   (assign val (reg n))               ; base case:  _Fib_(n) = n
   (goto (reg continue))
 fib-done)
#+END_SRC

*** Exercise 5.7
#+BEGIN_SRC elisp
  ;; super simple machine
    (setq my-machine
          (make-machine
           '(a b t)
           '((rem %) (= =))
           '((assign a (const 10)))))

  (set-register-contents! my-machine 'a 0)
  (get-register-contents my-machine 'a) ; => 0
  (start-machine my-machine) ; => done
  (get-register-contents my-machine 'a) ; => 10

  (setq gcd-machine
        (make-machine
           '(a b t)
           '((rem %) (= =) (insert (lambda (x) (insert (format "%d " x)))))
           '(test-b
               (test (op =) (reg b) (const 0))
               (branch (label gcd-done))
               (assign t (op rem) (reg a) (reg b))
               (assign a (reg b))
               (assign b (reg t))
               (goto (label test-b))
             gcd-done
               (perform (op insert) (reg a)))))

  (set-register-contents! gcd-machine 'a 18) ; done
  (set-register-contents! gcd-machine 'b 12) ; done
  (start-machine gcd-machine) ; => 6 done
  (get-register-contents gcd-machine 'a) ; => 6

  ;; Controller code for expt
  (setq expt
        (make-machine
         '(n b val continue)
         '((= =) (- -) (* *))
         '(begin
             (assign continue (label expt-done))
           expt-loop
             (test (op =) (reg n) (const 0))
             (branch (label base-case))
             (save continue)
             (assign continue (label after-loop))
             (assign n (op -) (reg n) (const 1))
             (goto (label expt-loop))
           after-loop
             (restore continue)
             (assign val (op *) (reg b) (reg val))
             (goto (reg continue))
           base-case
             (assign val (const 1))
             (goto (reg continue))
           expt-done)))

  (set-register-contents! expt 'n 8)
  (set-register-contents! expt 'b 2)
  (start-machine expt)
  (get-register-contents expt 'val) ; => 256


  ;; Controller code for expt-iter
  (setq expt-iter
        (make-machine
         '(n b counter product)
         '((= =) (- -) (* *) (print (lambda (x) (insert (format "%d " x)))))
         '(begin
             (assign counter (reg n))
             (assign product  (const 1))
           expt-iter
             (test (op =) (reg counter) (const 0))
             (branch (label expt-iter-done))
             (assign counter (op -) (reg counter) (const 1))
             (assign product (op *) (reg b) (reg product))
             (goto (label expt-iter))
           expt-iter-done
              (perform (op print) (reg product)))))

  (set-register-contents! expt-iter 'n 8)
  (set-register-contents! expt-iter 'b 2)
  (start-machine expt-iter)   ; => 256 done
  (get-register-contents expt -iter 'counter) ; => 0
  (get-register-contents expt-iter 'product) ; => 256
#+END_SRC

*** Exercise 5.8
#+BEGIN_SRC elisp
(start
  (goto (label here))
 here
  (assign a (const 3))
  (goto (label there))
 here
  (assign a (const 4))
  (goto (label there))
 there)

; Register `a' will contain 3

(defun extract-labels (text receive)
  (if (null text)
      (funcall receive '() '())
    (extract-labels (cdr text)
                    (lambda (insts labels)
                      (let ((next-inst (car text)))
                        (if (symbolp next-inst)
                            (if (assoc next-inst labels)
                                (error "Duplicated label %S -- EXTRACT-LABELS"
                                       next-inst)
                              (funcall receive insts
                                       (cons (make-label-entry next-inst
                                                               insts)
                                             labels)))
                          (funcall receive (cons (make-instruction next-inst)
                                                 insts)
                                   labels)))))))
#+END_SRC

*** Exercise 5.9
#+BEGIN_SRC elisp
(defun make-operation-exp (exp machine labels operations)
  (lexical-let ((op (lookup-prim (operation-exp-op exp) operations))
                (aprocs
                 (mapcar (lambda (e)
                           (if (or (register-exp? e)
                                   (constant-exp? e))
                               (make-primitive-exp e machine labels)
                             (error "Operation bad operands %S -- ASSEMBLE" e)))
                         (operation-exp-operands exp))))
    (lambda ()
      (apply op (mapcar (lambda (p) (funcall p)) aprocs)))))
#+END_SRC

*** Exercise 5.10
#+BEGIN_SRC elisp
;; new syntax
;; (assign let-register)
;; (test   try)
;; (branch cond-jump)
;; (save   save)
;; (goto   icond-jump)
;; (restore retrieve)

;; to modify the basic commands, we just need to alter the following
;; procedure.
(defun ex5.10/make-execution-procedure (inst labels machine pc flag stack ops)
  (let ((name (car inst)))
    (cond ((eq name 'let-register)
           (make-assign inst machine labels ops pc))
          ((eq name 'try)
           (make-test inst machine labels ops flag pc))
          ((eq name 'cond-jump)
           (make-branch inst machine labels flag pc))
          ((eq name 'icond-jump)
           (make-goto inst machine labels pc))
          ((eq name 'save)
           (make-save inst machine stack pc))
          ((eq name 'retrieve)
           (make-restore inst machine stack pc))
          ((eq name 'perform)
           (make-perform inst machine labels ops pc))
          (t (error "Unknown instruction type -- %S ASSEMBLE" inst)))))

;; In case we wanted to modify how the parameters are passed and the name
;; of the operator types we would need to modify the following procedures

(defun register-exp? (exp) (tagged-list? exp 'reg))
(defun register-exp-reg (exp) (cadr exp))

(defun constant-exp? (exp) (tagged-list? exp 'const))
(defun constant-exp-value (exp) (cadr exp))

(defun label-exp? (exp) (tagged-list? exp 'label))
(defun label-exp-label (exp) (cadr exp))

(defun operation-exp? (exp)
  (and (consp exp) (tagged-list? (car exp) 'op)))

(defun operation-exp-op (operation-exp)
  (cadr (car operation-exp)))

(defun operation-exp-operands (operation-exp)
  (cdr operation-exp))
(operation-exp-operands '((op =) (reg a) (const 1)))
#+END_SRC

*** Exercise 5.11
#+BEGIN_SRC elisp
  ;; a.
  ;; in `afterfib-n-2' register `val' contains f(n-2) already so just restore
  ;; to register `n'  so it contains f(n-1)
  (controller
     (assign continue (label fib-done))
   fib-loop
     (test (op <) (reg n) (const 2))
     (branch (label immediate-answer))
     ;; set up to compute _Fib_(n - 1)
     (save continue)
     (assign continue (label afterfib-n-1))
     (save n)                           ; save old value of `n'
     (assign n (op -) (reg n) (const 1)); clobber `n' to n - 1
     (goto (label fib-loop))            ; perform recursive call
   afterfib-n-1                         ; upon return, `val' contains _Fib_(n - 1)
     (restore n)
     ;; set up to compute _Fib_(n - 2)
     (assign n (op -) (reg n) (const 2))
     (assign continue (label afterfib-n-2))
     (save val)                         ; save _Fib_(n - 1)
     (goto (label fib-loop))
   afterfib-n-2                         ; upon return, `val' contains _Fib_(n - 2)
     (restore n)                        ; `n' now contains _Fib_(n - 1)
  ; ** DELETE **    (restore val)       ; `val' now contains _Fib_(n - 1)  ** DELETE **
     (restore continue)
     (assign val                        ;  _Fib_(n - 1) +  _Fib_(n - 2)
             (op +) (reg val) (reg n))
     (goto (reg continue))              ; return to caller, answer is in `val'
   immediate-answer
     (assign val (reg n))               ; base case:  _Fib_(n) = n
     (goto (reg continue))
   fib-done)

  ;; b.
     (defun make-save (inst machine stack pc)
       (lexical-let ((s stack)
                     (p pc)
                     (reg-name (stack-inst-reg-name inst))
                     (reg (get-machine-register machine
                                                reg-name)))
         (lambda ()
           (stack-push s (cons stack-name (get-contents reg)))
           (advance-pc p))))

     (defun make-restore (inst machine stack pc)
       (lexical-let ((s stack)
                     (p pc)
                     (reg-name (stack-inst-reg-name inst))
                     (reg (get-machine-register machine
                                                reg-name)))
         (lambda ()
           (let ((name-value-pair) (stack-pop))
               (if (not (eq reg-name) (car name-value-pair))
                  (error "Restored incorrect register %S -- STACK" reg-name)
                (set-contents! reg (cadr name-value-pair))
                (advance-pc p))))))

  ;; c.
  ;; Associate the stack directly to the register and not to the machine itself
  (defun make-register (nam)
    (lexical-let ((contents '*unassigned)
                  (stack (make-stack))
                  (name nam)
                  (dispatch nil))
      (setq dispatch
            (lambda (message)
              (cond ((eq message 'get) contents)
                    ((eq message 'set)
                     (lambda (value) (setq contents value)))
                    ((eq message 'name) name)
                    ((eq message 'stack) stack)
                    (t
                     (error "Unknown request -- %S REGISTER" message)))))
      dispatch))

  (defun get-register-stack (register)
    (funcall register 'stack))

  ;; Modify the `stack-initialize' from the machine so it
  ;; initializes the stacks
     (defun make-new-machine ()
       (lexical-let* ((pc (make-register 'pc))
                      (flag (make-register 'flag))
                      (the-instruction-sequence '())
                      (stack (make-stack))
                      (register-table
                       (list (list 'pc pc) (list 'flag flag)))
                      (the-ops
                       (list (list 'initialize-stack
                                   (lambda ()
                                     (for-each
                                      (lambda (r)
                                        (funcall (get-register-stack r) 'initialize))
                                      (mapcar 'cadr (register-table)))))))

                      ... )))

  ;; modify the save and restore operations so they retrieve
  ;; their values from the correct stack
  (defun make-save (inst machine stack pc)
    (lexical-let* ((p pc)
                  (reg (get-machine-register machine
                                             (stack-inst-reg-name isnt)))
                  (s (get-register-stack reg)))
      (lambda ()
        (stack-push s (get-contents reg))
        (advance-pc p))))

  (defun make-restore (inst machine stack pc)
    (lexical-let* ((p pc)
                  (reg (get-machine-register machine
                                             (stack-inst-reg-name inst)))
                  (s (get-register-stack reg)))
      (lambda ()
        (set-contents! reg (stack-pop s))
        (advance-pc p))))

#+END_SRC

*** Exercise 5.12
#+BEGIN_SRC elisp
   ;; the structure of the lists to hold the information
  ;;
  ;; 1. instructions list  (inst1 inst2 inst3 ...)
  ;; 2. go-to list         (reg1 reg2 reg3 ...)
  ;; 3. save-restore list  (reg1 reg2 reg3 ...)
  ;; 4. assign       list  ((reg1-name source) (reg2-name source) ...)
  (defun insert-sorted (fun elt lst)
    (cond ((null lst) (list elt))
          ((funcall fun elt (car lst)) (cons elt lst))
          (t (cons (car lst) (insert-sorted fun elt (cdr lst))))))
  
  (insert-sorted 'string< "9"
                 (insert-sorted 'string< "9"
                                (insert-sorted 'string< "10"
                                               (insert-sorted 'string< "1" '()))))
  ;; table has the form of 4. in the list above
  (defun insert-in-table (table index val)
    (cond ((null table) (list (list index (list val))))
          ((eq (caar table) index)
           (cons (list index (cons val (cadar table)))
                 (cdr table)))
          (t (cons (car table)
                   (insert-in-table (cdr table) index val)))))
  
  (defun make-info-tables ()
    (lexical-let ((instructions nil)
                  (goto nil)
                  (save-restore nil)
                  (assign nil)
                  (dispatch nil)
  
                  ; procedures
                  (add-instruction nil)
                  (add-goto nil)
                  (add-save-restore)
                  (add-assign))
      (setq add-instruction
            (lambda (inst)
              (or (member inst instructions)
                  (setq instructions (insert-sorted
                                      (lambda (i)
                                        (symbol-name (car i)))
                                      inst instructions)))))
      (setq add-goto
            (lambda (reg-name)
              (or (member reg-name goto)
                  (setq goto (cons reg-name goto)))))
  
      (setq add-save-restore
            (lambda (reg-name)
              (or (member reg-name save-restore)
                  (setq save-restore (cons reg-name save-restore)))))
  
      (setq add-assign
            (lambda (reg-name source)
              (setq assign (insert-in-table assign reg-name source))))
  
      (setq dispatch
            (lambda (message)
              (cond ((eq message 'add-instruction) add-instruction)
                    ((eq message 'get-instructions) instructions)
                    ((eq message 'add-entry-point) add-goto)
                    ((eq message 'get-entry-points) goto)
                    ((eq message 'add-save-restore) add-save-restore)
                    ((eq message 'get-save-restore) save-restore)
                    ((eq message 'add-register-source) add-assign)
                    ((eq message 'get-register-sources) assign)
                    (t (error "Unknown message %S -- INFO-TABLES" message)))))
      dispatch))
  
  ;; Now that we have a data structure to the info tables,
  ;; make it part of the new machine
  (defun make-new-machine ()
    (lexical-let* ((pc (make-register 'pc))
                   (flag (make-register 'flag))
                   (stack (make-stack))
                   (the-instruction-sequence '())
                   (the-ops
                    (list (list 'initialize-stack
                                (lambda () (funcall stack 'initialize)))))
                   (register-table
                    (list (list 'pc pc) (list 'flag flag)))
                   (info-table (make-info-tables)
                               ...))  ; MORE CODE HERE
      (setq dispatch
            (lambda (message)
              (cond ((eq message 'start)
                     (set-contents! pc the-instruction-sequence)
                     (funcall execute))
                    ((eq message 'install-instruction-sequence)
                     (lambda (seq) (setq the-instruction-sequence seq)))
                    ((eq message 'allocate-register) allocate-register)
                    ((eq message 'get-register) lookup-register)
                    ((eq message 'install-operations)
                     (lambda (ops) (setq the-ops (append the-ops ops))))
                    ((eq message 'get-operations) the-ops)
                    ((eq message 'stack) stack)
                    ((eq message 'operations) the-ops)
                    ((eq message 'info-gables) info-tables)  ; INFO-TABLES ACCESS
                    (t (error "Unknown request -- MACHINE" message)))))
      dispatch))
  
  ;; convenience definitions to access tables
  (defun info-add-instruction (info-tables inst)
    (funcall (funcall info-tables 'add-instruction) inst))
  
  (defun info-get-instructions (machine)
    (funcall (funcall machine 'info-tables) 'instructions)
  
  (defun info-add-register-source (info-tables inst)
    (funcall (funcall info-tables 'add-register-source)
             (assign-reg-name inst)
             (value-exp inst)))
  
  (defun info-get-register-sources (machine)
    (funcall (funcall machine) 'get-register-source))
  
  (defun info-add-entry-point (info-tables inst)
    (funcall (funcall info-tables 'add-entry-point)
             (register-exp-reg (goto-dest inst))))
  
  (defun info-get-entry-points (machine)
    (funcall (funcall machine 'info-tables) 'entry-points))
  
  (defun info-add-save-restore (info-tables inst)
    (funcall (funcall info-tables 'save-restore)
             (stack-inst-reg-name inst)))
  
  (defun info-get-save-restore (machine)
    (funcall (funcall machine 'info-tables) 'save-restore))
  
  ;; In the assemble stage populate the info tables
  (defun make-execution-procedure (inst labels machine pc flag stack ops)
    (let ((name (car inst))
          (info-tables (funcall machine 'info-tables)))
      ;; ex5.12
      (info-add-instruction info-tables inst)
      (cond ((eq name 'assign)
             (info-add-register-source info-table inst)
             (make-assign inst machine labels ops pc))
            ((eq name 'test)
             (make-test inst machine labels ops flag pc))
            ((eq name 'branch)
             (make-branch inst machine labels flag pc))
            ((eq name 'goto)
             (info-add-entry-point info-tables inst)
             (make-goto inst machine labels pc))
            ((eq name 'save)
             (info-add-save-restore info-tables inst)
             (make-save inst machine stack pc))
             ((eq name 'restore)
              (info-add-save-restore info-tables inst)
              (make-restore inst machine stack pc))
              ((eq name 'perform)
               (make-perform inst machine labels ops pc))
              (t (error "Unknown instruction type -- %S ASSEMBLE" inst)))))
  
  ;; PENDING test this with the fib machine
#+END_SRC

* ERRATA (texi version)
** 1.2.4
   - ERROR  : b^n = (b^(b/2))^2    if n is even
   - CORRECT: b^n = (b^(n/2))^2    if n is even
** 1.3.3 Finding fixed points of functions
   - ERROR  : f(x), f(f(x), (f(f(f(x))))
   - CORRECT: f(x), f(f(x)), f(f(f(x)))
   - ERROR  : a technique we that we call "average damping"
   - CORRECT: a technique that we call "average damping"
** 2.2.2 Figure 2.6
   - ERROR:
#+BEGIN_SRC elisp
;           ((1 2) 3 4)
;               /\\
;              /  | \
;          (1 2)  3 4
;           / \
;           1 2
#+END_SRC
   - CORRECT:
#+BEGIN_SRC elisp
  ;           ((1 2) 3 4)
  ;             /    | \
  ;            /     |  \
  ;          (1 2)   3  4
  ;           / \
  ;           1 2
#+END_SRC
** 2.2.4 Exercise 2.30
   - ERROR:   `square-list' should behave as follows:
   - CORRECT: `square-tree should behave as follows:
** 2.2.4 Exercise 2.37
   - ERROR: Exercise 2.37 is set as a header but not a header
   - CORRECT: *Exercise 2.37*: <text>
** 2.2.4 Frames
   - ERROR:   Origin(Frame) + r * Edge_1(Frame) + y * Edge_2(Frame)
   - CORRECT: Origin(Frame) + x * Edge_1(Frame) + y * Edge_2(Frame)
** 2.3.2 Exercise 2.56
   - ERROR:
#+BEGIN_SRC  text
          n_1   n_2
          --- = ---  if and only if n_1 d_2 = n_2 d_1
          d_1   d_2
#+END_SRC

   - CORRECT:
#+BEGIN_SRC text
         d(u^n)            du
         ------ = nu^(n-1) --
           dx              dx
#+END_SRC
** 2.4.3 Data-Directed Programming and Additivity
   - ERROR: Oh the other hand,
   - CORRECT: On the other hand,
** 3.2 The Environment Model of Evaluation
   - ERROR
#+BEGIN_SRC text
                     +--------+
                     |      I |
                     | x: 3   |
                     | y: 5   |
                     +--------+
                        ^  ^
                        |  |
                      C |  | D
          +---------+   |  |   +----------+
          |      II |   |  |   |      III |
          | z: 6    +---+  +---+ m: 1     |
          | x: 7    |          | y: 2     |
          +---------+          +----------+
#+END_SRC

   - CORRECT
#+BEGIN_SRC text
                     +--------+
                     |      I |
                     | x: 3   |
                     | y: 5   |
                     +--------+
                        ^  ^
                        |  |
                      C |  | D
          +---------+   |  |   +----------+
          |      II |   |  |   |      III |
          | z: 6    +---+  +---+ m: 1     |
          | x: 7    |          | y: 2     |
          +---------+          +----------+
               ^                     ^
               |                     |
               A                     B
#+END_SRC
** 3.2.2 Applying Simple Procedures
   - ERROR
#+BEGIN_SRC text
     *Figure 3.5:* Environments created by evaluating `(f 5)' using the
     procedures in *Note Figure 3-4::.

                    +-----------------------------------------------------+
          global -->|                                                     |
          env       +-----------------------------------------------------+
                      ^              ^                ^               ^
          (f 5)       |              |                |               |
                  +------+       +-------+        +------+        +-------+
            E1 -->| a: 5 |  E2 ->| x: 6  |  E3 -->| x: 6 |  E4 -->| x: 10 |
                  |      |       | y: 10 |        |      |        |       |
                  +------+       +-------+        +------+        +-------+
             (sum-of-squares   (+ (square x)       (* x x)         (* x x)
               (+ a 1)            (square u))
               (+ a 2))
#+END_SRC
   - CORRECT: Change (+ a 2) with (* a 2)
#+BEGIN_SRC text
     *Figure 3.5:* Environments created by evaluating `(f 5)' using the
     procedures in *Note Figure 3-4::.

                    +-----------------------------------------------------+
          global -->|                                                     |
          env       +-----------------------------------------------------+
                      ^              ^                ^               ^
          (f 5)       |              |                |               |
                  +------+       +-------+        +------+        +-------+
            E1 -->| a: 5 |  E2 ->| x: 6  |  E3 -->| x: 6 |  E4 -->| x: 10 |
                  |      |       | y: 10 |        |      |        |       |
                  +------+       +-------+        +------+        +-------+
             (sum-of-squares   (+ (square x)       (* x x)         (* x x)
               (+ a 1)            (square u))
               (* a 2))
#+END_SRC
** 3.3.5 Propagation of Constraints
   - ERROR is in the `*' sign corresponding to the (F - 32) box
#+BEGIN_SRC text
         v   +---------+
         ----+ a1      |
             |    *  s +---- F
          +--+ a2      |
          |  +---------+
          |y
          |     +-----+
          +-----+  32 |
                +-----+
#+END_SRC
   - CORRECT
#+BEGIN_SRC text
         v   +---------+
         ----+ a1      |
             |    +  s +---- F
          +--+ a2      |
          |  +---------+
          |y
          |     +-----+
          +-----+  32 |
                +-----+
#+END_SRC
** Exercise 3.41
   - ERROR: ;; continued on next page
   - CORRECT: Remove this comment from the code
** Exercise 3.59
   - ERROR:
#+BEGIN_SRC text
              1             1             1
 c + a_0 x + --- x_1 r^2 + --- a_2 r^3 + --- a_3 r^4 + ...
              2             3             4
#+END_SRC
   - CORRECT:
#+BEGIN_SRC text
              1             1             1
 c + a_0 x + --- a_1 x^2 + --- a_2 x^3 + --- a_3 x^4 + ...
              2             3             4
#+END_SRC
** Exercise 3.73 (Figure 3.33)
   - ERROR
#+BEGIN_SRC text
                        / t
                        |  i
           v  =  v   +  |      dt + R i
                  0     |
                        / 0
#+END_SRC

   - CORRECT
#+BEGIN_SRC text
                           / t
                        1  |
           v  =  v   + --- |  i dt + R i
                  0     C  |
                           / 0
#+END_SRC

** 4.1.5 Data as Programs in reference (2)
   - ERROR: theory "Recursion theory", a branch ...
   - CORRECT: "Recursion theory", a branch ..

** 5.1.5 Figure 5.11 A recursive factorial machine.
   - ERROR:  line that feeds `*' and `-' operations is missing
     #+BEGIN_SRC text
                                       ___
                                      /   \
              +----------*-----------|  =  |
              |          |            \___/
             (X)         |              ^
              |          |              |
              V          |          +---+---+   sn    +-------+
          +-------+      |          |       +---(X)-->|       |
          |  val  |<-(X)-|----------+   n   |         | stack |
          +-----+-+      |          |       |<--(X)---+       |
            ^   |        |          +-------+   rn    +-+-----+
            |   |        |            ^                 |   ^
           (X)  |        |            |                 |   |
            |   |   +----|--------*  (X)                |  (X) sc
            |   |   |    |        |   |             rc (X)  |
            |   |   |    *----.   |   |                 |   |
            |   V   V    |    V   V   |                 V   |
            |  -------   |   -------  |              +------+-+
            |  \  *  /   |   \  -  /  |              |continue+--> controller
            |   --+--    |    --+--   |              +--------+
            |     |      |      |     |               ^      ^
            +-----+      |      +-----+               |      |
                         |                           (X)    (X)
                         |                            |      |
                        / \                   after- / \    / \  fact-
                       /_1_\                  fact  /___\  /___\ done
     #+END_SRC
   - CORRECT:
     #+BEGIN_SRC text
                                       ___
                                      /   \
              +----------*-----------|  =  |
              |          |            \___/
             (X)         |              ^
              |          |              |
              V          |          +---+---+   sn    +-------+
          +-------+      |          |       +---(X)-->|       |
          |  val  |<-(X)-|--------*-+   n   |         | stack |
          +-----+-+      |        | |       |<--(X)---+       |
            ^   |        |        | +-------+   rn    +-+-----+
            |   |        |        |   ^                  |   ^
           (X)  |        |        |   |                 |   |
            |   |   +----|--------*  (X)                |  (X) sc
            |   |   |    |        |   |             rc (X)  |
            |   |   |    *----.   |   |                 |   |
            |   V   V    |    V   V   |                 V   |
            |  -------   |   -------  |              +------+-+
            |  \  *  /   |   \  -  /  |              |continue+--> controller
            |   --+--    |    --+--   |              +--------+
            |     |      |      |     |               ^      ^
            +-----+      |      +-----+               |      |
                         |                           (X)    (X)
                         |                            |      |
                        / \                   after- / \    / \  fact-
                       /_1_\                  fact  /___\  /___\ done
     #+END_SRC
